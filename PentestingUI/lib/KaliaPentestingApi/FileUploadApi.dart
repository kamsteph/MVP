// dart: flutter side helpers
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'dart:io';
import 'package:path/path.dart' as path;

final baseUrl = "http://192.168.106.154:8888";

Future<List<Map<String, dynamic>>> uploadFiles(List<File> files) async {
  if (files.isEmpty) return [];

  var uri = Uri.parse("$baseUrl/upload_files");
  var request = http.MultipartRequest("POST", uri);

  for (var f in files) {
    var stream = http.ByteStream(f.openRead());
    var length = await f.length();
    var multipart = http.MultipartFile('files', stream, length, filename: path.basename(f.path));
    request.files.add(multipart);
  }

  var streamed = await request.send();
  var resp = await http.Response.fromStream(streamed);
  if (resp.statusCode < 200 || resp.statusCode >= 300) {
    throw Exception("Upload failed: ${resp.statusCode} ${resp.body}");
  }
  var body = jsonDecode(resp.body);
  // `body['files']` -> [{id, original_filename, path}, ...]
  return List<Map<String, dynamic>>.from(body['files'] ?? []);
}

Future<Map<String, dynamic>> postScanMultipart({
  required String region,
  required String scanType,
  required String scope,
  required List<String> target,
  required String reportFormat,
  required bool crossDomainInsight,
  required String name,
  required String description,
  required Map<String, dynamic> tools,
  List<File>? codebaseFiles,
  List<File>? insiderFiles,
  List<dynamic>? attackSurface, // <-- now flexible
}) async {
  var uri = Uri.parse("$baseUrl/scan");
  var request = http.MultipartRequest("POST", uri);

  // Normalize attackSurface into List<String>? for payload
  List<String>? attackSurfaceForPayload;
  if (attackSurface != null) {
    attackSurfaceForPayload = attackSurface.map<String>((entry) {
      if (entry is String) {
        return entry;
      } else if (entry is Map) {
        // prefer 'name' then 'surface' as the human-friendly key
        if (entry.containsKey('name') && entry['name'] != null) {
          return entry['name'].toString();
        } else if (entry.containsKey('surface') && entry['surface'] != null) {
          return entry['surface'].toString();
        } else {
          // fallback: stringify the map (you may want to change this behavior)
          return entry.toString();
        }
      } else {
        // any other unexpected type -> stringify it
        return entry.toString();
      }
    }).toList();
  } else {
    attackSurfaceForPayload = null;
  }

  // JSON blob for everything except files
  final payload = jsonEncode({
    "region": region,
    "scan_type": scanType,
    "scope": scope,
    "target": target,
    "attack_surface": attackSurfaceForPayload,
    "cross_domain_insight": crossDomainInsight,
    "name": name,
    "description": description,
    "tools": tools,
  });
  request.fields["payload"] = payload;

  // Add codebase files
  if (codebaseFiles != null) {
    for (final file in codebaseFiles) {
      final stream = http.ByteStream(file.openRead());
      final length = await file.length();
      request.files.add(http.MultipartFile(
        'codebase_files',
        stream,
        length,
        filename: path.basename(file.path),
      ));
    }
  }

  // Add insider files
  if (insiderFiles != null) {
    for (final file in insiderFiles) {
      final stream = http.ByteStream(file.openRead());
      final length = await file.length();
      request.files.add(http.MultipartFile(
        'insider_files',
        stream,
        length,
        filename: path.basename(file.path),
      ));
    }
  }

  // Send
  var streamedResponse = await request.send();
  var response = await http.Response.fromStream(streamedResponse);

  if (response.statusCode < 200 || response.statusCode >= 300) {
    throw Exception("Scan request failed: ${response.statusCode} ${response.body}");
  }

  return jsonDecode(response.body) as Map<String, dynamic>;
}
