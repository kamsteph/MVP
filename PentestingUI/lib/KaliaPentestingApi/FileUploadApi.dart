// dart: flutter side helpers
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'dart:io';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';
import 'package:flutter/material.dart';

// For JWT storage (later you can use flutter_secure_storage)
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

final baseUrl = "http://192.168.106.154:8888";
final secureStorage = FlutterSecureStorage();

/// --- JWT SECTION (add this helper) ---
Future<Map<String, String>> _authHeaders() async {
  final token = await secureStorage.read(key: 'jwt_token');
  if (token == null) return {};
  return {
    HttpHeaders.authorizationHeader: 'Bearer $token',
  };
}
/// -------------------------------------

Future<void> downloadReport(String taskId, BuildContext context, String reportFormat) async {
  try {
    final url = '$baseUrl/download_report/$taskId';

    /// --- JWT SECTION ---
    //final headers = await _authHeaders();
    //final response = await http.get(Uri.parse(url), headers: headers);
    /// --------------------

    final response = await http.get(Uri.parse(url));
    if (response.statusCode == 200) {
      final directory = await getApplicationDocumentsDirectory();

      final extension = reportFormat == "json"
          ? "json"
          : reportFormat == "md"
          ? "md"
          : "pdf";

      final filePath = '${directory.path}/${taskId}_report.$extension';
      final file = File(filePath);
      await file.writeAsBytes(response.bodyBytes);

      _showCustomSnackBar(context, "Report downloaded to $filePath");
    } else {
      _showCustomSnackBar(context, "Failed to download report: ${response.statusCode}", isError: true);
    }
  } catch (e) {
    _showCustomSnackBar(context, "Error downloading report: $e", isError: true);
  }
}

void _showCustomSnackBar(BuildContext context, String message, {bool isError = false}) {
  final snackBar = SnackBar(
    content: Text(message),
    backgroundColor: isError ? Colors.red : Colors.green,
  );
  ScaffoldMessenger.of(context).showSnackBar(snackBar);
}

Future<List<Map<String, dynamic>>> uploadFiles(List<File> files) async {
  if (files.isEmpty) return [];

  var uri = Uri.parse("$baseUrl/upload_files");
  var request = http.MultipartRequest("POST", uri);

  /// --- JWT SECTION ---
  //final headers = await _authHeaders();
  //request.headers.addAll(headers);
  /// --------------------

  for (var f in files) {
    var stream = http.ByteStream(f.openRead());
    var length = await f.length();
    var multipart = http.MultipartFile('files', stream, length, filename: path.basename(f.path));
    request.files.add(multipart);
  }

  var streamed = await request.send();
  var resp = await http.Response.fromStream(streamed);
  if (resp.statusCode < 200 || resp.statusCode >= 300) {
    throw Exception("Upload failed: ${resp.statusCode} ${resp.body}");
  }
  var body = jsonDecode(resp.body);
  return List<Map<String, dynamic>>.from(body['files'] ?? []);
}

Future<Map<String, dynamic>> postScanMultipart({
  required String region,
  required String scanType,
  required String scope,
  required List<String> target,
  required String reportFormat,
  required bool crossDomainInsight,
  required String name,
  required String description,
  required Map<String, dynamic> tools,
  List<File>? codebaseFiles,
  List<File>? insiderFiles,
  List<dynamic>? attackSurface,
}) async {
  var uri = Uri.parse("$baseUrl/scan");
  var request = http.MultipartRequest("POST", uri);

  List<dynamic>? attackSurfaceForPayload;

  if (attackSurface != null) {
    attackSurfaceForPayload = attackSurface.map<dynamic>((entry) {
      if (entry is String) {
        // already plain string: wrap into map for server consistency
        return {"surface": entry};
      } else if (entry is Map) {
        // Keep map but try to normalize naming:
        if (entry.containsKey('surface') && entry['surface'] != null) {
          // ensure it's a string
          return {"surface": entry['surface'].toString()};
        } else if (entry.containsKey('name') && entry['name'] != null) {
          return {"surface": entry['name'].toString()};
        } else {
          // if it's a map with unknown shape, stringify only the surface-ish keys
          // but better keep the map as-is (server will normalize)
          return entry.map((k, v) => MapEntry(k.toString(), v));
        }
      } else {
        // fallback: stringify
        return {"surface": entry.toString()};
      }
    }).toList();
  } else {
    attackSurfaceForPayload = null;
  }
  /// --- JWT SECTION ---
  //final headers = await _authHeaders();
  //request.headers.addAll(headers);
  /// --------------------

  // Prepare JSON payload
  final payload = jsonEncode({
    "region": region,
    "scan_type": scanType,
    "scope": scope,
    "target": target,
    "attack_surface": attackSurfaceForPayload,
    "cross_domain_insight": crossDomainInsight,
    "name": name,
    "description": description,
    "tools": tools,
  });
  request.fields["payload"] = payload;

  // Add files
  if (codebaseFiles != null) {
    for (final file in codebaseFiles) {
      final stream = http.ByteStream(file.openRead());
      final length = await file.length();
      request.files.add(http.MultipartFile(
        'codebase_files', stream, length, filename: path.basename(file.path),
      ));
    }
  }

  if (insiderFiles != null) {
    for (final file in insiderFiles) {
      final stream = http.ByteStream(file.openRead());
      final length = await file.length();
      request.files.add(http.MultipartFile(
        'insider_files', stream, length, filename: path.basename(file.path),
      ));
    }
  }

  var streamedResponse = await request.send();
  var response = await http.Response.fromStream(streamedResponse);

  if (response.statusCode < 200 || response.statusCode >= 300) {
    throw Exception("Scan request failed: ${response.statusCode} ${response.body}");
  }

  return jsonDecode(response.body) as Map<String, dynamic>;
}
