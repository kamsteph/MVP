# new_module/gnn_brain.py
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch_geometric.data import Data
from torch_geometric.nn import GCNConv


class PentestGNN(nn.Module):
    """
    A small realistic GCN for pentest decision-making.
    Input: Graph of hosts, ports, vulns
    Output: Action class (0=exploitation, 1=deeper_scan)
    """
    def __init__(self, in_channels: int, hidden_channels: int, out_channels: int):
        super().__init__()
        self.conv1 = GCNConv(in_channels, hidden_channels)
        self.conv2 = GCNConv(hidden_channels, out_channels)

    def forward(self, x, edge_index):
        # x: Node feature matrix [num_nodes, in_channels]
        # edge_index: Graph edges (2, num_edges)
        x = self.conv1(x, edge_index)
        x = F.relu(x)
        x = self.conv2(x, edge_index)
        return F.log_softmax(x, dim=1)


class GNNBrain:
    def __init__(self, model_path: str = None, in_channels: int = 3):
        self.model = PentestGNN(in_channels=in_channels, hidden_channels=8, out_channels=2)
        if model_path:
            self.model.load_state_dict(torch.load(model_path))
        self.model.eval()

    def predict(self, scan_results: list[dict]) -> str:
        if isinstance(scan_results, dict):
            scan_results = [scan_results]

        graph = self._build_graph(scan_results)

        with torch.no_grad():
            out = self.model(graph.x, graph.edge_index)
            out_mean = out.mean(dim=0)  # aggregate node predictions
            pred_idx = out_mean.argmax().item()

        return "exploitation" if pred_idx == 1 else "deeper_scan"


    def _build_graph(self, results: list[dict]) -> Data:
        """
        Turn multiple scan results into a graph for the GNN.
        Each result becomes a node, edges represent relationships (same target, same IP, etc.).
        """

        nodes = []
        edges = []

        # Example feature extraction from results
        for idx, res in enumerate(results):
            # Each node gets basic features (example: risk level, num vulns, etc.)
            features = [
                len(res.get("vulnerabilities", [])),
                1 if res.get("risk", "").lower() == "high" else 0,
                1 if res.get("risk", "").lower() == "medium" else 0,
                1 if res.get("risk", "").lower() == "low" else 0,
            ]
            nodes.append(features)

            # Naive edges: connect each node to the next
            if idx > 0:
                edges.append([idx - 1, idx])

        # Convert to tensors
        x = torch.tensor(nodes, dtype=torch.float)
        if edges:
            edge_index = torch.tensor(edges, dtype=torch.long).t().contiguous()
        else:
            edge_index = torch.empty((2, 0), dtype=torch.long)

        return Data(x=x, edge_index=edge_index)