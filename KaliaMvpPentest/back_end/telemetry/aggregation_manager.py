# back_end/aggregation_manager.py
from typing import Dict, Any
from datetime import datetime
from back_end.cpu_ai_inference.telemetry_tracking import TelemetryTracker
from back_end.utils.colored_logger import get_logger

logger = get_logger(__name__, component="AGGREGATION", region="GLOBAL")


class AggregationManager:
    """
    Aggregates multiple tool outputs (Masscan, Naabu, Nmap, etc.)
    into unified results and reports telemetry for AI orchestration.
    """

    def __init__(self, db, model_name, bus=None):
        self.db = db
        self.bus = bus
        self.telemetry = TelemetryTracker(db, model_name=model_name)

    async def aggregate_partial_results(self, recon_results: Dict[str, Any], task_id="unknown", user_id="anonymous"):
        """
        Merge scan results (Masscan + Naabu + Nmap) into unified structure.
        Also publishes an event when aggregation is complete.
        """
        async def _aggregate():
            ports, services = set(), {}
            for tool, data in recon_results.get("tools", {}).items():
                for entry in data.get("open_ports", []):
                    ports.add(entry)
                for svc, info in data.get("services", {}).items():
                    services[svc] = info

            merged = {
                "open_ports": sorted(list(ports)),
                "services": services,
                "aggregated_at": datetime.utcnow().isoformat(),
                "tool_count": len(recon_results.get("tools", {}))
            }
            logger.info(f"[Aggregation] Aggregated {len(ports)} ports and {len(services)} services.")
            return merged

        wrapped = await self.telemetry.track_scan(task_id, user_id, _aggregate)

        result = wrapped.get("result", {})
        if self.bus:
            event_payload = {
                "event": "aggregation_complete",
                "task_id": task_id,
                "result": result,
                "telemetry": wrapped.get("telemetry", {}),
                "timestamp": datetime.utcnow().isoformat()
            }
            self.bus.publish_event("aggregation_complete", event_payload)
            logger.info(f"[Aggregation] Published aggregation_complete event for task {task_id}")

        return wrapped
