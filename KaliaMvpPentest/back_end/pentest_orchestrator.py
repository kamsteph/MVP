# back_end/orchestrator.py (modernized for NetworkPipeline integration)
import uuid
from datetime import datetime
from typing import Dict, Any, List, Union
import asyncio

from G_L_L.l_region.Aggregation_area import correlator
from Network_Pentest.network.utils.cipr_helper import normalize_targets
from back_end.network_cap_matrix import NETWORK_CAPABILITY_MATRIX
from back_end.mini_transformer.attack_surface_translator import AttackSurfaceTranslator
from back_end.mini_transformer.attack_surfaces import ATTACK_SURFACE_MAP
from back_end.utils.colored_logger import get_logger
from back_end.pentest_research import PentestResearchRAG

# import your unified pipeline


logger = get_logger(__name__, component="ORCHESTRATOR", region="CONTROLLER")
translator = AttackSurfaceTranslator()


class PentestOrchestrator:
    """
    AI-Orchestrator (Controller)
    ----------------------------
    - Dispatches network, web, or hybrid scans.
    - Expands and normalizes user requests.
    - For network scans, delegates execution to NetworkPipeline.
    - Performs RAG-based enrichment and contextualization.
    """

    def __init__(self,db,bus,network_pipeline):
        self.bus = bus
        self.db = db
        self.rag = PentestResearchRAG()
        self.network_pipeline = network_pipeline
        self.regions = ["network", "web"]
        self.completed_tasks = []
        logger.info("[Orchestrator] Initialized. Ready for regions: %s", self.regions)

    # ------------------------------------------------------------
    #  Attack surface expansion utilities
    # ------------------------------------------------------------
    def _expand_full_surfaces(self, raw: List[str]) -> List[str]:
        """Expand 'full' to all known surfaces."""
        if any(x in ("full", "all_surfaces") for x in raw):
            try:
                return list(ATTACK_SURFACE_MAP.keys())
            except Exception:
                return [m["attack_surface"] for m in NETWORK_CAPABILITY_MATRIX]
        return raw

    def _expand_aspects_to_surfaces(self, raw: List[str]) -> List[str]:
        """Map aspects like 'reachability' or 'deep_scan' to real surfaces."""
        aspect_keywords = {"asset_enumeration", "reachability", "deep_scan"}
        if not any(s in aspect_keywords for s in raw):
            return raw
        expanded = []
        for spec in raw:
            if spec in aspect_keywords:
                for m in NETWORK_CAPABILITY_MATRIX:
                    if spec in m.get("aspects", []) or m.get("aspect") == spec:
                        expanded.append(m["attack_surface"])
            else:
                expanded.append(spec)
        return list(dict.fromkeys(expanded))  # deduplicate

    # ------------------------------------------------------------
    #  Main entry point
    # ------------------------------------------------------------
    async def submit_scan_request(
            self,
            region: str,
            scan_type: str,
            scope: str,
            target: Union[str, List[str]],
            cross_domain_insight: bool = False,
            **kwargs,
    ) -> Dict[str, Any]:
        """
        Entry point from UI or CLI.
        Handles normalization, RAG enrichment, and dispatch to pipelines.
        """

        if region not in self.regions:
            raise ValueError(f"Unknown region '{region}'. Supported: {self.regions}")
        if not target:
            raise ValueError("Target required.")

        # Normalize target (single IP, range, or CIDR)
        subnetmask_enabled = kwargs.get("subnet_mask", False)
        explicit, retained = normalize_targets(target, subnetmask_enabled=subnetmask_enabled)
        target = explicit + retained
        ipv6_enabled = any(":" in t for t in target)

        # --- Scope & RAG reasoning ---
        research_notes = {"note": "Black-box minimal reconnaissance."}
        if scope == "white":
            research_notes = self.rag.research(f"Internal {region} pentest for {target}") or research_notes
        elif scope == "grey":
            research_notes = self.rag.research(f"Grey-box {region} pentest for {target}") or research_notes

        # --- Surface expansion ---
        raw_surfaces = kwargs.get("attack_surface", ["full"])
        expanded = self._expand_aspects_to_surfaces(self._expand_full_surfaces(raw_surfaces))

        # Enrich surfaces
        resolved_surface = []
        for surf in expanded:
            matrix_def = next((m for m in NETWORK_CAPABILITY_MATRIX if m.get("attack_surface") == surf), None)
            enrichment = self.rag.research(f"Explain risks and CVEs for {surf}.") if self.rag else {}
            resolved_surface.append({"surface": surf, "definition": matrix_def, "enrichment": enrichment})

        # --- Build task metadata ---
        task_id = str(uuid.uuid4())

        mode = kwargs.get("mode")
        if not mode:
            # e.g., scan_type might be "train_network" or UI flag
            if "train" in (scan_type or "").lower() or kwargs.get("deploy_honeypot"):
                mode = "train"
            else:
                mode = "live"

        hints = {
            "scope": scope,
            "attack_surface": resolved_surface,
            "ipv6_enabled": ipv6_enabled,
            "explicit_surfaces": raw_surfaces != ["full"],  # marks if user manually picked surfaces
            "cross_domain_info": {},
            "mode": mode
        }

        task = {
            "id": task_id,
            "region": region,
            "action": f"initial_{region}_scan",
            "target": target,
            "scan_type": scan_type,
            "scope": scope,
            "research": research_notes,
            "hints": hints,
            "created_at": datetime.now().isoformat(),
        }

        # Save initial task record
        self.db.results.insert_one({
            "_id": task_id,
            "task": task,
            "status": "queued",
            "created_at": datetime.now()
        })

        # Optional: correlate cross-domain learning
        if cross_domain_insight:
            events = list(self.db.learning_data.find({}))
            hints["cross_domain_info"] = correlator.compute_cross_domain_potential(events)

        # --- Dispatch ---
        logger.info("[Orchestrator] Dispatching %s (%s targets)", task_id, len(target))
        if region == "network":
            await self._dispatch_network_pipeline(task, target)
        else:
            logger.warning("[Orchestrator] Region '%s' not yet implemented.", region)

        return {
            "status": "accepted",
            "task_id": task_id,
            "targets": target,
            "surfaces": [s["surface"] for s in resolved_surface],
            "message": f"Network pipeline initiated with {len(target)} targets."
        }

    # ------------------------------------------------------------
    # Network pipeline dispatch logic
    # ------------------------------------------------------------
    async def _dispatch_network_pipeline(self, task: Dict[str, Any], targets: List[str]):
        """Decide whether to skip recon or run full mapping."""
        hints = task["hints"]
        task_id = task["id"]

        #task_id = task["id"]
        #hints = task.get("hints", {})


        logger.info(f"[Orchestrator] Dispatching NetworkPipeline for task {task_id}")
        # Explicit surfaces means user knows what to test → skip recon
        if hints.get("explicit_surfaces"):
            logger.info(f"[Orchestrator] Task {task_id}: explicit surfaces defined → skipping discovery.")
            await self.network_pipeline.run(targets, task_id=task_id, hints=hints)
            return

        # Full CIDR or multi-host → perform recon and mapping
        logger.info(f"[Orchestrator] Task {task_id}: initiating full recon + mapping pipeline.")
        await self.network_pipeline.run(targets, task_id=task_id, hints=hints)

    # ------------------------------------------------------------
    # Completion callback
    # ------------------------------------------------------------
    def handle_completed_task(self, task_result: Dict[str, Any]):
        """Triggered when downstream components signal completion."""
        self.completed_tasks.append(task_result)
        logger.info("[Orchestrator] Task %s completed.", task_result.get("id"))