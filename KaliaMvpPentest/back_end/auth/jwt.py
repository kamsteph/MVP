# # back_end/auth.py
# import os
# import json
# import time
# from typing import Dict, Any
# import requests
# from jose import jwk, jwt, JWTError
# from jose.utils import base64url_decode
# from fastapi import HTTPException, Security, Depends
# from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
#
# JWKS_URL = os.getenv("JWKS_URL")        # e.g. https://<domain>/.well-known/jwks.json
# ISSUER = os.getenv("JWT_ISSUER")       # e.g. https://<domain>/
# AUDIENCE = os.getenv("JWT_AUDIENCE")   # your API identifier
#
# _authed = HTTPBearer(auto_error=False)
#
# # cache JWKS in memory with a refresh TTL
# _jwks_cache = {"keys": None, "fetched_at": 0}
# JWKS_TTL = 60 * 60  # 1 hour
#
#
# def get_jwks() -> Dict[str, Any]:
#     now = time.time()
#     if _jwks_cache["keys"] is None or now - _jwks_cache["fetched_at"] > JWKS_TTL:
#         r = requests.get(JWKS_URL, timeout=5)
#         r.raise_for_status()
#         _jwks_cache["keys"] = r.json()
#         _jwks_cache["fetched_at"] = now
#     return _jwks_cache["keys"]
#
#
# def verify_jwt_token(token: str) -> Dict[str, Any]:
#     jwks = get_jwks()
#     headers = jwt.get_unverified_header(token)
#     kid = headers.get("kid")
#     if not kid:
#         raise HTTPException(status_code=401, detail="Invalid token header")
#
#     key = next((k for k in jwks["keys"] if k["kid"] == kid), None)
#     if key is None:
#         # refresh cache once and try again
#         _jwks_cache["keys"] = None
#         jwks = get_jwks()
#         key = next((k for k in jwks["keys"] if k["kid"] == kid), None)
#         if key is None:
#             raise HTTPException(status_code=401, detail="Public key not found in JWKS")
#
#     public_key = jwk.construct(key)
#     # verify signature and claims using python-jose
#     try:
#         payload = jwt.decode(
#             token,
#             key,
#             algorithms=key.get("alg", "RS256"),
#             audience=AUDIENCE,
#             issuer=ISSUER,
#         )
#         # you can customize claim checks here (roles/scopes)
#         return payload
#     except JWTError as e:
#         raise HTTPException(status_code=401, detail=f"Token invalid: {e}")
#
#
# async def get_current_user(credentials: HTTPAuthorizationCredentials = Security(_authed)):
#     if not credentials:
#         raise HTTPException(status_code=401, detail="Missing authorization token")
#     token = credentials.credentials
#     payload = verify_jwt_token(token)
#     # Minimal user object; you can add DB lookup if you want a user profile
#     return {"sub": payload.get("sub"), "claims": payload}
