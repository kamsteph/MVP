# new_module/database.py
from datetime import datetime

from pymongo import MongoClient
from dotenv import load_dotenv
from typing import List

# Load environment variables from .env file
load_dotenv()

class DatabaseManager:
    """
    Manages all database connections for the AI Pentest Platform.
    Using MongoDB as the primary data store.
    """
    def __init__(self):
        #self.client = MongoClient("mongodb+srv://kamsteph:Test1234@kaliacluster.mzupz.mongodb.net/?retryWrites=true&w=majority&appName=kaliaCluster")
        self.client=MongoClient("mongodb://localhost:27017/")
        self.db = self.client.get_database("ai_pentest_dbs")

        # Collections
        self.exploit_asset=self.db.get_collection("exploit_assets")
        self.standard_db = self.db.get_collection("standard_db")
        self.save_codebase=self.db.get_collection("save_codebase")
        self.learning_data = self.db.get_collection("stage_learning_area")
        self.adb_collection = self.db.get_collection("augmented_database") #Threat Intel DB
        self.agent_memory=self.client.get_database("agent_memory")
        self.capability_matrix=self.db.get_collection("capability_matrix")
        self.telemetry_logs=self.db.get_collection("telemetry_logs")

    def get_logs(self):
        return self.telemetry_logs.find({})

    def save_scan_result(self, result: dict):
        """Saves a scan result to the 'scan_results' collection."""
        return self.standard_db.insert_one(result)

    def get_unprocessed_results(self):
        """Retrieves scan results that have not yet been processed by the L-Region."""
        return self.standard_db.find({"l_region_processed": False})

    def mark_as_processed(self, result_id):
        """Marks a result as processed by the L-Region."""
        self.standard_db.update_one({"_id": result_id}, {"$set": {"l_region_processed": True}})

    def save_learning_data(self, data: dict):
        """Saves a new learning point or exploit to the 'learning_data' collection."""
        return self.learning_data.insert_one(data)

    def get_all_threat_intel(self):
        """Retrieves all threat intelligence from the ADB."""
        return self.adb_collection.find({})

    def get_cap_matrix(self):
        return self.capability_matrix.find({})

    def save_memory_state(self, memory: dict):
        return self.agent_memory.insert_one(memory)

    def get_memory_state(self, target_ip: str):
        return self.agent_memory.find_one({"target_ip": target_ip})

    def save_codebase(self, memory: dict):
        return self.save_codebase.insert_one(memory)

    def save_tool_capability(self, tool_doc: dict):
        """Insert or update a tool capability document."""
        return self.capability_matrix.update_one(
            {"tool": tool_doc["tool"]},
            {"$set": tool_doc},
            upsert=True
        )

    def get_tool_capabilities(self, surfaces: List[str] = None):
        """Retrieve tools, optionally filtered by supported attack surfaces."""
        if surfaces:
            return list(self.capability_matrix.find({"surfaces": {"$in": surfaces}}))
        return list(self.capability_matrix.find({}))

    def query(self,filter_query: dict = None, projection: dict = None):
        """Run a query on any collection."""
        filter_query = filter_query or {}
        return list(self.exploit_asset.find(filter_query, projection or {}))

    def find_one(self,filter_query: dict):
        """Find a single document by filter."""
        return self.exploit_asset.find_one(filter_query)

    def update(self,filter_query: dict, update_doc: dict, upsert: bool = True):
        """Update (or upsert) a document."""
        return self.exploit_asset.update_one(filter_query, {"$set": update_doc}, upsert=upsert)

    def insert_many(self, docs: list):
        """Insert many documents into a collection."""
        if not docs:
            return None
        return self.exploit_asset.insert_many(docs)

    @property
    def adb(self):
        """Shortcut to the augmented database (ADB) collection."""
        return self.adb_collection

        # -- Exploit assets helpers ------------------------------------------------
    def insert_exploit_asset(self, asset_doc: dict):
        """
        Insert one exploit asset into the `exploit_assets` collection.
        Use asset_doc keys per the recommended schema (asset_id optional).
        Returns InsertOneResult.
        """
        return self.exploit_asset.insert_one(asset_doc)

    def upsert_exploit_asset(self, unique_filter: dict, asset_doc: dict):
        """
        Upsert an exploit asset using a unique filter (eg {"value": url} or {"asset_id": id}).
        Returns UpdateResult.
        """
        coll = self.db.get_collection("exploit_assets")
        return coll.update_one(unique_filter, {"$set": asset_doc}, upsert=True)

    def find_exploit_assets(self, filter_query: dict = None, projection: dict = None, limit: int = 0):
        """
        Query exploit_assets. Returns a cursor/list.
        """
        cursor = self.exploit_asset.find(filter_query or {}, projection or {})
        if limit and limit > 0:
            return list(cursor.limit(limit))
        return list(cursor)

    def create_exploit_assets_indexes(self):
        """
        Create recommended indexes for fast lookup.
        Run once after populating the collection.
        """
        self.exploit_asset.create_index("asset_id", unique=True, sparse=True)
        self.exploit_asset.create_index("cves")
        self.exploit_asset.create_index("type")
        self.exploit_asset.create_index([("service", 1), ("vendor", 1)])
        self.exploit_asset.create_index("value")
        return True

    def count_exploit_assets(self, filter_query: dict = None):
        return self.exploit_asset.count_documents(filter_query or {})

    def upsert_tool_hint(self, attack_surface: str, tool_name: str, score: float, success_count: int = 0, total_count: int = 0):
        doc = {
            "attack_surface": attack_surface,
            "tool": tool_name,
            "score": float(score),
            "success_count": int(success_count),
            "total_count": int(total_count),
            "updated_at": datetime.now()
        }
        return self.capability_matrix.update_one({"attack_surface": attack_surface, "tool": tool_name},
                                                 {"$set": doc}, upsert=True)

    def get_tool_hints(self, attack_surface: str):
        return list(self.capability_matrix.find({"attack_surface": attack_surface}))

