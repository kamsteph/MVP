# new_module/database.py
from pymongo import MongoClient
import os
from dotenv import load_dotenv
from typing import List

# Load environment variables from .env file
load_dotenv()

class DatabaseManager:
    """
    Manages all database connections for the AI Pentest Platform.
    Using MongoDB as the primary data store.
    """
    def __init__(self):
        self.client = MongoClient(os.getenv("MONGO_URI", "mongodb://localhost:27017/"))
        self.db = self.client.get_database("ai_pentest_dbs")

        # Collections
        self.results = self.db.get_collection("standard_db")
        self.save_codebase=self.db.get_collection("save_codebase")
        self.learning_data = self.db.get_collection("stage_learning_area")
        self.adb_collection = self.db.get_collection("augmented_database") #Threat Intel DB
        self.agent_memory=self.client.get_database("agent_memory")
        self.capability_matrix=self.db.get_collection("capability_matrix")

    def save_scan_result(self, result: dict):
        """Saves a scan result to the 'scan_results' collection."""
        return self.results.insert_one(result)

    def get_unprocessed_results(self):
        """Retrieves scan results that have not yet been processed by the L-Region."""
        return self.results.find({"l_region_processed": False})

    def mark_as_processed(self, result_id):
        """Marks a result as processed by the L-Region."""
        self.results.update_one({"_id": result_id}, {"$set": {"l_region_processed": True}})

    def save_learning_data(self, data: dict):
        """Saves a new learning point or exploit to the 'learning_data' collection."""
        return self.learning_data.insert_one(data)

    def get_all_threat_intel(self):
        """Retrieves all threat intelligence from the ADB."""
        return self.adb_collection.find({})

    def save_memory_state(self, memory: dict):
        return self.agent_memory.insert_one(memory)

    def get_memory_state(self, target_ip: str):
        return self.agent_memory.find_one({"target_ip": target_ip})

    def save_codebase(self, memory: dict):
        return self.save_codebase.insert_one(memory)

    def save_tool_capability(self, tool_doc: dict):
        """Insert or update a tool capability document."""
        return self.capability_matrix.update_one(
            {"tool": tool_doc["tool"]},
            {"$set": tool_doc},
            upsert=True
        )

    def get_tool_capabilities(self, surfaces: List[str] = None):
        """Retrieve tools, optionally filtered by supported attack surfaces."""
        if surfaces:
            return list(self.capability_matrix.find({"surfaces": {"$in": surfaces}}))
        return list(self.capability_matrix.find({}))