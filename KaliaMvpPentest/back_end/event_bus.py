# modified EventBus (drop-in replacement)
import asyncio
import inspect
import logging
from typing import Dict, Any, Callable, List, Optional
from back_end.utils.colored_logger import get_logger

logger = get_logger(__name__, component="EVENTBUS", region="ROUTE")
logger.setLevel(logging.DEBUG)

class EventBus:
    def __init__(self):
        self.subscribers: Dict[str, List[Callable]] = {}
        self.published_keys = set()   # keep idempotency keys (in-memory; persist for multi-instance)
        logger.info("EventBus initialized")

    def subscribe(self, event_name: str, handler: Callable):
        if event_name not in self.subscribers:
            self.subscribers[event_name] = []
        self.subscribers[event_name].append(handler)
        try:
            handler_name = handler.__name__
        except Exception:
            handler_name = repr(handler)
        logger.info(f"Handler {handler_name} subscribed to event '{event_name}'")

    def _maybe_schedule(self, handler: Callable, payload: Any):
        try:
            if inspect.iscoroutinefunction(handler):
                asyncio.create_task(handler(payload))
                return
            res = handler(payload)
            if inspect.iscoroutine(res):
                asyncio.create_task(res)
                return
        except Exception as e:
            logger.exception("Error while scheduling handler: %s", e)

    def publish_task(self, task: Dict[str, Any], key: Optional[str] = None):
        """
        Publish a task. Optionally pass an idempotency `key` to prevent duplicate publishing.
        NOTE: in-memory idempotency is ephemeral â€” for multi-instance you need persistent store.
        """
        if key:
            if key in self.published_keys:
                logger.info("Duplicate publish suppressed for key=%s", key)
                return {"status": "duplicate", "key": key}
            # record key
            self.published_keys.add(key)

        # Generic "task" subscribers first
        for handler in self.subscribers.get("task", []):
            self._maybe_schedule(handler, task)

        # Validate region
        region = task.get("region")
        if not region or region not in self.subscribers:
            logger.error(f"No subscribers for region '{region}' or region not specified.")
            return {"status": "no_subscribers", "region": region}

        logger.debug(f"Publishing task for region='{region}': {task}")

        for handler in self.subscribers[region]:
            try:
                self._maybe_schedule(handler, task)
            except Exception as e:
                try:
                    handler_name = handler.__name__
                except Exception:
                    handler_name = repr(handler)
                logger.exception(f"Error scheduling task for region '{region}' by handler '{handler_name}': {e}")

        return {"status": "published", "region": region, "key": key}

    def publish_event(self, event_name: str, payload: Dict[str, Any], key: Optional[str] = None):
        if key:
            if key in self.published_keys:
                logger.info("Duplicate event suppressed for key=%s", key)
                return {"status": "duplicate", "key": key}
            self.published_keys.add(key)

        if event_name not in self.subscribers:
            logger.warning(f"No subscribers for event '{event_name}'.")
            return {"status": "no_subscribers", "event": event_name}

        logger.debug(f"Publishing event '{event_name}': {payload}")
        for handler in self.subscribers[event_name]:
            try:
                self._maybe_schedule(handler, payload)
            except Exception as e:
                try:
                    handler_name = handler.__name__
                except Exception:
                    handler_name = repr(handler)
                logger.exception(f"Error scheduling handler '{handler_name}' for event '{event_name}': {e}")

        return {"status": "published", "event": event_name}
