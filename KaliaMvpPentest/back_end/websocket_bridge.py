import asyncio
import websockets
import json
from back_end.event_bus import EventBus

class WebSocketBridge:
    """
    Bridges internal EventBus messages to external WebSocket clients.
    """

    def __init__(self, event_bus: EventBus):
        self.event_bus = event_bus
        self.clients = set()
        self.server = None  # will hold the running WebSocket server

        # Subscribe to events from the EventBus
        event_bus.subscribe("scan_progress", self.forward_event)
        event_bus.subscribe("scan_complete", self.forward_event)

    async def forward_event(self, payload):
        """
        Forwards an event from the EventBus to all connected WebSocket clients.
        """
        message = json.dumps({
            "event": payload.get("event", "unknown"),
            "payload": payload
        })
        # Send to all connected clients
        await asyncio.gather(
            *[client.send(message) for client in list(self.clients)],
            return_exceptions=True
        )

    async def handler(self, websocket, path):
        """
        Handles a new WebSocket client connection.
        """
        self.clients.add(websocket)
        try:
            async for _ in websocket:
                pass  # Keep connection alive
        finally:
            self.clients.discard(websocket)

    async def start(self, host="192.168.106.154", port=4000):
        """
        Starts the WebSocket server and keeps a reference so we can stop it later.
        """
        self.server = await websockets.serve(self.handler, host, port)
        print(f"[WebSocketBridge] Listening on ws://{host}:{port}")

    async def stop(self):
        """
        Stops the WebSocket server gracefully and releases the port.
        """
        if self.server:
            self.server.close()              # stop accepting new connections
            await self.server.wait_closed()  # wait until fully closed
            print("[WebSocketBridge] Server stopped")
            self.server = None               # reset reference
        # Also disconnect clients
        for client in list(self.clients):
            await client.close()
        self.clients.clear()
