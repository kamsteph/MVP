# tests_network/Integration_test/test_exploitation_flow.py
import pytest
from unittest.mock import MagicMock, AsyncMock
from Network_Pentest.network.Sub_Unit_Manager_Network.network_exploitation_manager import ExploitationManagerAI


@pytest.mark.asyncio
async def test_exploitation_manager_with_candidates(monkeypatch):
    fake_db = MagicMock()
    fake_db.get_memory_state.return_value = {}

    fake_bus = MagicMock()

    # Patch EventBus constructor so ExploitationManagerAI uses our fake_bus
    monkeypatch.setattr(
        "Network_Pentest.network.Sub_Unit_Manager_Network.network_exploitation_manager.EventBus",
        lambda *a, **kw: fake_bus
    )

    # Fake vuln candidate in DB, with all fields GNN expects
    candidate = {
        "id": "CVE-UNIT-2",
        "affected_ports": [443],
        "exploit_tool": "sim",
        "severity": 7,
        "port": 443,
        "service": "http",
        "previous_success": False,
        "exploit_age": 10,
    }
    fake_db.adb_collection.find.return_value = [candidate]

    mgr = ExploitationManagerAI(fake_db, fake_bus)
    mgr.executor.run_exploitation = AsyncMock(
        return_value={"status": "executed", "output": "ok"}
    )

    # Simulate scan result that matches candidate
    scan_result = {
        "target": ["192.168.1.5"],
        "open_ports": [443],
        "vulnerabilities": ["CVE-UNIT-2"],
    }

    results = await mgr.handle_scan_result(scan_result)

    # Assertions
    assert isinstance(results, list)
    assert results[0]["status"] == "executed"
    assert results[0]["output"] == "ok"

    # DB + EventBus interactions
    fake_db.save_memory_state.assert_called_once()
    fake_bus.publish_event.assert_called_once()
