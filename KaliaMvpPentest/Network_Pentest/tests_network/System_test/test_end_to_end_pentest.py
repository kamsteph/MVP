# tests/system/test_end_to_end_pentest.py
import pytest
from unittest.mock import MagicMock

from Network_Pentest.network.network_manager import NetworkManager


@pytest.mark.asyncio
async def test_full_network_pentest_pipeline(monkeypatch):
    """
    System test: simulate the full pentest orchestration
    from initial_scan -> recon -> vulnscan -> exploitation -> learning.
    All external tools and AI are mocked.
    """

    # --- Fake DB ---
    fake_db = MagicMock()
    fake_db.save_scan_result = MagicMock()

    # --- Fake Message Bus ---
    published_tasks = []
    fake_bus = MagicMock()
    fake_bus.publish_task = MagicMock(side_effect=lambda task: published_tasks.append(task))
    fake_bus.publish_event = MagicMock()

    # --- Fake local learner ---
    fake_local_learner = MagicMock()
    fake_local_learner.learn_from_exploitation = MagicMock(return_value=[{"_id": "abc123"}])

    # --- Patch GNNBrain to always choose exploitation ---
    monkeypatch.setattr(
        "Network_Pentest.network.network_manager.GNNBrain",
        lambda *a, **k: MagicMock(predict=MagicMock(return_value="exploitation")),
    )

    # --- Patch ExploitationManager to return fake results ---
    class FakeExploitMgr:
        async def handle_scan_result(self, scan_result):
            return [{"status": "executed", "cve_id": "CVE-SYSTEM-1"}]

    monkeypatch.setattr(
        "Network_Pentest.network.network_manager.ExploitationManagerAI",
        lambda *a, **k: FakeExploitMgr(),
    )

    # --- Init system under test ---
    mgr = NetworkManager(fake_bus, fake_local_learner, fake_db)

    # --- Step 1: Initial Scan ---
    task_initial = {"action": "initial_scan", "target": ["10.0.0.10"]}
    await mgr.handle_task(task_initial)

    assert any(t["action"] == "network_recon_scan" for t in published_tasks)

    # --- Step 2: Post-Recon (simulate recon results) ---
    task_post_recon = {
        "action": "post_recon_decision",
        "target": ["10.0.0.10"],
        "scan_results": {"ip": "10.0.0.10", "alive": True, "open_ports": [22]},
    }
    await mgr.handle_task(task_post_recon)

    fake_db.save_scan_result.assert_any_call(task_post_recon["scan_results"])
    assert any(t["action"] == "run_exploitation" for t in published_tasks)

    # --- Step 3: Exploitation ---
    task_exploit = {"action": "run_exploitation", "target": ["10.0.0.10"]}
    await mgr.handle_task(task_exploit)

    # DB should save exploitation results
    saved = fake_db.save_scan_result.call_args[0][0]
    assert "exploit_results" in saved

    # And learning should be triggered
    assert any(t.get("region") == "learning" for t in published_tasks)

    # --- Check system-wide expectations ---
    assert fake_db.save_scan_result.call_count >= 2
    assert fake_bus.publish_task.call_count >= 3
    assert any(t.get("region") == "learning" for t in published_tasks)

