# tests/unit/test_exploitation.py
import pytest
from unittest.mock import MagicMock, AsyncMock

# Import the modules under test


from Network_Pentest.network import network_exploitation as ne_mod
from Network_Pentest.network.Sub_Unit_Manager_Network.network_exploitation_manager import ExploitationManagerAI
from Network_Pentest.network.network_exploitation import NetworkExploitation


# ------------------------------
# NetworkExploitation unit tests
# ------------------------------

@pytest.mark.asyncio
async def test_run_exploitation_skipped_live_db_persisted(monkeypatch):
    """
    When ALLOW_LIVE is False (default), run_exploitation should:
      - mark the result as "skipped_live_disabled"
      - attempt to persist the skipped result via db.save_scan_result
      - return the result dict
    """
    # Ensure safety gate is closed
    monkeypatch.setattr(ne_mod, "ALLOW_LIVE", False)

    # Fake DB that records save_scan_result calls
    fake_db = MagicMock()
    fake_db.save_scan_result = MagicMock()

    ne = NetworkExploitation(db=fake_db, execute_fn=None)

    cve_entry = {"id": "CVE-TEST-1", "exploit_tool": "sim", "exploit_command": "echo hi"}
    res = await ne.run_exploitation(cve_entry, target_ip="127.0.0.1", port=22)

    assert res["status"] in ("skipped_live_disabled", "skipped"), "Expected safety-skip status"
    fake_db.save_scan_result.assert_called_once()
    assert res["cve_id"] == "CVE-TEST-1"


@pytest.mark.asyncio
async def test_run_exploitation_with_execute_fn(monkeypatch):
    """
    If ALLOW_LIVE is True and execute_fn is provided, the code should:
      - run the provided execute_fn in a threadpool (we simulate with a sync function)
      - update result with values returned by execute_fn
      - persist via db.save_scan_result
    """
    monkeypatch.setattr(ne_mod, "ALLOW_LIVE", True)

    # Fake DB and a simple execute_fn
    fake_db = MagicMock()
    fake_db.save_scan_result = MagicMock()

    def fake_exec_fn(cve_entry, target_ip, port):
        # simulate an external executor returning a dict
        return {"status": "executed", "output": f"ran {cve_entry.get('id')} on {target_ip}:{port}"}

    ne = NetworkExploitation(db=fake_db, execute_fn=fake_exec_fn)

    cve_entry = {"id": "CVE-TEST-2", "exploit_tool": "sim", "exploit_command": "echo hi"}
    res = await ne.run_exploitation(cve_entry, target_ip="10.0.0.1", port=8080)

    assert res["status"] == "executed"
    assert "ran CVE-TEST-2" in res["output"]
    fake_db.save_scan_result.assert_called_once()


@pytest.mark.asyncio
async def test_execute_cli_no_command_returns_no_command(monkeypatch):
    """
    _execute_cli should return a 'no_command' result if given an empty command string.
    We test the public async wrapper by calling the method directly.
    """
    fake_db = MagicMock()
    ne = NetworkExploitation(db=fake_db, execute_fn=None)

    result = await ne._execute_cli("", timeout=1)
    assert result["status"] == "no_command"


# ------------------------------
# ExploitationManager unit tests
# ------------------------------

@pytest.mark.asyncio
async def test_handle_scan_result_no_target_returns_empty(monkeypatch):
    """
    If scan_result contains no 'ip' or 'target', manager should skip and return [].
    No events or DB saves should be performed.
    """
    fake_db = MagicMock()
    fake_bus = MagicMock()

    mgr = ExploitationManagerAI(fake_db, fake_bus)

    res = await mgr.handle_scan_result({"some": "data"})
    assert res == []
    fake_bus.publish_event.assert_not_called()
    fake_db.save_scan_result.assert_not_called()


@pytest.mark.asyncio
async def test_handle_scan_result_no_candidates_publishes_empty(monkeypatch):
    """
    If there are no candidates found in adb_collection, the manager should:
      - publish 'exploitation_completed' with empty results
      - return empty list
    """
    fake_db = MagicMock()
    fake_bus = MagicMock()

    # adb_collection.find should return an empty iterator
    fake_db.adb_collection.find = MagicMock(return_value=[])
    mgr = ExploitationManagerAI(fake_db, fake_bus)

    # ensure agent won't be invoked; give a minimal fake scan_result with a target
    scan_result = {"target": ["127.0.0.1"], "open_ports": [], "vulnerabilities": []}
    res = await mgr.handle_scan_result(scan_result)

    assert res == []
    fake_bus.publish_event.assert_called_once()
    # check published event name & payload structure
    called_args = fake_bus.publish_event.call_args[0]
    assert called_args[0] == "exploitation_completed"
    assert isinstance(called_args[1], dict)


@pytest.mark.asyncio
async def test_handle_scan_result_runs_exploit_and_saves_summary(monkeypatch):
    """
    Full happy-path unit test:
      - Mock adb_collection.find to return one candidate
      - Provide a fake agent (deterministic select_action)
      - Patch executor.run_exploitation to return an executed status
      - Ensure DB save for exploitation_summary and event publish occurs
    """
    # Prepare fake DB, Bus
    fake_db = MagicMock()
    fake_db.adb_collection = MagicMock()
    # adb_collection.find should return an iterator yielding one candidate doc
    fake_candidate = {"id": "CVE-UNIT-1", "affected_ports": [22], "exploit_tool": "sim"}
    fake_db.adb_collection.find = MagicMock(side_effect=lambda q: [fake_candidate])

    fake_bus = MagicMock()

    # Create a deterministic fake agent
    class FakeAgent:
        def __init__(self):
            pass

        def select_action(self, scan_result, candidates, epsilon=0.0):
            # always pick index 0
            return 0

        def store_experience(self, *args, **kwargs):
            # noop for unit test
            return None

        def learn_from_experience(self, *args, **kwargs):
            # noop to avoid RL training side effects
            return None

    fake_agent = FakeAgent()

    # Create manager with fake agent and fake executor
    mgr = ExploitationManagerAI(fake_db, fake_bus)

    # patch the async executor.run_exploitation to avoid external execution
    mgr.executor.run_exploitation = AsyncMock(return_value={"status": "executed", "output": "ok"})

    # Provide a scan_result that yields the candidate by vulnerability lookup
    scan_result = {"target": ["10.0.0.5"], "vulnerabilities": ["CVE-UNIT-1"], "open_ports": [22]}

    results = await mgr.handle_scan_result(scan_result)

    # We expect at least one result returned (the fake run_exploitation output)
    assert isinstance(results, list)
    assert len(results) >= 1
    assert results[0]["status"] == "executed"

    # Verify we persisted an exploitation_summary and published completion event
    fake_db.save_scan_result.assert_called()
    fake_bus.publish_event.assert_called()
    # Validate saved summary contains the 'exploitation_summary' type
    args, _ = fake_db.save_scan_result.call_args
    saved_obj = args[0]
    assert saved_obj.get("type") == "exploitation_summary"
