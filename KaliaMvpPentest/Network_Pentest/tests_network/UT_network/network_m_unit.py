import pytest
from unittest.mock import MagicMock, AsyncMock

from Network_Pentest.network.network_manager import NetworkManager
from Network_Pentest.network import network_manager as nm_mod


@pytest.mark.asyncio
async def test_handle_task_no_targets_warns_and_returns(monkeypatch):
    """
    If task has no 'target', NetworkManager.handle_task should warn and return None.
    No DB saves or bus publishes should occur.
    """
    fake_db = MagicMock()
    fake_bus = MagicMock()
    fake_local_learner = MagicMock()
    # Patch GNNBrain to avoid real model loading
    monkeypatch.setattr(nm_mod, "GNNBrain", lambda *a, **k: MagicMock(predict=MagicMock(return_value="exploitation")))
    monkeypatch.setattr(nm_mod, "ExploitationManager", lambda *a, **k: AsyncMock())

    mgr = NetworkManager(fake_bus, fake_local_learner, fake_db)

    res = await mgr.handle_task({"action": "initial_scan"})
    assert res is None
    fake_bus.publish_task.assert_not_called()
    fake_db.save_scan_result.assert_not_called()


@pytest.mark.asyncio
async def test_handle_task_initial_scan_publishes(monkeypatch):
    """
    When action == 'initial_scan', it should publish a recon scan task to the bus.
    """
    fake_db = MagicMock()
    fake_bus = MagicMock()
    fake_local_learner = MagicMock()
    monkeypatch.setattr(nm_mod, "GNNBrain", lambda *a, **k: MagicMock(predict=MagicMock()))
    monkeypatch.setattr(nm_mod, "ExploitationManager", lambda *a, **k: AsyncMock())

    mgr = NetworkManager(fake_bus, fake_local_learner, fake_db)

    task = {"action": "initial_scan", "target": ["10.0.0.1"]}
    await mgr.handle_task(task)

    fake_bus.publish_task.assert_called_once()
    published = fake_bus.publish_task.call_args[0][0]
    assert published["action"] == "network_recon_scan"
    assert "targets" in published


@pytest.mark.asyncio
async def test_handle_task_post_recon_decision_exploitation(monkeypatch):
    """
    If action == 'post_recon_decision' and GNN predicts 'exploitation',
    manager should save recon results and publish a run_exploitation task.
    """
    fake_db = MagicMock()
    fake_bus = MagicMock()
    fake_local_learner = MagicMock()
    mock_gnn = MagicMock()
    mock_gnn.predict.return_value = "exploitation"

    monkeypatch.setattr(nm_mod, "GNNBrain", lambda *a, **k: mock_gnn)
    monkeypatch.setattr(nm_mod, "ExploitationManager", lambda *a, **k: AsyncMock())

    mgr = NetworkManager(fake_bus, fake_local_learner, fake_db)

    recon_results = {"ip": "10.0.0.2"}
    task = {"action": "post_recon_decision", "target": ["10.0.0.2"], "scan_results": recon_results}
    await mgr.handle_task(task)

    fake_db.save_scan_result.assert_called_once_with(recon_results)
    fake_bus.publish_task.assert_called_once()
    published = fake_bus.publish_task.call_args[0][0]
    assert published["action"] == "run_exploitation"


@pytest.mark.asyncio
async def test_handle_task_run_exploitation_saves_and_publishes(monkeypatch):
    """
    If action == 'run_exploitation', manager should:
      - call exploit_mgr.handle_scan_result per target
      - save results to DB
      - publish learning task if 'new_for_global' is returned
    """
    fake_db = MagicMock()
    fake_bus = MagicMock()
    fake_local_learner = MagicMock()
    fake_local_learner.learn_from_exploitation.return_value = [{"_id": "123"}]

    # Patch exploit manager so its handle_scan_result returns a fake result
    class FakeExploitMgr:
        async def handle_scan_result(self, scan_result):
            return {"status": "executed"}

    monkeypatch.setattr(nm_mod, "ExploitationManager", lambda *a, **k: FakeExploitMgr())
    monkeypatch.setattr(nm_mod, "GNNBrain", lambda *a, **k: MagicMock())

    mgr = NetworkManager(fake_bus, fake_local_learner, fake_db)

    task = {"action": "run_exploitation", "target": ["10.0.0.3"]}
    await mgr.handle_task(task)

    # Ensure DB save was called with exploit_results dict
    fake_db.save_scan_result.assert_called_once()
    saved_arg = fake_db.save_scan_result.call_args[0][0]
    assert "exploit_results" in saved_arg

    # Ensure publish_task was called for learning
    fake_bus.publish_task.assert_called_once()
    published = fake_bus.publish_task.call_args[0][0]
    assert published["region"] == "learning"
    assert "results_ids" in published
