# tests/unit/test_vulnscan_and_manager.py
import pytest
import subprocess
from unittest.mock import patch, MagicMock

import Network_Pentest.network.Sub_Unit_Manager_Network.network_vuln_manager as nm
from Network_Pentest.network.network_vuln_scan import VulnScan


# -------------------
# VulnScan tests
# -------------------
def test_is_valid_ip():
    scanner = VulnScan("naabu", "nmap")
    assert scanner.is_valid_ip("192.168.1.1")
    assert scanner.is_valid_ip("::1")
    assert not scanner.is_valid_ip("")
    assert not scanner.is_valid_ip("192.168.56.")
    assert not scanner.is_valid_ip("invalid-ip")


@patch("subprocess.run")
def test_run_naabu_success(mock_run):
    mock_run.return_value = subprocess.CompletedProcess(
        args=["naabu"], returncode=0, stdout="80\n443\n"
    )
    scanner = VulnScan("naabu", "nmap")
    ports = scanner.run_naabu("192.168.1.1")
    assert ports == [80, 443]


@patch("subprocess.run", side_effect=FileNotFoundError)
def test_run_naabu_missing_binary(mock_run):
    scanner = VulnScan("naabu", "nmap")
    ports = scanner.run_naabu("192.168.1.1")
    assert ports == []


@patch("subprocess.run", side_effect=subprocess.CalledProcessError(1, "naabu", stderr="fail"))
def test_run_naabu_error(mock_run):
    scanner = VulnScan("naabu", "nmap")
    ports = scanner.run_naabu("192.168.1.1")
    assert ports == []


@patch("back_end.Regions.network.network_vuln_scan.parse_nmap_output", return_value={"parsed": "ok"})
@patch("back_end.Regions.network.network_vuln_scan.export_to_pdf")
@patch("back_end.Regions.network.network_vuln_scan.generate_ai_summary", return_value="ai_summary")
@patch("subprocess.run")  # pretend success
def test_run_nmap_success(mock_run, mock_ai, mock_pdf, mock_parse):
    mock_run.return_value = subprocess.CompletedProcess(args=["nmap"], returncode=0, stdout="")

    scanner = VulnScan("nmap", "nmap")
    result = scanner.run_nmap("192.168.1.1", [22, 80])

    assert result == "ai_summary"
    mock_parse.assert_called_once()
    mock_pdf.assert_called_once()
    mock_ai.assert_called_once()


def test_run_nmap_no_ports():
    scanner = VulnScan("nmap", "nmap")
    result = scanner.run_nmap("192.168.1.1", [])
    assert result is None


# -------------------
# NetworkVulnManager tests
# -------------------
@pytest.mark.asyncio
async def test_manager_run_scan_success(monkeypatch):
    # fake db + bus
    fake_db = MagicMock()
    fake_bus = MagicMock()

    manager = nm.NetworkVulnManager(fake_bus, fake_db, "naabu", "nmap")

    # patch vuln scanner methods
    manager.vuln_scanner.run_naabu = MagicMock(return_value=[80])
    manager.vuln_scanner.run_nmap = MagicMock(return_value="nmap_data")

    task = {"id": "task1", "target": ["192.168.1.1"], "hints": {}, "research": {}}
    await manager.run_scan(task)

    fake_db.save_scan_result.assert_called_once()
    assert fake_bus.publish_task.call_count == 3


@pytest.mark.asyncio
async def test_manager_no_targets(monkeypatch):
    fake_db = MagicMock()
    fake_bus = MagicMock()
    manager = nm.NetworkVulnManager(fake_bus, fake_db, "naabu", "nmap")

    task = {"id": "task2", "target": []}
    await manager.run_scan(task)

    fake_db.save_scan_result.assert_not_called()
    fake_bus.publish_task.assert_not_called()


@pytest.mark.asyncio
async def test_manager_scan_failure(monkeypatch):
    fake_db = MagicMock()
    fake_bus = MagicMock()
    manager = nm.NetworkVulnManager(fake_bus, fake_db, "naabu", "nmap")

    # make run_naabu raise error
    manager.vuln_scanner.run_naabu = MagicMock(side_effect=Exception("crash"))

    task = {"id": "task3", "target": ["10.0.0.1"]}
    await manager.run_scan(task)

    fake_db.save_scan_result.assert_called_once()
    fake_bus.publish_task.assert_called()
