#!/usr/bin/env python3
"""
Convert Nmap XML scan results into PyTorch Geometric .pt batches
usable by NetworkManagerGNN and VulnerabilityManagerGNN.

Usage:
    python convert_nmap_xml_to_pt.py \
        --xml vuln_scan.xml \
        --out-dir Network_Pentest/network/db_manip/cache/batches \
        --type vuln

OR:

    python convert_nmap_xml_to_pt.py --xml scan.xml --type network
"""

import argparse
import os
import xml.etree.ElementTree as ET
import torch
from torch_geometric.data import Data


# --------------------------------------------------------------
# Utility: safe torch save (PyTorch 2.6+)
# --------------------------------------------------------------
def torch_save_safe(obj, path):
    torch.save(
        obj,
        path,
        _use_new_zipfile_serialization=False   # required for 2.6 safety
    )


# --------------------------------------------------------------
#  Node feature builder
# --------------------------------------------------------------
def build_node_features(host):
    """
    Produce a 11-dimensional feature vector for a host or service.
    Matches your VulnerabilityAIAgent + NetworkManager features.
    """

    # ---- Vulnerability count ----
    vulns = host.get("vulnerabilities", [])
    num_vulns = len(vulns)

    # ---- Max CVSS ----
    max_cvss = max([v.get("cvss", 0.0) for v in vulns], default=0.0)

    # ---- Has exploit (from vulners NSE script) ----
    has_exploit = 1 if any(("exploit" in str(v).lower()) for v in vulns) else 0

    # ---- Number of services ----
    services = host.get("services", [])
    num_services = len(services)

    # ---- Risk tag ----
    risk = host.get("risk", "low").lower()
    r_high = 1 if risk == "high" else 0
    r_med = 1 if risk == "medium" else 0
    r_low = 1 if risk == "low" else 0

    # Additional placeholders to reach dimension = 11
    extra1 = float(num_vulns)
    extra2 = float(num_services)
    extra3 = 0.0

    return [
        float(num_vulns), float(max_cvss), float(has_exploit),
        float(num_services), float(r_high), float(r_med), float(r_low),
        extra3, extra1, extra2, extra3
    ]


# --------------------------------------------------------------
#  Edge builder (service-based graph)
# --------------------------------------------------------------
def build_edges(hosts):
    edges = []
    for i, h in enumerate(hosts):
        s1 = {s["name"] for s in h.get("services", [])}
        for j in range(i):
            s2 = {s["name"] for s in hosts[j].get("services", [])}
            if s1 & s2:
                edges.append([i, j])
                edges.append([j, i])
    if not edges:
        return torch.empty((2, 0), dtype=torch.long)
    return torch.tensor(edges, dtype=torch.long).t().contiguous()


# --------------------------------------------------------------
#  NMAP XML PARSER
# --------------------------------------------------------------
def parse_nmap_xml(xml_path):
    """
    Produces a list of host dicts:
        {
            "ip": "...",
            "services": [ {"name": ..., "port": ...}, ...],
            "vulnerabilities": [ {"id":..., "cvss":..., ...}, ... ],
            "risk": "high"/"medium"/"low"
        }
    """
    tree = ET.parse(xml_path)
    root = tree.getroot()

    hosts = []
    for h in root.findall("host"):

        # Skip down hosts
        if h.find("status").get("state") != "up":
            continue

        ip = None
        addr = h.find("address")
        if addr is not None:
            ip = addr.get("addr")

        ports = h.find("ports")
        services = []
        if ports:
            for p in ports.findall("port"):
                if p.find("state").get("state") != "open":
                    continue
                port = p.get("portid")
                svc_el = p.find("service")
                svc_name = svc_el.get("name") if svc_el is not None else "unknown"
                services.append({"name": svc_name, "port": port})

        # Vulners NSE script output
        vulns = []
        for script in h.findall("hostscript/script"):
            if script.get("id") == "vulners":
                for table in script.findall("table"):
                    cve = table.get("key")  # often CVE-XXXX-YYYY
                    cvss = 0.0
                    for elem in table.findall("elem"):
                        if elem.get("key") == "cvss":
                            try:
                                cvss = float(elem.text)
                            except:
                                pass
                    vulns.append({"id": cve, "cvss": cvss})

        # simple heuristic:
        if len(vulns) > 5 or any(v.get("cvss", 0) >= 7 for v in vulns):
            risk = "high"
        elif any(v.get("cvss", 0) >= 4 for v in vulns):
            risk = "medium"
        else:
            risk = "low"

        hosts.append({
            "ip": ip,
            "services": services,
            "vulnerabilities": vulns,
            "risk": risk
        })

    return hosts


# --------------------------------------------------------------
#  Label assignment for NETWORK / VULN training
# --------------------------------------------------------------
def assign_label(host, gnn_type):
    """
    gnn_type = "network" or "vuln"

    network label:
        0 = do not deeper-scan
        1 = deeper scan recommended
    vulnerability label:
        0 = not exploitable
        1 = exploitable
    """
    if gnn_type == "network":
        if host["risk"] == "high" or len(host["vulnerabilities"]) > 3:
            return 1
        return 0

    if gnn_type == "vuln":
        # simple rule: any CVSS >= 7 means exploitable
        if any(v.get("cvss", 0) >= 7 for v in host["vulnerabilities"]):
            return 1
        return 0

    raise ValueError("Invalid gnn_type")


# --------------------------------------------------------------
#  Convert parsed XML → PyG Data object
# --------------------------------------------------------------
def hosts_to_graph(hosts, gnn_type):
    x_list = [build_node_features(h) for h in hosts]
    x = torch.tensor(x_list, dtype=torch.float)

    edge_index = build_edges(hosts)
    batch = torch.zeros(len(hosts), dtype=torch.long)

    # label
    # For graph-level training, label only the *aggregate*
    # Here: pick OR of all.

    labels = [assign_label(h, gnn_type) for h in hosts]
    y = torch.tensor([1 if any(labels) else 0], dtype=torch.long)

    graph = Data(x=x, edge_index=edge_index, y=y, batch=batch)

    # Remove unsupported fields (PyTorch 2.6 safe)
    for bad in ["edge_attr", "face", "norm", "pos"]:
        if hasattr(graph, bad):
            delattr(graph, bad)

    return graph


# --------------------------------------------------------------
#  Main
# --------------------------------------------------------------
def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--xml", required=True, help="Path to Nmap XML file")
    ap.add_argument("--out-dir", required=True, help="Directory to save .pt batches")
    ap.add_argument("--type", required=True, choices=["network", "vuln"],
                    help="GNN training type")

    args = ap.parse_args()
    os.makedirs(args.out_dir, exist_ok=True)

    hosts = parse_nmap_xml(args.xml)
    if not hosts:
        print("[ERROR] No hosts found in XML.")
        return

    graph = hosts_to_graph(hosts, args.type)

    # Auto-increment output filename to avoid overwriting
    base_name = f"{args.type}_batch"
    existing = [
        f for f in os.listdir(args.out_dir)
        if f.startswith(base_name) and f.endswith(".pt")
    ]

    if not existing:
        new_index = 1
    else:
        nums = []
        for f in existing:
            try:
                n = int(f.replace(base_name + "_", "").replace(".pt", ""))
                nums.append(n)
            except:
                pass
        new_index = max(nums) + 1 if nums else 1

    # HERE is the fix — use the new index
    out_path = os.path.join(args.out_dir, f"{base_name}_{new_index}.pt")

    torch_save_safe({"data": graph}, out_path)
    print(f"[OK] Saved graph batch → {out_path}")
    print(f"[INFO] Nodes: {graph.x.shape[0]} | Features: {graph.x.shape[1]}")



if __name__ == "__main__":
    main()


# #!/usr/bin/env python3
# import argparse
# import os
# import torch
# import numpy as np
# from xml.etree import ElementTree as ET
# from torch_geometric.data import Data
#
# # ------------------------------------------------------------
# # PARSE NMAP XML
# # ------------------------------------------------------------
# def parse_nmap_xml(xml_path):
#     tree = ET.parse(xml_path)
#     root = tree.getroot()
#
#     hosts = []
#
#     for h in root.findall("host"):
#         addr = h.find("address")
#         if addr is None:
#             continue
#
#         ip = addr.attrib.get("addr", "unknown")
#
#         ports = []
#         vulns = []
#         services = []
#
#         for ports_node in h.findall("ports/port"):
#             portid = ports_node.attrib.get("portid")
#             proto = ports_node.attrib.get("protocol", "tcp")
#             state = ports_node.find("state")
#             service = ports_node.find("service")
#
#             if state is not None and state.attrib.get("state") == "open":
#                 service_name = service.attrib.get("name", "") if service is not None else ""
#                 ports.append(int(portid))
#                 services.append(service_name)
#
#         # vulners NSE script results
#         for script in h.findall("hostscript/script"):
#             if script.attrib.get("id") == "vulners":
#                 for table in script.findall("table"):
#                     cve = table.attrib.get("key")
#                     cvss = 0.0
#                     for elem in table.findall("elem"):
#                         if elem.attrib.get("key") == "cvss":
#                             try:
#                                 cvss = float(elem.text)
#                             except:
#                                 cvss = 0.0
#                     vulns.append({"cve": cve, "cvss": cvss})
#
#         hosts.append({
#             "ip": ip,
#             "ports": ports,
#             "services": services,
#             "vulns": vulns
#         })
#
#     return hosts
#
#
# # ------------------------------------------------------------
# # BUILD GRAPH FOR NETWORKMANAGER
# # ------------------------------------------------------------
# def build_network_graph(hosts):
#     x = []
#     edges = []
#
#     for idx, h in enumerate(hosts):
#         num_ports = len(h["ports"])
#         num_services = len(h["services"])
#         num_vulns = len(h["vulns"])
#         max_cvss = max([v["cvss"] for v in h["vulns"]], default=0.0)
#
#         r_high = 1 if max_cvss >= 7.0 else 0
#         r_med = 1 if 4.0 <= max_cvss < 7.0 else 0
#         r_low = 1 if 0 < max_cvss < 4.0 else 0
#
#         x.append([
#             float(num_ports),
#             float(num_services),
#             float(num_vulns),
#             float(max_cvss),
#             float(r_high),
#             float(r_med),
#             float(r_low),
#             0.0,
#             float(num_vulns),
#             float(num_services),
#             0.0
#         ])
#
#     # Full mesh based on shared service (simple heuristic)
#     for i in range(len(hosts)):
#         for j in range(i+1, len(hosts)):
#             if set(hosts[i]["services"]) & set(hosts[j]["services"]):
#                 edges.append((i, j))
#                 edges.append((j, i))
#
#     x = torch.tensor(x, dtype=torch.float)
#     edge_index = torch.tensor(edges, dtype=torch.long).t().contiguous() \
#         if edges else torch.empty((2, 0), dtype=torch.long)
#
#     return Data(x=x, edge_index=edge_index)
#
#
# # ------------------------------------------------------------
# # BUILD GRAPH FOR VULNERABILITYMANAGER
# # ------------------------------------------------------------
# def build_vuln_graph(hosts):
#     x = []
#     edges = []
#
#     for idx, h in enumerate(hosts):
#         num_vulns = len(h["vulns"])
#         num_services = len(h["services"])
#         max_cvss = max([v["cvss"] for v in h["vulns"]], default=0.0)
#         has_exploit = 1 if num_vulns > 0 else 0
#
#         r_high = 1 if max_cvss >= 7 else 0
#         r_med = 1 if 4 <= max_cvss < 7 else 0
#         r_low = 1 if 0 < max_cvss < 4 else 0
#
#         x.append([
#             float(num_vulns),
#             float(max_cvss),
#             float(has_exploit),
#             float(num_services),
#             float(r_high),
#             float(r_med),
#             float(r_low),
#             0.0,
#             float(num_vulns),
#             float(num_services),
#             0.0
#         ])
#
#     # Same-service edges
#     for i in range(len(hosts)):
#         for j in range(i+1, len(hosts)):
#             if set(hosts[i]["services"]) & set(hosts[j]["services"]):
#                 edges.append((i, j))
#                 edges.append((j, i))
#
#     x = torch.tensor(x, dtype=torch.float)
#     edge_index = torch.tensor(edges, dtype=torch.long).t().contiguous() \
#         if edges else torch.empty((2,0), dtype=torch.long)
#
#     return Data(x=x, edge_index=edge_index)
#
#
# # ------------------------------------------------------------
# # MAIN CLI
# # ------------------------------------------------------------
# def main():
#     parser = argparse.ArgumentParser(description="Convert Nmap XML to PT graph batches")
#     parser.add_argument("--xml", required=True, help="Path to vuln_scan.xml")
#     parser.add_argument("--output-dir", required=True, help="Where to save .pt batches")
#
#     args = parser.parse_args()
#
#     hosts = parse_nmap_xml(args.xml)
#     print(f"[+] Parsed {len(hosts)} hosts from XML")
#
#     os.makedirs(args.output_dir, exist_ok=True)
#
#     net_graph = build_network_graph(hosts)
#     vuln_graph = build_vuln_graph(hosts)
#
#     torch.save({"data": net_graph}, os.path.join(args.output_dir, "network_batch.pt"))
#     torch.save({"data": vuln_graph}, os.path.join(args.output_dir, "vuln_batch.pt"))
#
#     print("[+] DONE — Saved:")
#     print(f"    {args.output_dir}/network_batch.pt")
#     print(f"    {args.output_dir}/vuln_batch.pt")
#
#
# if __name__ == "__main__":
#     main()
