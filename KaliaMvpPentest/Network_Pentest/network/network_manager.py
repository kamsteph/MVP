# new_module/network_manager_async.py
import logging
from typing import Dict, Any, List
import asyncio
import time

from G_L_L.l_region.local_learner import LocalLearner
from back_end.GraphNN import GNNBrain
from Network_Pentest.network.Sub_Unit_Manager_Network.network_exploitation_manager import ExploitationManagerAI
from back_end.utils.colored_logger import get_logger
from back_end.database import DatabaseManager
from back_end.event_bus import EventBus

from back_end.utils.ai_summary import generate_ai_summary  # <-- your Ollama wrapper

logger = get_logger(__name__, component="MANAGER", region="NETWORK")
logger.setLevel(logging.INFO)


class NetworkManager:
    """
    Fully async high-level AI Agent for Network Pentesting.
    Orchestrates Recon, VulnScan, and Exploitation.
    Integrates Local Learner for exploitation feedback.
    """

    def __init__(self, bus: EventBus, local_learner: LocalLearner, db: DatabaseManager, gnn_model_path: str = None):
        self.bus = bus
        self.db = db
        self.local_learner = local_learner
        self.gnn_brain = GNNBrain(model_path=gnn_model_path)
        self.exploit_mgr = ExploitationManagerAI(db, bus)

        logger.info("[NETWORK][MANAGER] Initialized as an async AI Agent")

        # Subscribe to network region tasks using async wrapper
        self.bus.subscribe("network", self._async_task_wrapper)

    def _async_task_wrapper(self, task: Dict[str, Any]):
        asyncio.create_task(self.handle_task(task))

    def _scan_allows_exploit(self, scan_type: str) -> bool:
        if not scan_type:
            return True
        s = str(scan_type).lower()
        if "scan only" in s or "scan_only" in s or s.strip() == "scan_only":
            return False
        if "attack" in s or "exploit" in s or "scan+attack" in s or "scan_and_attack" in s:
            return True
        return True

    async def handle_task(self, task: Dict[str, Any]):
        start_time = time.time()
        logger.info(f"[NETWORK][MANAGER] Received task: {task}")
        action = task.get("action", "initial_scan")

        # FIX: allow hints.targets
        targets = task.get("target", []) or task.get("targets", []) or task.get("hints", {}).get("targets", [])

        if not targets:
            logger.warning("[NetworkManager] No targets specified. Skipping task.")
            return

        # initial scan
        if action in ("initial_scan", "initial_network_scan"):
            self.bus.publish_task({
                "region": "network",
                "action": "network_recon_scan",
                "targets": targets
            })
            return

        # post-recon decision
        if action == "post_recon_decision":
            recon_results = task.get("scan_results", {})
            if not recon_results:
                logger.warning("[NetworkManager] No recon results provided. Skipping.")
                return

            try:
                self.db.save_scan_result(recon_results)
            except Exception:
                logger.exception("Failed to save recon results to DB")

            next_action = self.gnn_brain.predict([recon_results])
            hints = task.get("hints", {}) or {}
            do_exploit_hint = hints.get("do_exploit", True)
            scan_type = task.get("scan_type") or task.get("scanType") or ""
            scan_allows = self._scan_allows_exploit(scan_type)

            if next_action == "exploitation" and do_exploit_hint and scan_allows:
                self.bus.publish_task({
                    "region": "network",
                    "action": "run_exploitation",
                    "target": targets,
                    "parent_id": task.get("id")
                })
            else:
                # Generate summary here (scan only)
                summary = generate_ai_summary(recon_results.get("findings", []))
                end_time = time.time()

                self.bus.publish_event("task_completed", {
                    "id": task["id"],
                    "region": "network",
                    "status": "completed",
                    "time_taken": round(end_time - start_time, 2),
                    "threats_found": len(recon_results.get("findings", [])),
                    "risk_level": self._assess_risk(recon_results),
                    "summary": summary,
                    "raw_results": recon_results
                })
            return

        # exploitation branch
        if action == "run_exploitation":
            exploit_results = await self._run_exploitation(targets)

            try:
                self.db.save_scan_result(exploit_results)
            except Exception:
                logger.exception("Failed to save exploit results to DB")

            summary = generate_ai_summary(
                exploit_results.get("exploit_results", {}).values()
            )

            end_time = time.time()
            self.bus.publish_event("task_completed", {
                "id": task.get("parent_id", task["id"]),
                "region": "network",
                "status": "completed",
                "time_taken": round(end_time - start_time, 2),
                "threats_found": len(exploit_results.get("exploit_results", {})),
                "risk_level": self._assess_risk(exploit_results),
                "summary": summary,
                "raw_results": exploit_results
            })
            return

        logger.debug("[NETWORK][MANAGER] Unhandled action: %s", action)

    async def _run_exploitation(self, targets: List[str]) -> Dict[str, Any]:
        all_results = {}
        for target in targets:
            exploit_res = await self.exploit_mgr.handle_scan_result({"target": [target]})
            all_results[target] = exploit_res

        try:
            new_for_global = self.local_learner.local_knowledge([
                {"target": t, "vulnerabilities": r, "status": "success"}
                for t, r in all_results.items()
            ])
        except Exception:
            logger.exception("Local learner failed to process exploit results")
            new_for_global = []

        return {"targets": targets, "exploit_results": all_results, "new_for_global": new_for_global}

    def _assess_risk(self, results: Dict[str, Any]) -> str:
        """
        Simple heuristic risk scoring.
        """
        findings = results.get("findings") or results.get("exploit_results", {})
        count = len(findings)
        if count == 0:
            return "None"
        elif count < 3:
            return "Low"
        elif count < 6:
            return "Medium"
        else:
            return "High"
