# new_module/api_wrappers/cli_base.py
import asyncio
import logging
import os
from typing import List, Dict, Any, Optional

from Network_Pentest.network.tool.base_class import ToolAPI

logger = logging.getLogger("CLI_TOOL_BASE")

#TODO: remember the ways for calling the cli_wrapper
class CLIToolHelper(ToolAPI):
    binary_name: str = ""
    default_timeout: int = 60

    def _build_cmd(self, args: List[str]) -> List[str]:
        """
        Build the final sys command list, depending on environment.
        Supported CLI_MODE values:
          - 'local'  -> call binary directly
          - 'docker' -> run binary inside named docker container (CLI_DOCKER_CONTAINER)
          - 'ssh'    -> run remote via SSH (SSH_USER, SSH_HOST)
        """
        cli_mode = os.getenv("CLI_MODE", "local").lower()
        if cli_mode == "docker":
            container = os.getenv("CLI_DOCKER_CONTAINER", "metasploit")
            # docker exec -i <container> <binary> <args...>
            return ["docker", "exec", "-i", container, self.binary_name] + args
        if cli_mode == "ssh":
            ssh_user = os.getenv("SSH_USER", "pentest")
            ssh_host = os.getenv("SSH_HOST", "10.10.10.5")
            # ssh pentest@host msfconsole -q -x "<cmd>"
            return ["ssh", f"{ssh_user}@{ssh_host}", self.binary_name] + args
        # default: local binary
        return [self.binary_name] + args

    # def _build_cmd(self, args: List[str]) -> List[str]:
    #         return [self.binary_name] + args

    def execute_sync(self, target: str, args: Optional[List[str]] = None, timeout: Optional[int] = None, **kwargs) -> Dict[str, Any]:
        """
        Blocking CLI execution that will be called via run_in_executor.
        Implementors may call this directly or override scan_sync/execute_sync.
        """
        cmd = self._build_cmd(args or [])
        import subprocess
        try:
            completed = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=timeout or self.default_timeout)
            return {
                "stdout": completed.stdout.decode(errors="ignore"),
                "stderr": completed.stderr.decode(errors="ignore"),
                "returncode": completed.returncode
            }
        except FileNotFoundError:
            return {"status": "not_found", "error": f"binary {self.binary_name} not found"}
        except subprocess.TimeoutExpired:
            return {"status": "timeout"}
        except Exception as e:
            return {"status": "error", "error": str(e)}
