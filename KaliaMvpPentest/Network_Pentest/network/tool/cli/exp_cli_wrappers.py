# new_module/api_wrappers/cli_metasploit.py
import asyncio
import shlex
import logging
from typing import Optional, Dict, Any, List
from Network_Pentest.network.tool.base_class import register_tool
from Network_Pentest.network.tool.cli.cli_wrapper_base import CLIToolHelper

logger = logging.getLogger("MetasploitCLI")

@register_tool("metasploit", mode="cli", category="exploiter")
class MetasploitCLI(CLIToolHelper):
    """
    CLI version of Metasploit execution.
    Supports sandbox-safe 'training' mode for honeypot testing.
    """

    binary_name = "msfconsole"
    default_timeout = 300

    async def execute(self, target: str, **kwargs) -> Dict[str, Any]:
        """
        Generic execute signature to match ToolAPI.
        Expected kwargs:
           - exploit_name: str
           - payload: Optional[str]
           - options: Optional[dict]
           - training: bool  (if True, enforce sandbox-safe options)
           - cli_mode_args: Optional[List[str]] (extra CLI args)
        """
        exploit_name = kwargs.get("exploit_name")
        payload = kwargs.get("payload")
        options = kwargs.get("options") or {}
        training = bool(kwargs.get("training", True))
        extra_args = kwargs.get("cli_mode_args") or []

        if not exploit_name:
            return {"status": "error", "error": "missing exploit_name"}

        # Build base command
        base_cmd = f"use {exploit_name}; set RHOSTS {target}; "

        # Safe payload substitution for training mode
        safe_payload = payload
        if training:
            # Replace payload with a safe stub if none provided, or prevent reverse shells etc
            safe_payload = payload or "generic/safe"
            logger.info(f"[MetasploitCLI][TRAINING] Using safe payload: {safe_payload}")
            # Example training restrictions - these are suggestions, adjust to your policies
            options = {k: v for k, v in options.items() if not str(k).lower().startswith(("handler", "session"))}

        if safe_payload:
            base_cmd += f"set PAYLOAD {safe_payload}; "
        for k, v in options.items():
            base_cmd += f"set {k} {v}; "

        if training:
            base_cmd += "set DisablePayloadHandler true; set AutoRunScript post/test_sandbox; run -j; exit"
        else:
            base_cmd += "run; exit"

        # Use _build_cmd to produce potentially docker/ssh wrapper
        args = ["-q", "-x", base_cmd] + extra_args
        cmd = self._build_cmd(args)

        logger.info(f"[MetasploitCLI] Running exploit: {exploit_name} on {target} (training={training}) -> cmd: {cmd}")

        try:
            # Use asyncio.create_subprocess_exec so run_safe handles wrapping if necessary
            proc = await asyncio.create_subprocess_exec(
                *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await proc.communicate()

            return {
                "tool": "metasploit",
                "mode": "cli",
                "target": target,
                "exploit": exploit_name,
                "payload": safe_payload,
                "training": training,
                "stdout": stdout.decode(errors="ignore"),
                "stderr": stderr.decode(errors="ignore"),
                "status": "executed" if proc.returncode == 0 else "failed",
                "returncode": proc.returncode,
            }
        except FileNotFoundError:
            return {"status": "error", "error": "msfconsole binary not found"}
        except Exception as e:
            logger.error(f"[MetasploitCLI] Error executing exploit: {e}")
            return {"status": "error", "error": str(e)}
