import asyncio
import logging
from typing import List, Optional
import ipaddress

from Network_Pentest.network.tool.base_class import ToolAPI, register_tool

logger = logging.getLogger("API_WRAPPERS")

# Define top 10 common service ports
TOP_10_PORTS = [20, 21, 22, 23, 25, 53, 80, 110, 443, 3389]

@register_tool("nmap")
class NmapAPI(ToolAPI):
    async def scan(self, target: str, ports: Optional[List[int]] = None, top_ports: Optional[int] = None):
        # determine IPv6
        is_ipv6 = False
        try:
            if "/" in target:
                is_ipv6 = ipaddress.ip_network(target, strict=False).version == 6
            else:
                is_ipv6 = ipaddress.ip_address(target).version == 6
        except Exception:
            is_ipv6 = False

        if ports:
            ports_arg = ",".join(str(p) for p in ports)
            cmd = [ "nmap", "-p", ports_arg ]
        elif top_ports:
            # simple fallback: build ports string from a small list or map
            default_list = [80,443,22,53,3389,110,25,21,23,445]
            ports_arg = ",".join(str(p) for p in default_list[:top_ports])
            cmd = [ "nmap", "-p", ports_arg ]
        else:
            cmd = ["nmap"]

        if is_ipv6:
            cmd.insert(1, "-6")  # place -6 right after 'nmap' (so final looks like ['nmap','-6', ...])

        cmd.append(target)

        logger.info("Running Nmap: %s", " ".join(cmd))
        try:
            proc = await asyncio.create_subprocess_exec(*cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE)
            stdout, _ = await proc.communicate()
            out = stdout.decode()
            results = []
            for line in out.splitlines():
                if "/tcp open" in line:
                    try:
                        port = int(line.split("/")[0])
                        results.append({"port": port, "state": "open"})
                    except Exception:
                        continue
            return results
        except FileNotFoundError:
            logger.error("Nmap not found.")
            return []
        except Exception as e:
            logger.exception("Nmap failed: %s", e)
            return []

@register_tool("masscan")
class MasscanAPI(ToolAPI):
    # set this True only if your masscan binary supports IPv6
    SUPPORTS_IPV6 = False

    async def scan(self, target: str, top_ports: Optional[int] = 10, ports: Optional[List[int]] = None):
        try:
            is_ipv6 = False
            if "/" in target:
                is_ipv6 = ipaddress.ip_network(target, strict=False).version == 6
            else:
                is_ipv6 = ipaddress.ip_address(target).version == 6
        except Exception:
            is_ipv6 = False

        if is_ipv6 and not self.SUPPORTS_IPV6:
            logger.warning("Masscan IPv6 unsupported in this build; skipping / return empty. Consider Naabu/Nmap.")
            return []

        if ports:
            ports_arg = ",".join(str(p) for p in ports)
        else:
            # default top ports mapping, adjust as needed
            default_list = [80,443,22,53,3389,110,25,21,23,445]
            ports_arg = ",".join(str(p) for p in default_list[:top_ports])

        # masscan CLI usually: masscan -p80,443 <target> --rate 1000
        cmd = ["masscan", "-p", ports_arg, target, "--rate", "1000"]
        if is_ipv6 and self.SUPPORTS_IPV6:
            cmd += ["--ipv6"]

        logger.info("Running Masscan: %s", " ".join(cmd))
        try:
            proc = await asyncio.create_subprocess_exec(*cmd, stdout=asyncio.subprocess.PIPE)
            stdout, _ = await proc.communicate()
            ports_found = []
            for line in stdout.decode().splitlines():
                line = line.strip()
                if line.isdigit():
                    ports_found.append(int(line))
                else:
                    # parse lines like "Discovered open port 80/tcp on 192.168.0.1"
                    parts = [p for p in line.split() if p.isdigit()]
                    if parts:
                        ports_found.extend(int(x) for x in parts)
            return [{"port": p, "state": "open"} for p in set(ports_found)]
        except FileNotFoundError:
            logger.error("Masscan not found.")
            return []
        except Exception as e:
            logger.exception("Masscan failed: %s", e)
            return []


@register_tool("naabu")
class NaabuAPI(ToolAPI):
    async def scan(self, target: str, top_ports: int = 10, ports: Optional[List[int]] = None) -> List[int]:
        """
        target: single IP string or CIDR (e.g. 192.168.1.0/24) or hostname.
        Auto-detect IPv6 and add -6 flag if necessary.
        """
        cmd = ["naabu"]

        # detect IPv6
        is_ipv6 = False
        try:
            if "/" in target:
                # could be CIDR
                is_ipv6 = ipaddress.ip_network(target, strict=False).version == 6
            else:
                is_ipv6 = ipaddress.ip_address(target).version == 6
        except Exception:
            # not a pure IP/CIDR â€” may be hostname; leave is_ipv6 = False
            is_ipv6 = False

        if is_ipv6:
            cmd.append("-6")

        # naabu accepts -host <target> or -cidr <cidr> depending on version
        # using -host for both single IP and CIDR (most recent versions accept CIDR), else orchestrator should expand
        cmd += ["-host", target]

        if ports:
            cmd += ["-p", ",".join(str(p) for p in ports)]
        else:
            # a small mapping for top_ports to a list (customize if you keep TOP_10 etc)
            default_map = {10: "100", 100: "100", 1000: "1000"}
            # we'll map simple case: if top_ports=10 -> -top-ports 100
            if top_ports:
                cmd += ["-top-ports", str(top_ports)]
        cmd += ["-silent"]

        logger.info("Running Naabu: %s", " ".join(cmd))
        try:
            proc = await asyncio.create_subprocess_exec(*cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE)
            stdout, stderr = await proc.communicate()
            out = stdout.decode() if stdout else ""
            open_ports = []
            for line in out.splitlines():
                line = line.strip()
                if line.isdigit():
                    open_ports.append(int(line))
                elif ':' in line:
                    try:
                        open_ports.append(int(line.split(':')[-1]))
                    except Exception:
                        continue
            return open_ports
        except FileNotFoundError:
            logger.error("Naabu not found.")
            return []
        except Exception as e:
            logger.exception("Naabu scan failed: %s", e)
            return []
