import asyncio
import os
from typing import Dict, Any
from pymetasploit3.msfrpc import MsfRpcClient
from Network_Pentest.network.tool.base_class import ToolAPI, register_tool, logger


class MetasploitAPI(ToolAPI):
    def __init__(self):
        super().__init__()
        self.host = os.getenv("MSF_HOST")
        self.port = int(os.getenv("MSF_PORT", "55553")) if os.getenv("MSF_PORT") else None
        self.password = os.getenv("MSF_PASSWORD")
        self.client = None
        if self.host and self.port and self.password:
            try:
                self.client = MsfRpcClient(self.password, server=self.host, port=self.port, ssl=True)
                logger.info("[MetasploitAPI] Connected to msfrpcd")
            except Exception as e:
                logger.warning(f"[MetasploitAPI] Could not connect to msfrpcd: {e}")
                self.client = None

    async def execute(self, target: str, **kwargs) -> Dict[str, Any]:
        exploit_name = kwargs.get("exploit_name")
        payload = kwargs.get("payload")
        options = kwargs.get("options") or {}
        training = bool(kwargs.get("training", True))

        if not exploit_name:
            return {"status":"error", "error":"missing exploit_name"}

        safe_payload = payload or None
        if training:
            safe_payload = payload or "generic/safe"

        # 1) Try RPC if available (run in thread to avoid blocking)
        if self.client:
            try:
                def rpc_call():
                    category, module_name = exploit_name.split("/", 1)
                    exp = self.client.modules.use(category, module_name)
                    exp['RHOSTS'] = target
                    if safe_payload:
                        exp['PAYLOAD'] = safe_payload
                    for k, v in options.items():
                        exp[k] = v
                    res = exp.execute(payload=safe_payload or None)
                    # after execution check sessions
                    sessions = self.client.sessions.list
                    return {"status":"executed_rpc", "result": res, "sessions": sessions}
                rpc_result = await asyncio.to_thread(rpc_call)
                # Normalize rpc_result into our parsed schema (best-effort)
                parsed = {"success": False, "evidence": [], "session": {"id": None, "type": None, "line": None}, "raw": str(rpc_result)}
                # try to find new session in sessions (simplest heuristic)
                sessions = rpc_result.get("sessions") or {}
                if sessions:
                    # pick last session id
                    sid = max(int(k) for k in sessions.keys())
                    parsed["success"] = True
                    parsed["evidence"].append("rpc_session")
                    parsed["session"]["id"] = sid
                    parsed["session"]["type"] = sessions[str(sid)].get("type")
                return {
                    "tool": "metasploit",
                    "mode": "rpc",
                    "target": target,
                    "exploit": exploit_name,
                    "payload": safe_payload,
                    "parsed": parsed,
                    "raw_rpc": rpc_result
                }
            except Exception as e:
                logger.warning(f"[MetasploitAPI] RPC execution failed, falling back to CLI: {e}")

# # new_module/api_wrappers/api_metasploit.py
# import asyncio
# import logging
# import os
# from typing import Optional, Dict, Any
# from pymetasploit3.msfrpc import MsfRpcClient
#
# from Network_Pentest.network.tool.base_class import ToolAPI, register_tool
#
# logger = logging.getLogger("MetasploitAPI")
#
# @register_tool("metasploit",mode="api", category="exploiter")
# class MetasploitAPI(ToolAPI):
#     async def execute(
#             self, target: str, **kwargs
#     ) -> Any:
#         """
#         Execute a Metasploit exploit via msfconsole RPC or subprocess.
#
#         training=True â†’ restrict payloads and network isolation for honeypot testing
#         """
#         exploit_name = kwargs.get("exploit_name")
#         payload = kwargs.get("payload")
#         options = kwargs.get("options") or {}
#         training = bool(kwargs.get("training", True))
#
#         safe_payload = payload
#         if training:
#             # Enforce sandbox-safe payload (no outbound connections)
#             safe_payload = "generic/safe" if not payload else payload
#             logger.info(f"[MetasploitAPI][TRAINING] Safe payload enforced: {safe_payload}")
#
#         # Build msfconsole command
#         cmd = ["msfconsole", "-q", "-x", f"use {exploit_name}; set RHOSTS {target};"]
#         if safe_payload:
#             cmd += [f"set PAYLOAD {safe_payload};"]
#         if options:
#             for k, v in options.items():
#                 cmd += [f"set {k} {v};"]
#
#         # In training mode, restrict networking
#         if training:
#             cmd.append("set AutoRunScript post/test_sandbox;")  # optional sandbox marker
#             cmd.append("set DisablePayloadHandler true;")       # no reverse shell
#             cmd.append("run -j; exit")
#         else:
#             cmd.append("run; exit")
#
#         logger.info(f"[MetasploitAPI] Executing exploit: {exploit_name} on {target} (training={training})")
#
#         proc = await asyncio.create_subprocess_exec(
#             *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
#         )
#         stdout, stderr = await proc.communicate()
#         return {
#             "tool": self.TOOL_NAME,
#             "target": target,
#             "exploit": exploit_name,
#             "payload": safe_payload,
#             "stdout": stdout.decode(),
#             "stderr": stderr.decode(),
#             "training": training,
#         }

# class MetasploitAPI(ToolAPI):
#     """
#     API (RPC) version of Metasploit integration.
#     Secure TLS connection to remote msfrpcd daemon.
#     """
#
#     def __init__(self):
#         super().__init__()
#         self.host = os.getenv("MSF_HOST", "10.149.244.106")
#         self.port = int(os.getenv("MSF_PORT", "55553"))
#         self.password = os.getenv("MSF_PASSWORD", "mypassword")
#         self.client = None
#         try:
#             logger.info(f"[MetasploitAPI] Connecting to RPC at {self.host}:{self.port}")
#             self.client = MsfRpcClient(self.password, server=self.host, port=self.port, ssl=True)
#             logger.info("[MetasploitAPI] Connected successfully.")
#         except Exception as e:
#             logger.error(f"[MetasploitAPI] RPC connection failed: {e}")
#             self.client = None
#
#     async def execute(self, target: str, exploit_name: str,
#                       payload: Optional[str] = None, options: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
#         if not self.client:
#             return {"status": "rpc_unavailable", "error": "MSF RPC not connected"}
#
#         try:
#             category, module_name = exploit_name.split("/", 1)
#             exploit = self.client.modules.use(category, module_name)
#
#             exploit["RHOSTS"] = target
#             if payload:
#                 exploit["PAYLOAD"] = payload
#             if options:
#                 for k, v in options.items():
#                     exploit[k] = v
#
#             result = exploit.execute(payload=payload or "generic/shell_reverse_tcp")
#             logger.info(f"[MetasploitAPI] Exploit executed via RPC on {target}")
#             return {"status": "executed_rpc", "result": result}
#         except Exception as e:
#             logger.error(f"[MetasploitAPI] Execution failed: {e}")
#             return {"status": "error", "error": str(e)}

@register_tool("customexploit")
class CustomExploitAPI(ToolAPI):
    name = "CustomExploit"
    category = "exploiter"
    supports_ipv6 = True

    async def execute(self, target: str, exploit_vector: Dict[str, Any]) -> Any:
        """Template for your own custom exploitation scripts."""
        logger.info(f"[CustomExploitAPI] Launching custom exploit on {target}")
        # Implement your own exploit logic here (PoC, payloads, etc.)
        await asyncio.sleep(1)
        return {"target": target, "status": "simulated_success"}
