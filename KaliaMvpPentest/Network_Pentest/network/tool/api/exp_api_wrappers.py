# new_module/api_wrappers/api_metasploit.py
import asyncio
import logging
import os
from typing import Optional, Dict, Any
from pymetasploit3.msfrpc import MsfRpcClient

from Network_Pentest.network.tool.base_class import ToolAPI, register_tool

logger = logging.getLogger("MetasploitAPI")

@register_tool("metasploit",mode="api", category="exploiter")
class MetasploitAPI(ToolAPI):
    async def execute(
            self, target: str, **kwargs
    ) -> Any:
        """
        Execute a Metasploit exploit via msfconsole RPC or subprocess.

        training=True â†’ restrict payloads and network isolation for honeypot testing
        """
        exploit_name = kwargs.get("exploit_name")
        payload = kwargs.get("payload")
        options = kwargs.get("options") or {}
        training = bool(kwargs.get("training", True))

        safe_payload = payload
        if training:
            # Enforce sandbox-safe payload (no outbound connections)
            safe_payload = "generic/safe" if not payload else payload
            logger.info(f"[MetasploitAPI][TRAINING] Safe payload enforced: {safe_payload}")

        # Build msfconsole command
        cmd = ["msfconsole", "-q", "-x", f"use {exploit_name}; set RHOSTS {target};"]
        if safe_payload:
            cmd += [f"set PAYLOAD {safe_payload};"]
        if options:
            for k, v in options.items():
                cmd += [f"set {k} {v};"]

        # In training mode, restrict networking
        if training:
            cmd.append("set AutoRunScript post/test_sandbox;")  # optional sandbox marker
            cmd.append("set DisablePayloadHandler true;")       # no reverse shell
            cmd.append("run -j; exit")
        else:
            cmd.append("run; exit")

        logger.info(f"[MetasploitAPI] Executing exploit: {exploit_name} on {target} (training={training})")

        proc = await asyncio.create_subprocess_exec(
            *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
        )
        stdout, stderr = await proc.communicate()
        return {
            "tool": self.TOOL_NAME,
            "target": target,
            "exploit": exploit_name,
            "payload": safe_payload,
            "stdout": stdout.decode(),
            "stderr": stderr.decode(),
            "training": training,
        }

# class MetasploitAPI(ToolAPI):
#     """
#     API (RPC) version of Metasploit integration.
#     Secure TLS connection to remote msfrpcd daemon.
#     """
#
#     def __init__(self):
#         super().__init__()
#         self.host = os.getenv("MSF_HOST", "10.149.244.106")
#         self.port = int(os.getenv("MSF_PORT", "55553"))
#         self.password = os.getenv("MSF_PASSWORD", "mypassword")
#         self.client = None
#         try:
#             logger.info(f"[MetasploitAPI] Connecting to RPC at {self.host}:{self.port}")
#             self.client = MsfRpcClient(self.password, server=self.host, port=self.port, ssl=True)
#             logger.info("[MetasploitAPI] Connected successfully.")
#         except Exception as e:
#             logger.error(f"[MetasploitAPI] RPC connection failed: {e}")
#             self.client = None
#
#     async def execute(self, target: str, exploit_name: str,
#                       payload: Optional[str] = None, options: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
#         if not self.client:
#             return {"status": "rpc_unavailable", "error": "MSF RPC not connected"}
#
#         try:
#             category, module_name = exploit_name.split("/", 1)
#             exploit = self.client.modules.use(category, module_name)
#
#             exploit["RHOSTS"] = target
#             if payload:
#                 exploit["PAYLOAD"] = payload
#             if options:
#                 for k, v in options.items():
#                     exploit[k] = v
#
#             result = exploit.execute(payload=payload or "generic/shell_reverse_tcp")
#             logger.info(f"[MetasploitAPI] Exploit executed via RPC on {target}")
#             return {"status": "executed_rpc", "result": result}
#         except Exception as e:
#             logger.error(f"[MetasploitAPI] Execution failed: {e}")
#             return {"status": "error", "error": str(e)}

@register_tool("customexploit")
class CustomExploitAPI(ToolAPI):
    name = "CustomExploit"
    category = "exploiter"
    supports_ipv6 = True

    async def execute(self, target: str, exploit_vector: Dict[str, Any]) -> Any:
        """Template for your own custom exploitation scripts."""
        logger.info(f"[CustomExploitAPI] Launching custom exploit on {target}")
        # Implement your own exploit logic here (PoC, payloads, etc.)
        await asyncio.sleep(1)
        return {"target": target, "status": "simulated_success"}
