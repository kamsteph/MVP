# new_module/api_wrappers/base_api.py
"""
Backward-compatible Tool API registry that accepts both async and sync tool implementations.

- Tools may implement async scan/execute OR sync scan_sync/execute_sync.
- run_safe() will call whichever exists and automatically wrap sync calls via asyncio.to_thread.
- Registry supports mode ("api"/"cli") and resolve_tool fallback.
"""
import asyncio
import logging
import os
from typing import Any, Dict, Type, Optional, Iterable, Callable

logger = logging.getLogger("TOOL_API_BASE")

TOOL_REGISTRY: Dict[str, Dict[str, Type["ToolAPI"]]] = {}

def register_tool(name: str, mode: str = "api",category: str="vuln_scan"):
    def decorator(cls: Type["ToolAPI"]):
        key = name.lower()
        TOOL_REGISTRY.setdefault(key, {})[mode.lower()] = cls
        cls.TOOL_NAME = key
        cls.TOOL_MODE = mode.lower()
        return cls
    return decorator

# convenience old API function (backwards compatible)
def get_tool_by_name(name: str) -> Optional["ToolAPI"]:
    clsmap = TOOL_REGISTRY.get(name.lower(), {})
    # prefer api implementation if present
    cls = clsmap.get("api") or next(iter(clsmap.values()), None)
    return cls() if cls else None

def list_registered_tools() -> Dict[str, Dict[str, Type["ToolAPI"]]]:
    return {k: v.copy() for k, v in TOOL_REGISTRY.items()}

def resolve_tool(tool_name: str, preferred_modes: Iterable[str] = ("api", "cli")) -> Optional["ToolAPI"]:
    key = tool_name.lower()
    mods = TOOL_REGISTRY.get(key, {})
    for m in preferred_modes:
        cls = mods.get(m.lower())
        if cls:
            return cls()
    return None

class ToolAPI:
    """
    Base class for tools. Subclasses may implement:
      - async def scan(self, target, **kw)
      - async def execute(self, target, **kw)
    OR (sync):
      - def scan_sync(self, target, **kw)
      - def execute_sync(self, target, **kw)

    run_safe() will pick scan first, then execute, and will wrap sync versions.
    """
    TOOL_NAME: str = "unnamed"
    TOOL_MODE: str = "api"
    category: str = "generic"
    supports_ipv6: bool = False
    metadata: Dict[str, Any] = {}

    # Optional async implementations
    async def scan(self, target: str, **kwargs) -> Any:
        raise NotImplementedError("scan() not implemented")

    async def execute(self, target: str, **kwargs) -> Any:
        raise NotImplementedError("execute() not implemented")

    # Optional sync implementations (helpers for authors who prefer sync)
    def scan_sync(self, target: str, **kwargs) -> Any:
        raise NotImplementedError("scan_sync() not implemented")

    def execute_sync(self, target: str, **kwargs) -> Any:
        raise NotImplementedError("execute_sync() not implemented")

    # Helper to call sync function in thread
    async def _maybe_wrap_sync(self, fn: Callable, *args, **kwargs):
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(None, lambda: fn(*args, **kwargs))


    async def run_safe(self, target: str, **kwargs) -> Any:
        training = bool(kwargs.get("training", False))

        # global safety: prevent accidental live exploitation unless explicitly allowed
        ALLOW_LIVE = os.getenv("ALLOW_LIVE_EXPLOITS", "0") == "1"
        if not training and not ALLOW_LIVE and self.category == "exploiter":
            logger.warning(f"[{self.TOOL_NAME}] Live exploitation blocked (ALLOW_LIVE=0). Use training mode or enable ALLOW_LIVE.")
            return {"status": "skipped_live_disabled"}

        # propagate flag
        kwargs["training"] = training

        # central sanitation: block reverse shells during training
        if training:
            payload = kwargs.get("payload")
            if payload and "reverse" in str(payload).lower():
                logger.debug(f"[{self.TOOL_NAME}] stripping reverse payload in training mode.")
                kwargs["payload"] = "generic/safe"

        # fallback order: async scan -> scan_sync -> async execute -> execute_sync
        try:
            try:
                return await self.scan(target, **kwargs)
            except NotImplementedError:
                pass

            if hasattr(self, "scan_sync") and callable(getattr(self, "scan_sync")):
                try:
                    return await self._maybe_wrap_sync(self.scan_sync, target, **kwargs)
                except NotImplementedError:
                    pass

            try:
                return await self.execute(target, **kwargs)
            except NotImplementedError:
                pass

            if hasattr(self, "execute_sync") and callable(getattr(self, "execute_sync")):
                try:
                    return await self._maybe_wrap_sync(self.execute_sync, target, **kwargs)
                except NotImplementedError:
                    pass

            raise NotImplementedError("Tool has no usable scan/execute implementation.")
        except asyncio.TimeoutError:
            logger.exception(f"[{self.TOOL_NAME}:{self.TOOL_MODE}] timed out")
            return {"status": "timeout"}
        except Exception as e:
            logger.exception(f"[{self.TOOL_NAME}:{self.TOOL_MODE}] error: {e}")
            return {"status": "error", "error": str(e)}

    # async def run_safe(self, target: str, **kwargs) -> Any:
    #     """
    #     Prefer scan(), then scan_sync(), then execute(), then execute_sync().
    #     Wrap sync calls using a threadpool so run_safe is always awaitable.
    #     """
    #     try:
    #         # async scan
    #         if hasattr(self, "scan"):
    #             # try calling async scan - may raise NotImplementedError if not implemented
    #             try:
    #                 return await self.scan(target, **kwargs)
    #             except NotImplementedError:
    #                 pass
    #
    #         # sync scan
    #         if hasattr(self, "scan_sync") and callable(getattr(self, "scan_sync")):
    #             try:
    #                 return await self._maybe_wrap_sync(self.scan_sync, target, **kwargs)
    #             except NotImplementedError:
    #                 pass
    #
    #         # async execute
    #         if hasattr(self, "execute"):
    #             try:
    #                 return await self.execute(target, **kwargs)
    #             except NotImplementedError:
    #                 pass
    #
    #         # sync execute
    #         if hasattr(self, "execute_sync") and callable(getattr(self, "execute_sync")):
    #             try:
    #                 return await self._maybe_wrap_sync(self.execute_sync, target, **kwargs)
    #             except NotImplementedError:
    #                 pass
    #
    #         raise NotImplementedError("Tool has no usable scan/execute implementation.")
    #
    #     except asyncio.TimeoutError:
    #         logger.exception(f"[{self.TOOL_NAME}:{self.TOOL_MODE}] timed out")
    #         return {"status": "timeout"}
    #     except Exception as e:
    #         logger.exception(f"[{self.TOOL_NAME}:{self.TOOL_MODE}] error: {e}")
    #         return {"status": "error", "error": str(e)}
