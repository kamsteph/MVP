"""
Advanced GNN architectures for AI Pentest Managers.

NetworkManagerGNN       -> Residual GCN (graph-level)
VulnerabilityManagerGNN -> Hybrid GCN+GAT (graph-level)
ExploitManagerGNN       -> Multi-head GAT (node-level, multi-task)

Designed for research-grade robustness and transferability.
"""

from typing import Optional
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch_geometric.nn import (
    GCNConv, GATConv, GraphNorm, BatchNorm, global_mean_pool
)

# ---------------------------------------------------------------------
# Utility blocks
# ---------------------------------------------------------------------

class ResidualBlock(nn.Module):
    """GCN block with BatchNorm, residual connection, and dropout."""
    def __init__(self, in_dim, out_dim, dropout=0.3):
        super().__init__()
        self.conv = GCNConv(in_dim, out_dim)
        self.bn = BatchNorm(out_dim)
        self.res_fc = nn.Linear(in_dim, out_dim) if in_dim != out_dim else None
        self.dropout = dropout

    def forward(self, x, edge_index):
        identity = x
        #message passing
        x = self.conv(x, edge_index)
        x = self.bn(x)
        x = F.relu(x)
        x = F.dropout(x, p=self.dropout, training=self.training)
        if self.res_fc is not None:
            identity = self.res_fc(identity)
        return x + identity


# ---------------------------------------------------------------------
# 1. NetworkManagerGNN  (Phase 1A: Mapping & Delegation)
# ---------------------------------------------------------------------
class NetworkManagerGNN(nn.Module):
    """
    Residual GCN for learning topology patterns and scan-delegation logic.
    Graph-level classifier: predicts whether to map deeper or delegate tasks.
    """
    def __init__(self, in_channels=11, hidden=64, num_classes=2, dropout=0.3):
        super().__init__()
        self.block1 = ResidualBlock(in_channels, hidden, dropout)
        self.block2 = ResidualBlock(hidden, hidden, dropout)
        self.block3 = ResidualBlock(hidden, hidden, dropout)
        self.norm = GraphNorm(hidden)

        self.classifier = nn.Sequential(
            nn.Linear(hidden, hidden // 2),
            nn.ReLU(),
            nn.Dropout(p=dropout),
            nn.Linear(hidden // 2, num_classes)
        )

    def forward(self, x, edge_index, batch):
        x = self.block1(x, edge_index)
        x = self.block2(x, edge_index)
        x = self.block3(x, edge_index)
        x = self.norm(x, batch)
        g = global_mean_pool(x, batch)
        return self.classifier(g)


# ---------------------------------------------------------------------
# 2. VulnerabilityManagerGNN  (Phase 1B/1C: Surface & Vuln Analysis)
# ---------------------------------------------------------------------
class VulnerabilityManagerGNN(nn.Module):
    """
    Hybrid GCN + GAT for analyzing vulnerability context.
    Graph-level classifier: assess risk & readiness for exploitation.
    """
    def __init__(self, in_channels=11, hidden=64, num_classes=2, dropout=0.3):
        super().__init__()
        self.gcn1 = GCNConv(in_channels, hidden)
        self.gat1 = GATConv(hidden, hidden // 2, heads=4, concat=True, dropout=dropout)
        self.bn = BatchNorm(hidden * 2)
        self.gcn2 = GCNConv(hidden * 2, hidden)
        self.norm = GraphNorm(hidden)
        self.dropout = dropout

        self.classifier = nn.Sequential(
            nn.Linear(hidden, hidden // 2),
            nn.ReLU(),
            nn.Dropout(p=dropout),
            nn.Linear(hidden // 2, num_classes)
        )

    def forward(self, x, edge_index, batch):
        # Layer 1: neighborhood mixing
        x1 = F.relu(self.gcn1(x, edge_index))
        # Layer 2: attention fusion for multi-service contexts
        x2 = F.elu(self.gat1(x1, edge_index))
        # concatenate GCN + GAT signals
        x = torch.cat([x1, x2], dim=1)
        x = self.bn(x)
        x = F.relu(self.gcn2(x, edge_index))
        x = self.norm(x, batch)
        g = global_mean_pool(x, batch)
        return self.classifier(g)


# ---------------------------------------------------------------------
# 3. ExploitManagerGNN  (Phase 2: Exploitation Prioritization)
# ---------------------------------------------------------------------
class ExploitManagerGNN(nn.Module):
    """
    Multi-head GAT for per-node exploitability prediction.

    Outputs:
        - success_logits: raw scores for exploitation success (BCE loss)
        - severity_score: predicted severity (scaled 0-1)
    """
    def __init__(self, in_channels=16, hidden=48, heads=6, dropout=0.25):
        super().__init__()
        self.gat1 = GATConv(in_channels, hidden, heads=heads, concat=True, dropout=dropout)
        self.norm1 = BatchNorm(hidden * heads)
        self.gat2 = GATConv(hidden * heads, hidden, heads=2, concat=True, dropout=dropout)
        self.norm2 = BatchNorm(hidden * 2)
        self.out_success = nn.Linear(hidden * 2, 1)
        self.out_severity = nn.Linear(hidden * 2, 1)

    def forward(self, x, edge_index, batch=None):
        x = F.elu(self.gat1(x, edge_index))
        x = self.norm1(x)
        x = F.elu(self.gat2(x, edge_index))
        x = self.norm2(x)
        return {
            "success_logits": self.out_success(x).squeeze(-1),
            "severity_score": torch.sigmoid(self.out_severity(x)).squeeze(-1)
        }
