"""
graph_builders.py

Builds graph structures and defines the logic wrapper for each GNN:
- NetworkGraphBuilder (for NetworkManagerGNN)
- VulnerabilityGraphBuilder (for VulnerabilityManagerGNN)
- ExploitGraphBuilder (for ExploitManagerGNN)

Each builder:
  1. Transforms raw scan data into a torch_geometric.data.Data object
  2. (Optionally) batches multiple graphs
  3. Provides forward() for training or evaluation
"""

import ipaddress
import random
from collections import defaultdict
from typing import List, Dict, Optional

import torch
from torch_geometric.data import Data, Batch

from Network_Pentest.network.Brain.gnn_models import NetworkManagerGNN, VulnerabilityManagerGNN, ExploitManagerGNN


# -------------------------------------------------------------------------
# Utility
# -------------------------------------------------------------------------
def ip_to_subnet(ip_str: str, prefix: int = 24) -> Optional[str]:
    """Convert IP to subnet string like '192.168.1.0/24'."""
    try:
        ip = ipaddress.ip_address(ip_str)
        network = ipaddress.ip_network(f"{ip}/{prefix}", strict=False)
        return f"{network.network_address}/{prefix}"
    except Exception:
        return None


# -------------------------------------------------------------------------
# 1 Network Graph Builder (Phase 1A)
# -------------------------------------------------------------------------
class NetworkGraphBuilder:
    """
    Builds network topology graphs for NetworkManagerGNN.

    Nodes = hosts; edges = subnet + service + observed links
    Features = vulnerabilities, CVSS, exploit flags, risk level, etc.
    """
    def __init__(self, subnet_prefix=24):
        self.subnet_prefix = subnet_prefix
        self.model = NetworkManagerGNN(in_channels=11, hidden=64, num_classes=2)

    def build_graph(self, scan_results: List[Dict]) -> Data:
        nodes = []
        edges = set()
        subnet_map = defaultdict(list)
        cve_map = defaultdict(list)
        service_map = defaultdict(list)
        ip_index = {}

        for idx, r in enumerate(scan_results):
            ip_index[r["ip"]] = idx

        for idx, res in enumerate(scan_results):
            vulns = res.get("vulnerabilities", [])
            services = res.get("services", [])
            num_vulns = len(vulns)
            max_cvss = max([v.get("cvss", 0.0) for v in vulns]) if vulns else 0.0
            has_exploit = 1 if any(v.get("exploit", False) for v in vulns) else 0
            num_services = len(services)
            risk = res.get("risk", "").lower()

            r_high, r_med, r_low = int(risk == "high"), int(risk == "medium"), int(risk == "low")

            nodes.append({
                "num_vulns": num_vulns,
                "max_cvss": max_cvss,
                "has_exploit": has_exploit,
                "num_services": num_services,
                "risk_high": r_high,
                "risk_med": r_med,
                "risk_low": r_low,
                "ip": res.get("ip"),
                "vulns": [v.get("cve") for v in vulns if v.get("cve")],
                "services": [s.get("name") for s in services],
                "observed_connections": res.get("observed_connections", []),
            })

            ip = res.get("ip")
            if ip:
                subnet = ip_to_subnet(ip, self.subnet_prefix)
                if subnet:
                    subnet_map[subnet].append(idx)
            for v in nodes[-1]["vulns"]:
                cve_map[v].append(idx)
            for s in nodes[-1]["services"]:
                service_map[s].append(idx)

        def add_edge(a, b):
            if a == b: return
            if a < b: edges.add((a, b))
            else: edges.add((b, a))

        for idxs in subnet_map.values():
            for i in range(len(idxs)):
                for j in range(i + 1, len(idxs)):
                    add_edge(idxs[i], idxs[j])
        for idxs in cve_map.values():
            for i in range(len(idxs)):
                for j in range(i + 1, len(idxs)):
                    add_edge(idxs[i], idxs[j])
        for idxs in service_map.values():
            for i in range(len(idxs)):
                for j in range(i + 1, len(idxs)):
                    add_edge(idxs[i], idxs[j])

        for idx, node in enumerate(nodes):
            for peer_ip in node["observed_connections"]:
                j = ip_index.get(peer_ip)
                if j is not None: add_edge(idx, j)

        # Construct feature matrix
        feats = []
        for n in nodes:
            feats.append([
                n["num_vulns"], n["max_cvss"], n["has_exploit"],
                n["num_services"], n["risk_high"], n["risk_med"], n["risk_low"],
                len(subnet_map.get(ip_to_subnet(n["ip"], self.subnet_prefix), [])),
                len(n["vulns"]), len(n["services"]),
                len(n["observed_connections"])
            ])
        x = torch.tensor(feats, dtype=torch.float)
        edge_index = torch.tensor(list(edges), dtype=torch.long).t().contiguous() if edges else torch.empty((2, 0), dtype=torch.long)
        return Data(x=x, edge_index=edge_index)

    def forward(self, data: Data):
        batch = torch.zeros(data.num_nodes, dtype=torch.long)
        logits = self.model(data.x, data.edge_index, batch)
        return logits


# -------------------------------------------------------------------------
# 2 Vulnerability Graph Builder (Phase 1B / 1C)
# -------------------------------------------------------------------------
class VulnerabilityGraphBuilder:
    """
    Builds vulnerability relation graphs for the VulnerabilityManagerGNN.
    Nodes = vulnerabilities or services.
    """
    def __init__(self):
        self.model = VulnerabilityManagerGNN(in_channels=11, hidden=64, num_classes=2)

    def build_graph(self, vuln_data: List[Dict]) -> Data:
        # Each node represents a discovered vulnerability
        x = []
        edges = []
        for i, v in enumerate(vuln_data):
            sev = v.get("severity", 0)
            exploit = int(v.get("has_exploit", False))
            cvss = v.get("cvss", 0.0)
            port = v.get("port", 0)
            risk_vec = [int(v.get("risk") == r) for r in ["low", "medium", "high"]]
            x.append([sev, cvss, exploit, port] + risk_vec + [random.random() for _ in range(5)])
            for j in range(i):
                # connect if same service or similar severity
                if abs(sev - vuln_data[j].get("severity", 0)) <= 1:
                    edges.append((i, j))
                    edges.append((j, i))
        x = torch.tensor(x, dtype=torch.float)
        edge_index = torch.tensor(edges, dtype=torch.long).t().contiguous() if edges else torch.empty((2, 0), dtype=torch.long)
        return Data(x=x, edge_index=edge_index)

    def forward(self, data: Data):
        batch = torch.zeros(data.num_nodes, dtype=torch.long)
        logits = self.model(data.x, data.edge_index, batch)
        return logits


# -------------------------------------------------------------------------
# 3 Exploit Graph Builder (Phase 2)
# -------------------------------------------------------------------------
class ExploitGraphBuilder:
    """
    Builds graphs of exploit candidates for ExploitManagerGNN.
    Nodes = exploits, edges = shared ports / services / CVEs
    """
    def __init__(self):
        self.model = ExploitManagerGNN(in_channels=6, hidden=48)

    def build_graph(self, exploits: List[Dict]) -> Data:
        edges = []
        x = []
        for i, e in enumerate(exploits):
            sev = e.get("severity", 0.0)
            port = e.get("port", 0)
            success = int(e.get("previous_success", False))
            age = e.get("exploit_age", 0)
            tool_vec = [1 if e.get("exploit_tool", "") == "metasploit" else 0]
            x.append([sev, port, success, age] + tool_vec + [random.random()])
            for j in range(i):
                if abs(port - exploits[j].get("port", 0)) < 2:
                    edges.append((i, j))
                    edges.append((j, i))
        x = torch.tensor(x, dtype=torch.float)
        edge_index = torch.tensor(edges, dtype=torch.long).t().contiguous() if edges else torch.empty((2, 0), dtype=torch.long)
        return Data(x=x, edge_index=edge_index)

    def forward(self, data: Data):
        return self.model(data.x, data.edge_index)
