
import ipaddress

MAX_EXPANSION = 65536 #max number of ip allowed
import ipaddress
from typing import List, Tuple, Union

class TargetExpansionError(ValueError):
    pass

def normalize_targets(
        raw_targets: List[str],
        subnetmask_enabled: bool = False,
        max_expansion: int = MAX_EXPANSION
) -> Tuple[List[str], List[str]]:
    """
    Normalizes a list of raw target strings into a pair:
      (explicit_targets, retained_cidrs)
    - explicit_targets: list of explicit IP strings (result of expansions + single IPs)
    - retained_cidrs: list of CIDR strings (kept as-is because too large to expand or IPv6 large)
    Rules:
      - If subnetmask_enabled is False: only single IPs allowed (no '/' and no '-').
      - If subnetmask_enabled is True: allow CIDR and range (dash).
    Raises TargetExpansionError on invalid input or too-large expansion.
    """
    explicit: List[str] = []
    retained_cidrs: List[str] = []

    for t in raw_targets:
        t = t.strip()
        if not t:
            continue

        # RANGE handling: "start-end"
        if "-" in t:
            if not subnetmask_enabled:
                raise TargetExpansionError(f"Range not allowed unless subnetmask_enabled is true: {t}")

            start_s, end_s = t.split("-", 1)
            try:
                start_ip = ipaddress.ip_address(start_s.strip())
                end_ip = ipaddress.ip_address(end_s.strip())
            except ValueError as e:
                raise TargetExpansionError(f"Invalid IP in range '{t}': {e}")

            if start_ip.version != end_ip.version:
                raise TargetExpansionError(f"Mismatched IP versions in range: {t}")

            # compute size
            size = int(end_ip) - int(start_ip) + 1
            if size <= 0:
                raise TargetExpansionError(f"Invalid range (end before start): {t}")
            if size > max_expansion:
                raise TargetExpansionError(f"Requested range too large ({size} IPs). Limit: {max_expansion}")

            # expand (note: for IPv6 small ranges ok; but we keep policy conservative)
            cur = int(start_ip)
            for i in range(size):
                explicit.append(str(ipaddress.ip_address(cur + i)))
            continue

        # CIDR handling: "addr/x"
        if "/" in t:
            if not subnetmask_enabled:
                raise TargetExpansionError(f"CIDR notation not allowed unless subnetmask_enabled is true: {t}")
            try:
                net = ipaddress.ip_network(t.strip(), strict=False)
            except ValueError as e:
                raise TargetExpansionError(f"Invalid CIDR '{t}': {e}")

            num_hosts = net.num_addresses
            # For IPv4 small networks, we can expand safely
            if net.version == 4 and num_hosts <= max_expansion:
                # expand hosts â€” use .hosts() to skip network/broadcast if desired
                explicit.extend([str(ip) for ip in net.hosts()])
            else:
                # For large IPv4 nets or IPv6, keep CIDR string for tools that support it
                retained_cidrs.append(t.strip())
            continue

        # Single IP
        try:
            ip = ipaddress.ip_address(t)
            explicit.append(str(ip))
        except ValueError:
            raise TargetExpansionError(f"Invalid IP address: {t}")

    # final safety: don't exceed max_expansion with explicit list
    if len(explicit) > max_expansion:
        raise TargetExpansionError(f"Total expanded explicit targets too large: {len(explicit)} > {max_expansion}")

    return explicit, retained_cidrs
