# Network_Pentest/network/utils/low_hanging_fruits.py
from typing import Dict, Any, List, Tuple

from Network_Pentest.network.Brain.hyperparams import LHF_WEIGHTS, DEFAULT_BANNER_PATTERNS, KNOWN_DEFAULT_CREDENTIALS
from back_end.database import DatabaseManager
import re

def _banner_has_default_indicators(banner_text: str) -> bool:
    if not banner_text:
        return False
    txt = banner_text.lower()
    for p in DEFAULT_BANNER_PATTERNS:
        if re.search(p, txt):
            return True
    # check for user:pass pattern
    if re.search(r"\b(admin|root|guest|user)\s*[:/]\s*(admin|root|password|)\b", txt):
        return True
    return False

def detect_low_hanging_fruits(vuln_record: Dict[str, Any], host_record: Dict[str, Any], db: DatabaseManager = None) -> Tuple[List[Dict[str, Any]], float]:
    """
    Inspect vuln_record + host_record and DB for evidence of low-hanging fruits.

    Inputs:
      - vuln_record: single vulnerability dict (may include 'cve', 'service', 'port', 'cvss', 'evidence', 'banner', etc.)
      - host_record: host-level info (ip, services, discovered_credentials list, user_roles, observed_connections, etc.)
      - db: DatabaseManager instance (optional). If None, a new DatabaseManager() is used.

    Returns:
      - lh_list: list of dicts like {"tag": "default_creds", "weight": -0.35, "reason": "..."}
      - adjusted_score: float in [0.0, 1.0] where lower = easier target (clamped)
    """
    db = db or DatabaseManager()
    # starting baseline score (neutral)
    base_score = 0.6
    deltas = 0.0
    lh_list = []

    # ---- 1) default credentials / default config evidence ----
    # Heuristics:
    #  - if host_record contains discovered_credentials that match common defaults
    #  - OR service banner (or vuln_record.summary) contains default indicators
    discovered_creds = host_record.get("discovered_credentials", []) or []  # list of {"user","pass","source"}
    found_default = False
    for cred in discovered_creds:
        try:
            u = str(cred.get("user", "")).lower()
            p = str(cred.get("pass", "")).lower()
            if (u, p) in KNOWN_DEFAULT_CREDENTIALS or u in ("admin","root","guest") and (p in ("", "password", "root", "admin")):
                found_default = True
                reason = f"credential {u}:{p} discovered"
                break
        except Exception:
            continue

    banner = vuln_record.get("banner") or host_record.get("banner") or vuln_record.get("summary") or ""
    if not found_default:
        if _banner_has_default_indicators(banner):
            found_default = True
            reason = "banner/summary indicates default credentials/config"

    if found_default:
        w = LHF_WEIGHTS["default_creds"]
        deltas += w
        lh_list.append({"tag": "default_creds", "weight": w, "reason": reason})

    # ---- 2) shared credentials across multiple systems ----
    # Check agent memory or a credentials collection for reuse
    # For simplicity, check host_record.get("shared_credentials") or query agent_memory collection
    shared_flag = False
    try:
        # If host_record provides shared_credentials indicator
        if host_record.get("shared_credentials"):  # boolean or list
            shared_flag = True
            reason = "host_record flagged shared_credentials"
        else:
            # Try agent memory (store of known creds across hosts)
            mem = db.get_memory_state(host_record.get("ip")) or {}
            # mem could contain 'known_credentials': [{"user":"u","pass":"p","seen_on":[ip1, ip2]}]
            known = mem.get("known_credentials") or []
            for k in known:
                seen = k.get("seen_on") or []
                if isinstance(seen, list) and len(seen) > 1:
                    shared_flag = True
                    reason = f"credential {k.get('user')} reused across {len(seen)} hosts"
                    break
    except Exception:
        shared_flag = False

    if shared_flag:
        w = LHF_WEIGHTS["shared_creds"]
        deltas += w
        lh_list.append({"tag": "shared_creds", "weight": w, "reason": reason})

    # ---- 3) admin_all_users / broad privileges ----
    # Host_record may include user_roles or local_admin_count, or a 'config' hint
    admin_flag = False
    try:
        roles = host_record.get("user_roles") or []  # e.g. [{"user":"joe","admin":True}, ...]
        if isinstance(roles, list):
            # if many users have admin or a flag all_admins set
            admin_count = sum(1 for r in roles if r.get("admin"))
            if admin_count and admin_count >= max(1, int(len(roles) * 0.6)):
                admin_flag = True
                reason = f"{admin_count}/{len(roles)} users have admin"
        # fallback: a simple marker field
        if host_record.get("all_users_admin") or host_record.get("local_admin_equals_users"):
            admin_flag = True
            reason = "host flagged all users have admin privileges"
    except Exception:
        admin_flag = False

    if admin_flag:
        w = LHF_WEIGHTS["admin_all_users"]
        deltas += w
        lh_list.append({"tag": "admin_all_users", "weight": w, "reason": reason})

    # ---- 4) missing patches with public exploits (ADB/exploit_assets evidence) ----
    public_exploit_flag = False
    try:
        cve = (vuln_record.get("cve") or vuln_record.get("id") or "").upper()
        if cve:
            # Prefer checking the augmented db for an indicator
            adb_doc = None
            try:
                adb_doc = db.adb.find_one({"cve": cve})
            except Exception:
                # fallback to DatabaseManager.find_one if implemented
                try:
                    adb_doc = db.find_one("augmented_database", {"cve": cve})
                except Exception:
                    adb_doc = None
            if adb_doc:
                # check explicit has_exploit flag or exploit_urls/pocs
                if adb_doc.get("has_exploit") or (adb_doc.get("exploit_urls") and len(adb_doc.get("exploit_urls"))>0):
                    public_exploit_flag = True
                    reason = f"ADB indicates exploit available for {cve}"
                else:
                    # also check exploit_assets collection for matching cve
                    assets = db.find_exploit_assets({"cves": cve}, limit=1)
                    if assets:
                        public_exploit_flag = True
                        reason = f"exploit_assets contains PoC for {cve}"
    except Exception:
        public_exploit_flag = False

    if public_exploit_flag:
        w = LHF_WEIGHTS["public_exploit"]
        deltas += w
        lh_list.append({"tag": "public_exploit", "weight": w, "reason": reason})

    # ---- compute final score, clamp --------------------------
    adjusted = base_score + deltas
    # clamp between 0 and 1
    adjusted = max(0.0, min(1.0, adjusted))

    return lh_list, adjusted
