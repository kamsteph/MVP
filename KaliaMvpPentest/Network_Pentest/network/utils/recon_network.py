# new_module/recon.py
import subprocess
import os
from typing import Dict, Any, Iterable, List, Union, Optional
from concurrent.futures import ThreadPoolExecutor, as_completed

from back_end.utils.colored_logger import get_logger

logger = get_logger(__name__, component="RECON", region="NETWORK")


class Recon:
    """
    Lightweight reconnaissance module.
    - Checks host liveness (ping).
    - Runs very fast sanity checks before heavier scans.

    scan(targets, hints=None, concurrent=True, max_workers=20)
      - targets: str (single IP), iterable of str, or comma/newline separated string
      - hints: dict applied to all targets OR dict mapping ip -> hints
      - concurrent: run checks in parallel (ThreadPoolExecutor)
      - returns: dict for single target, or list[dict] for multiple targets
    """

    def __init__(self):
        pass

    @staticmethod
    def _normalize_targets(targets: Union[str, Iterable[str]]) -> List[str]:
        # Accept single string IP or iterable. Also allow comma/newline-separated strings.
        if isinstance(targets, str):
            # split if multiple items provided as a single string
            if "," in targets or "\n" in targets or " " in targets:
                parts = [p.strip() for p in targets.replace("\n", ",").split(",")]
                return [p for p in parts if p]
            return [targets]
        # Otherwise assume iterable of strings
        return [str(t).strip() for t in targets]

    @staticmethod
    def is_host_alive(ip: str, timeout: int = 2) -> bool:
        """
        Check if a host is alive using ping.
        Uses subprocess.run with a timeout and OS-aware parameter.
        Returns True if ping returned exit code 0.
        """
        param = "-n" if os.name == "nt" else "-c"
        # On some systems you might also want to add a timeout param like -w or -W
        ping_cmd = ["ping", param, "1", ip]
        try:
            completed = subprocess.run(
                ping_cmd,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                timeout=timeout,
            )
            return completed.returncode == 0
        except subprocess.TimeoutExpired:
            logger.debug(f"Ping timeout for {ip}")
            return False
        except FileNotFoundError:
            # ping not found on system â€” fallback: mark as unknown/down
            logger.error("ping executable not found on system PATH.")
            return False
        except Exception as e:
            logger.error(f"Ping check failed for {ip}: {e}")
            return False

    def _scan_single(self, ip: str, hints: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        logger.info(f"[Recon] Recon for {ip} started.")
        result = {"target": ip, "alive": False}

        alive = self.is_host_alive(ip)
        if not alive:
            logger.warning(f"[Recon] Host {ip} appears down.")
            result["alive"] = False
            return result

        logger.info(f"[Recon] Host {ip} is alive.")
        result["alive"] = True

        # Use attack surface hints (either global hints or hints specific to ip)
        if hints:
            # If hints is mapping ip->hints, extract for this ip
            if isinstance(hints, dict) and any(isinstance(k, str) for k in hints.keys()) and ip in hints and isinstance(hints[ip], dict):
                local_hints = hints[ip]
            else:
                local_hints = hints  # apply same hints to all

            if isinstance(local_hints, dict) and "attack_surface" in local_hints:
                for surf in local_hints["attack_surface"]:
                    if "Email servers" in surf.get("surface", ""):
                        result.setdefault("mx_enum", []).append(f"Checked MX records for {ip}")
                    if "VPN gateways" in surf.get("surface", ""):
                        result.setdefault("vpn_ports", []).append(f"Scanned VPN ports for {ip}")

        return result

    def scan(
            self,
            targets: Union[str, Iterable[str]],
            hints: Optional[Union[Dict[str, Any], Dict[str, Dict[str, Any]]]] = None,
            concurrent: bool = True,
            max_workers: int = 20,
    ) -> Union[Dict[str, Any], List[Dict[str, Any]]]:
        """
        Run lightweight recon on one or many hosts.
        - targets: single IP string or iterable of IPs (or comma/newline separated string)
        - hints: either a global hints dict applied to all targets, or a dict mapping ip->hints
        - concurrent: whether to perform pings concurrently
        - returns: dict for single target, or list[dict] for multiple targets
        """
        ips = self._normalize_targets(targets)
        logger.info(f"[Recon] Starting reconnaissance for {len(ips)} target(s).")

        # Fast path: single ip
        if len(ips) == 1:
            return self._scan_single(ips[0], hints)

        results: List[Dict[str, Any]] = []
        if concurrent:
            workers = min(max_workers, len(ips))
            with ThreadPoolExecutor(max_workers=workers) as ex:
                future_to_ip = {ex.submit(self._scan_single, ip, hints): ip for ip in ips}
                for fut in as_completed(future_to_ip):
                    ip = future_to_ip[fut]
                    try:
                        results.append(fut.result())
                    except Exception as e:
                        logger.error(f"[Recon] Exception scanning {ip}: {e}")
                        results.append({"target": ip, "alive": False, "error": str(e)})
        else:
            for ip in ips:
                try:
                    results.append(self._scan_single(ip, hints))
                except Exception as e:
                    logger.error(f"[Recon] Exception scanning {ip}: {e}")
                    results.append({"target": ip, "alive": False, "error": str(e)})

        return results
