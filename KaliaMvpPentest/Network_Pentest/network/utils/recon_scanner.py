# new_module/recon_scanner.py
import asyncio
import logging
from typing import Dict, Any, Iterable, List, Union, Optional

from Network_Pentest.network.Managers.network_vuln_manager import VulnScanManager
from Network_Pentest.network.utils.recon_network import Recon

logger = logging.getLogger("ReconScanner")

class ReconScanner:
    def __init__(self, vulnscan_mgr: VulnScanManager):
        self.recon = Recon()
        self.vulnscan_mgr = vulnscan_mgr

    @staticmethod
    def _normalize_targets(targets: Union[str, Iterable[str]]) -> List[str]:
        if isinstance(targets, str):
            # split on commas, newlines or whitespace if user provided multiple in one string
            if "," in targets or "\n" in targets or " " in targets:
                parts = [p.strip() for p in targets.replace("\n", ",").split(",")]
                return [p for p in parts if p]
            return [targets]
        # iterable
        return [str(t).strip() for t in targets]

    async def _run_recon_in_executor(self, ip: str, hints_for_ip: Optional[Dict[str, Any]] = None, loop: Optional[asyncio.AbstractEventLoop] = None) -> Dict[str, Any]:
        """
        Runs the (synchronous) Recon.scan for a single ip in a thread pool executor to avoid blocking.
        Note: Recon.scan returns a dict for a single ip (per the recon implementation).
        """
        loop = loop or asyncio.get_running_loop()
        return await loop.run_in_executor(None, self.recon.scan, ip, hints_for_ip)

    async def _scan_one(self, ip: str, task_id: str, hints_for_ip: Optional[Dict[str, Any]], sem: asyncio.Semaphore) -> Dict[str, Any]:
        """
        Scans a single target: recon (in executor), then vulnscan if alive.
        Uses semaphore to limit concurrent vuln scans.
        """
        async with sem:
            try:
                # Run recon (blocking) in executor
                recon_data = await self._run_recon_in_executor(ip, hints_for_ip)
                if not recon_data.get("alive"):
                    return {"task_id": task_id, "target": ip, "alive": False, "recon": recon_data}

                # Recon reports alive -> delegate to vuln scanner (async)
                # alive_hosts = []
                # for ip in ip_list:
                #     recon_res = await recon_scanner.scan(task_id, ip, hints)
                #     if recon_res.get("alive"):
                #         alive_hosts.append(ip)

                #scan_results = await vulnscan_mgr.scan_target(alive_hosts, hints)

                scan_results = await self.vulnscan_mgr.scan_target(target_ip=ip, hints=hints_for_ip)
                # Merge results, include recon data for traceability
                merged = {"task_id": task_id, "target": ip, "alive": True}
                merged.update(scan_results if isinstance(scan_results, dict) else {"vuln_results": scan_results})
                merged["recon"] = recon_data
                return merged
            except Exception as e:
                logger.exception(f"Exception scanning {ip}: {e}")
                return {"task_id": task_id, "target": ip, "alive": False, "error": str(e)}

    async def scan(
            self,
            task_id: str,
            target_ip: Union[str, Iterable[str]],
            hints: Optional[Union[Dict[str, Any], Dict[str, Dict[str, Any]]]] = None,
            max_concurrency: int = 20,
    ) -> Union[Dict[str, Any], List[Dict[str, Any]]]:
        """
        Perform recon on target(s), then delegate vuln scan for alive hosts.

        - task_id: traceable id for the whole operation
        - target_ip: single ip string OR iterable of ip strings OR comma/newline separated string
        - hints: either a global hints dict applied to all targets, or a dict mapping ip->hints
        - max_concurrency: maximum number of concurrent scans (affects both recon and vuln scans)
        - returns: dict for single input target, or list[dict] for multiple targets
        """
        ips = self._normalize_targets(target_ip)
        logger.info(f"[ReconScanner] Starting scan for {len(ips)} target(s).")

        # Prepare semaphore to limit concurrent tasks
        sem = asyncio.Semaphore(max_concurrency)

        tasks = []
        for ip in ips:
            # Determine hints for this IP: either per-ip mapping or global hints
            if isinstance(hints, dict) and ip in hints and isinstance(hints[ip], dict):
                hints_for_ip = hints[ip]
            else:
                hints_for_ip = hints  # could be None or global hints dict

            tasks.append(asyncio.create_task(self._scan_one(ip, task_id, hints_for_ip, sem)))

        # Await all tasks
        results = await asyncio.gather(*tasks, return_exceptions=False)

        # If single ip was provided, return single dict (backwards compat)
        if len(results) == 1:
            return results[0]
        return results
