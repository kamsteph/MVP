
import subprocess
from datetime import datetime
from typing import Optional, List, Dict
import os
import sys
import logging

from Network_Pentest.network.parse_scan import parse_nmap_output
from back_end.utils.ai_summary import generate_ai_summary
from back_end.utils.export_report import export_to_pdf

# Ensure the base directory is in the system path for imports
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(BASE_DIR)

# Configure a consistent logger
logging.basicConfig(level=logging.INFO, format="%(asctime)s - [VulnScan] - %(levelname)s - %(message)s")


class VulnScan:
    """
    Network vulnerability scanner.
    Wraps Naabu (fast port scanner) and Nmap (detailed service/OS scan).
    """

    def __init__(self, naabu_path: str, nmap_path: str):
        self.naabu_path = naabu_path
        self.nmap_path = nmap_path

    def run_naabu(
            self, ip: str, recon_data: Optional[Dict] = None,
            port_ranges: str = "top-100", silent: bool = True
    ) -> List[int]:
        """
        Run Naabu scan.
        - Supports top-100, top-1000, or custom port ranges
        - Validates IP before scanning
        - Returns list of open ports
        """
        if not self.is_valid_ip(ip):
            logging.error(f"Invalid IP address: {ip}. Skipping Naabu scan.")
            return []

        #ports = recon_data.get("ports") if recon_data and "ports" in recon_data else None
        cmd = [self.naabu_path, "-host", ip]

        # Handle port range selection
        if port_ranges == "top-100":
            cmd += ["-top-ports", "100"]
        elif port_ranges == "top-1000":
            cmd += ["-top-ports", "1000"]
        else:
            try:
                custom_ports = parse_nmap_output(port_ranges)
                valid_ports = [str(p) for p in custom_ports if 0 < p < 65536]
                if valid_ports:
                    cmd += ["-p", ",".join(valid_ports)]
            except ValueError:
                logging.error(f"Invalid custom port range: {port_ranges}. Defaulting to top-100.")
                cmd += ["-top-ports", "100"]

        if silent:
            cmd.append("-silent")

        logging.info(f"Running Naabu: {' '.join(cmd)}")

        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        except FileNotFoundError:
            logging.error(f"Naabu not found at {self.naabu_path}. Check the path.")
            return []
        except subprocess.CalledProcessError as e:
            logging.error(f"Naabu failed (code {e.returncode}). stderr: {e.stderr}")
            return []

        # Parse open ports from output
        open_ports = []
        for line in result.stdout.splitlines():
            line = line.strip()
            if line.isdigit():
                open_ports.append(int(line))
            elif ':' in line:
                try:
                    open_ports.append(int(line.split(':')[-1]))
                except ValueError:
                    logging.warning(f"Could not parse port: {line}")

        logging.info(f"Naabu found {len(open_ports)} open ports on {ip}")
        return open_ports

    def run_nmap(
            self, target_ip: str, ports: List[int],
            #recon_data: Optional[Dict] = None,
            output_file: str = "scan_output.xml", timing: str = "4", ping_scan: bool = True
    ) -> str:
        if not ports:
            logging.warning(f"No ports provided for Nmap on {target_ip}. Skipping.")
            return None  # important

        if not self.is_valid_ip(target_ip):
            logging.error(f"Invalid target IP: {target_ip}. Skipping Nmap scan.")
            return None

        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        base_filename = f"{os.path.basename(output_file).strip().split('.')[0]}_{timestamp}.xml"
        safe_output_path = os.path.join(BASE_DIR, "reports", base_filename)
        os.makedirs(os.path.dirname(safe_output_path), exist_ok=True)

        port_str = ",".join(map(str, ports))

        cmd = [
            self.nmap_path,
            "-O",
            "-sV",
            "-p", port_str,
            "-T" + timing,
            "-n",
            "-oX", safe_output_path,
            target_ip
        ]
        if not ping_scan:
            cmd.append("-Pn")

        logging.info(f"Running Nmap: {' '.join(cmd)}")

        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            logging.info(f"Nmap completed. Output saved to {safe_output_path}")
        except FileNotFoundError:
            logging.error(f"Nmap not found at {self.nmap_path}. Check the path.")
            return ''
        except subprocess.CalledProcessError as e:
            logging.error(f"Nmap failed (code {e.returncode}). stderr: {e.stderr}")
            return ''

        #Parse results into structured data
        parsed_results = parse_nmap_output(safe_output_path)

        # Build PDF report
        summary_text = f"""
        # Report Summary
    
        ## Target: `{target_ip}`
    
        ## Scanned Ports: `{port_str}`
    
        ### Nmap Parsed Results
        {parsed_results}
        """
        export_to_pdf(summary_text, os.path.join(BASE_DIR, "reports"), "network_vulnerability_scan")

        ai_summary_text = generate_ai_summary(parsed_results)

        return ai_summary_text

    def is_valid_ip(self, ip: str) -> bool:
        """
        Validate if a string is a proper IPv4 or IPv6 address.
        """
        import ipaddress

        if not isinstance(ip, str):
            logging.error(f"IP must be a string, got {type(ip).__name__}")
            return False

        ip = ip.strip()
        if not ip:
            logging.error("Empty IP address provided.")
            return False

        try:
            ipaddress.ip_address(ip)
            return True
        except ValueError:
            logging.error(f"Invalid IP address format: {ip}")
            return False