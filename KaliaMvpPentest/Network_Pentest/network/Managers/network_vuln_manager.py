"""
VulnerabilityAIAgent (Smart version)
------------------------------------

AI-powered vulnerability analysis agent that:
  - Reads tool capabilities from NETWORK_CAPABILITY_MATRIX
  - Dynamically chooses the best scanner (Naabu, Nmap, or Masscan)
  - Uses GNN reasoning for contextual risk scoring
  - Applies a DQN-style learning policy to improve over time
"""

import torch
import torch.nn.functional as F
import numpy as np
import random
from typing import List, Dict, Any

from Network_Pentest.network.Brain.gnn_models import VulnerabilityManagerGNN
from Network_Pentest.network.Managers.exploitation_rl_network import ExploitationAgent
from Network_Pentest.network.tool.base_class import get_tool_by_name, resolve_tool
from Network_Pentest.network.utils.tools_surface_helper import tools_for_surface
from back_end.database import DatabaseManager
from back_end.network_cap_matrix import NETWORK_CAPABILITY_MATRIX
from back_end.utils.colored_logger import get_logger

logger = get_logger(__name__, component="VULN_AI_AGENT", region="AI")

class VulnerabilityAIAgent:
    """
    AI vulnerability assessment agent combining:
      - GNN-based contextual reasoning
      - RL-based decision policy (DQN)
      - Dynamic tool selection via NETWORK_CAPABILITY_MATRIX
    """

    def __init__(self, db: DatabaseManager, model_path: str = None, device: str = "cpu"):
        self.db = db
        self.device = torch.device(device)

        # Graph Encoder
        self.encoder = VulnerabilityManagerGNN(in_channels=11, hidden=64, num_classes=2).to(self.device)
        if model_path:
            self.encoder.load_state_dict(torch.load(model_path, map_location=self.device))
        self.encoder.eval()

        # DQN Policy Learner
        self.policy = ExploitationAgent(db, input_dim=6, hidden=64, lr=1e-3, device=device)

    # ------------------------------------------------------------
    # Capability matrix interface
    # ------------------------------------------------------------

    def get_tools_for_surface(self, attack_surface: str):
        """
        Return instantiated tool objects (preferring API then CLI).
        """
        return tools_for_surface(attack_surface, prefer_modes=("api", "cli"))

    #def get_tools_for_surface(self, attack_surface: str) -> List[Dict[str, Any]]:
        # """Return available tools for a given attack surface."""
        # for entry in NETWORK_CAPABILITY_MATRIX:
        #     if entry["attack_surface"].lower() == attack_surface.lower():
        #         return entry["tools"]
        # logger.warning(f"No tools found for surface: {attack_surface}")
        # return []

    async def run_tool(self, tool_name: str, target: str, ports: List[int] = None):

        tool = get_tool_by_name(tool_name)
        if not tool:
            logger.warning(f"No wrapper found for tool {tool_name}")
            return []
        return await tool.run_safe(target, ports=ports)


    # ------------------------------------------------------------
    # Graph feature builder (same as before)
    # ------------------------------------------------------------
    def build_graph_features(self, scan_results: List[Dict[str, Any]]) -> np.ndarray:
        from torch_geometric.data import Data

        nodes, edges = [], set()
        for idx, r in enumerate(scan_results):
            vulns = r.get("vulnerabilities", [])
            services = r.get("services", [])
            num_vulns = len(vulns)
            max_cvss = max([v.get("cvss", 0.0) for v in vulns]) if vulns else 0.0
            has_exploit = 1 if any(v.get("exploit", False) for v in vulns) else 0
            num_services = len(services)
            risk = r.get("risk", "").lower()
            r_high, r_med, r_low = int(risk == "high"), int(risk == "medium"), int(risk == "low")

            nodes.append([
                float(num_vulns), float(max_cvss), float(has_exploit), float(num_services),
                float(r_high), float(r_med), float(r_low),
                0.0, float(num_vulns), float(num_services), 0.0
            ])
            for j in range(idx):
                s1 = [s.get("name") for s in r.get("services", []) if s.get("name")]
                s2 = [s.get("name") for s in scan_results[j].get("services", []) if s.get("name")]
                if any(x in s2 for x in s1):
                    edges.add((idx, j)); edges.add((j, idx))

        x = torch.tensor(nodes, dtype=torch.float, device=self.device)
        if edges:
            edge_index = torch.tensor(list(edges), dtype=torch.long, device=self.device).t().contiguous()
        else:
            edge_index = torch.empty((2, 0), dtype=torch.long, device=self.device)
        data = Data(x=x, edge_index=edge_index, batch=torch.zeros(len(nodes), dtype=torch.long, device=self.device))
        with torch.no_grad():
            logits = self.encoder(data.x, data.edge_index, data.batch)
            probs = F.softmax(logits, dim=1).squeeze(0).cpu().numpy()
        return probs

    # ------------------------------------------------------------
    # AI decision loop
    # ------------------------------------------------------------
    async def analyze_surface(self, target_ip: str, attack_surface: str, epsilon: float = 0.1, mode: str = "live"):
        """
        Analyze a given attack surface using the best available tool and AI reasoning.
        Adds 'training' flag for honeypot/sandbox runs.
        """
        global input_vec
        training_flag = (mode == "train")

        tools = self.get_tools_for_surface(attack_surface)
        if not tools:
            logger.warning(f"No tools available for {attack_surface}")
            return None

        # 1 Encode graph context
        scan_result = {"ip": target_ip, "vulnerabilities": [], "services": []}
        graph_probs = self.build_graph_features([scan_result])
        context_mean = float(graph_probs.mean())

        # 2 Select best tool using DQN policy
        q_values = []
        for t in tools:
            input_vec = np.array([
                context_mean,
                t["priority"],
                float(t["supports_ipv6"]),
                1.0 if t["role"].startswith("service") else 0.0,
                np.random.random(),
                0.0
            ], dtype=np.float32)
            tensor = torch.from_numpy(input_vec).to(self.device)
            with torch.no_grad():
                q = self.policy.qnet(tensor).item()
            q_values.append(q)

        if np.random.random() < epsilon:
            chosen_idx = np.random.randint(0, len(tools))
        else:
            chosen_idx = int(np.argmax(q_values))

        chosen_tool = tools[chosen_idx]
        tool_name = chosen_tool["name"]
        logger.info(f"[VulnAIAgent] Selected tool {tool_name} for {attack_surface} (mode={mode})")

        # 3 Resolve actual implementation (prefers API then CLI)
        tool_instance = resolve_tool(tool_name, preferred_modes=("api", "cli"))
        if not tool_instance:
            logger.warning(f"[VulnAIAgent] No registered implementation for {tool_name}")
            return None

        # 4 Run it safely, passing training flag
        logger.info(f"[VulnAIAgent] Running {tool_name} with training={training_flag}")
        result = await tool_instance.run_safe(target_ip, training=training_flag)

        success = result and result.get("status", "").startswith("executed")
        reward = 1.0 if success else -0.3

        # 5 Learn from experience
        self.policy.store_experience(
            state_vec=input_vec.tolist(),
            action_idx=chosen_idx,
            reward=reward,
            next_state_vec=input_vec.tolist(),
            done=False
        )
        loss = self.policy.learn_from_experience(batch_size=16)
        logger.info(f"[VulnAIAgent] Learning update complete. Loss={loss:.4f}")

        # 6️⃣ Return structured result
        return {
            "target": target_ip,
            "surface": attack_surface,
            "tool": tool_name,
            "training": training_flag,
            "reward": reward,
            "results": result,
            "loss": loss
        }

# import asyncio
# import logging
# from typing import List, Optional, Dict, Any
# from Network_Pentest.network.vuln_scan_api_wrappers import NaabuAPI, NmapAPI, MasscanAPI
# from back_end.database import DatabaseManager
# from Network_Pentest.network.Managers.GNN_Features.vuln_scan_gnn import VulnScanBrain
# from back_end.event_bus import EventBus
# from back_end.network_cap_matrix import NETWORK_CAPABILITY_MATRIX
#
# logger = logging.getLogger("VulnScanManager")
#
#
# class VulnScanManager:
#     def __init__(self, db: DatabaseManager, bus: EventBus, gnn_model_path: Optional[str] = None, max_concurrency: int = 20):
#         self.db = db
#         self.bus = bus
#         self.brain = VulnScanBrain(model_path=gnn_model_path)
#         self.tools = {
#             "naabu": NaabuAPI(),
#             "nmap": NmapAPI(),
#             "masscan": MasscanAPI()
#         }
#         self.global_semaphore = asyncio.Semaphore(max_concurrency)
#         # per-target concurrency semaphore to limit simultaneous tool calls per target if needed
#         self.per_target_semaphore = asyncio.Semaphore(4)
#         # timeouts (tune to environment)
#         self.discovery_timeout = 25.0
#         self.nmap_timeout = 60.0
#
#     async def scan_target(
#             self,
#             target_ip: str,
#             hints: Optional[Dict[str, Any]] = None,
#             tool_order: Optional[List[str]] = None,
#             top_ports: Optional[int] = None,
#             custom_ports: Optional[List[int]] = None,
#     ):
#         hints = hints or {}
#         attack_surfaces = hints.get("attack_surface", [])
#         tool_hints = hints.get("tools", {})
#
#         scan_results = {"ip": target_ip, "open_ports": [], "services": [], "vulns": []}
#         memory = self.db.get_memory_state(target_ip) or {}
#
#         for surface in attack_surfaces:
#             surface_name = surface.get("surface")
#             normalized_name = surface_name.strip().replace("{", "").replace("}", "")
#             matrix_entry = next((m for m in NETWORK_CAPABILITY_MATRIX if m["attack_surface"] == normalized_name), None)
#             if not matrix_entry:
#                 logging.warning(f"No capability matrix entry for {surface_name}, skipping.")
#                 continue
#
#             # Decide ports
#             port_mode = matrix_entry.get("default_ports", "top10")
#             ports_to_scan = custom_ports or surface.get("custom_ports")
#             top_ports_to_scan = top_ports or (10 if port_mode == "top10" else 0)
#
#             # Decide tools
#             tools_for_surface = surface.get("tools") or matrix_entry.get("tools") or ["Nmap"]
#
#             # Prioritize port scanners
#             priority = {"Naabu": 1, "Masscan": 1, "Nmap": 2}
#             tools_for_surface = sorted(set(tools_for_surface), key=lambda t: priority.get(t, 99))
#             if tool_order:
#                 tools_for_surface = tool_order
#
#             # Run tools
#             for tool_name in tools_for_surface:
#                 tool = self.tools.get(tool_name.lower())
#                 if not tool:
#                     logging.warning(f"Tool {tool_name} not found, skipping.")
#                     continue
#                 try:
#                     if tool_name in ["Naabu", "Masscan"]:
#                         if ports_to_scan:
#                             res = await tool.scan(target_ip, ports=ports_to_scan)
#                         else:
#                             res = await tool.scan(target_ip, top_ports=top_ports_to_scan)
#                         scan_results["open_ports"] = list(set(scan_results["open_ports"] + res))
#                     else:
#                         res = await tool.scan(target_ip, scan_results.get("open_ports", []))
#                         scan_results["services"] += res.get("services", [])
#                         scan_results["vulns"] += res.get("vulns", [])
#                 except Exception as e:
#                     logging.warning(f"Tool {tool_name} failed on {target_ip}: {e}")
#
#         self.db.save_memory_state({"target_ip": target_ip, "last_scan": scan_results})
#         self.bus.publish_task({
#             "region": "deception",
#             "action": "deploy_honeynet",
#             "target_ip": target_ip,
#             "vuln_files": scan_results["vulns"],
#         })
#         return scan_results
