
# new_module/managers/network_manager.py
"""
NetworkManager: Phase 1A (mapping & delegation)
- Uses advanced NetworkManagerGNN to make graph-level decisions.
- Loads model weights (optional) and exposes `decide` which returns (action, probs).
"""

from typing import List, Tuple
import torch
import torch.nn.functional as F
from torch_geometric.data import Data
import ipaddress
from collections import defaultdict

from Network_Pentest.network.Brain.gnn_models import NetworkManagerGNN
from back_end.database import DatabaseManager


class NetworkManager:
    def __init__(self, model_path: str = None, device: str = "cpu", subnet_prefix: int = 24):
        self.device = torch.device(device)
        self.model = NetworkManagerGNN(in_channels=11, hidden=64, num_classes=2)
        if model_path:
            self.model.load_state_dict(torch.load(model_path, map_location=self.device))
        self.model.to(self.device)
        self.model.eval()
        self.db = DatabaseManager()
        self.subnet_prefix = subnet_prefix

    def _ip_to_subnet(self, ip_str: str):
        try:
            ip = ipaddress.ip_address(ip_str)
            network = ipaddress.ip_network(f"{ip}/{self.subnet_prefix}", strict=False)
            return f"{network.network_address}/{self.subnet_prefix}"
        except Exception:
            return None

    def build_graph(self, scan_results: List[dict]) -> Data:
        # same features as the advanced models expect (11-dim)
        nodes = []
        edges = set()
        subnet_map = defaultdict(list)
        cve_map = defaultdict(list)
        service_map = defaultdict(list)
        ip_index = {}

        for idx, r in enumerate(scan_results):
            ip = r.get("ip", f"node_{idx}")
            ip_index[ip] = idx

        for idx, r in enumerate(scan_results):
            vulns = r.get("vulnerabilities", [])
            services = r.get("services", [])
            num_vulns = len(vulns)
            max_cvss = max([v.get("cvss", 0.0) for v in vulns]) if vulns else 0.0
            has_exploit = 1 if any(v.get("exploit", False) for v in vulns) else 0
            num_services = len(services)
            risk = r.get("risk", "").lower()
            r_high, r_med, r_low = int(risk == "high"), int(risk == "medium"), int(risk == "low")

            nodes.append({
                "num_vulns": num_vulns,
                "max_cvss": max_cvss,
                "has_exploit": has_exploit,
                "num_services": num_services,
                "risk_high": r_high,
                "risk_med": r_med,
                "risk_low": r_low,
                "ip": r.get("ip"),
                "vulns": [v.get("cve") for v in vulns if v.get("cve")],
                "services": [s.get("name") or str(s.get("port")) for s in services],
                "observed_connections": r.get("observed_connections", []),
            })

            ip = r.get("ip")
            if ip:
                sn = self._ip_to_subnet(ip)
                if sn:
                    subnet_map[sn].append(idx)
            for v in nodes[-1]["vulns"]:
                cve_map[v].append(idx)
            for s in nodes[-1]["services"]:
                service_map[s].append(idx)

        def add_edge(edge_a, edge_b):
            if edge_a==edge_b: return
            if edge_a < edge_b: edges.add((edge_a, edge_b))
            else: edges.add((edge_b, edge_a))

        for idxs in subnet_map.values():
            for i in range(len(idxs)):
                for j in range(i+1, len(idxs)):
                    add_edge(idxs[i], idxs[j])
        for idxs in cve_map.values():
            for i in range(len(idxs)):
                for j in range(i+1, len(idxs)):
                    add_edge(idxs[i], idxs[j])
        for idxs in service_map.values():
            for i in range(len(idxs)):
                for j in range(i+1, len(idxs)):
                    add_edge(idxs[i], idxs[j])
        for idx, node in enumerate(nodes):
            for peer in node["observed_connections"]:
                j = ip_index.get(peer)
                if j is not None:
                    add_edge(idx, j)

        # build features (11 dims)
        feats = []
        for n in nodes:
            subnet_deg = 0
            if n["ip"]:
                sn = self._ip_to_subnet(n["ip"])
                if sn:
                    subnet_deg = len(subnet_map.get(sn, [])) - 1
            feats.append([
                float(n["num_vulns"]),
                float(n["max_cvss"]),
                float(n["has_exploit"]),
                float(n["num_services"]),
                float(n["risk_high"]),
                float(n["risk_med"]),
                float(n["risk_low"]),
                float(subnet_deg),
                float(len(n["vulns"])),
                float(len(n["services"])),
                float(len(n["observed_connections"]))
            ])
        import torch
        x = torch.tensor(feats, dtype=torch.float)
        if edges:
            el = []
            for a,b in edges:
                el.append([a,b]); el.append([b,a])
            edge_index = torch.tensor(el, dtype=torch.long).t().contiguous()
        else:
            edge_index = torch.empty((2,0), dtype=torch.long)
        return Data(x=x, edge_index=edge_index)

    def decide(self, scan_results: List[dict]) -> Tuple[str, torch.Tensor]:
        """Return (action: 'delegate'|'deeper_scan', probs tensor)"""
        data = self.build_graph(scan_results=scan_results)
        device=self.device
        data = data.to(device)
        data.batch = torch.zeros(data.num_nodes, dtype=torch.long, device=self.device)
        with torch.no_grad():
            logits = self.model(data.x, data.edge_index, data.batch)
            probs = F.softmax(logits, dim=1).squeeze(0)
            pred = int(probs.argmax().item())
        action = "delegate" if pred == 0 else "deeper_scan"
        return action, probs.cpu()

# import asyncio
# import time
# from typing import Dict, Any, List
#
# from G_L_L.l_region.local_learner import LocalLearner
# from back_end.GraphNN import GNNBrain
# from Network_Pentest.network.Managers.network_exploitation_manager import ExploitationManagerAI
# from back_end.utils.colored_logger import get_logger
# from back_end.database import DatabaseManager
# from back_end.event_bus import EventBus
# from back_end.utils.ai_summary import generate_ai_summary
# from back_end.aggregation_manager import AggregationManager
# from back_end.utils.export_report import export_report
#
# logger = get_logger(__name__, component="MANAGER", region="NETWORK")
#
#
# class NetworkManager:
#     def __init__(self, bus: EventBus, local_learner: LocalLearner, db: DatabaseManager, gnn_model_path=None):
#         self.bus = bus
#         self.db = db
#         self.local_learner = local_learner
#         self.gnn_brain = GNNBrain(model_path=gnn_model_path)
#         self.exploit_mgr = ExploitationManagerAI(db, bus)
#         self.aggregator = AggregationManager(db, model_name="ai_pentest_orchestrator_v1")
#
#         logger.info("[NETWORK] Manager initialized.")
#         self.bus.subscribe("network", self._async_wrapper)
#
#     def _async_wrapper(self, task: Dict[str, Any]):
#         asyncio.create_task(self.handle_task(task))
#
#     def _scan_allows_exploit(self, scan_type: str) -> bool:
#         s = (scan_type or "").lower()
#         return not ("scan only" in s or "scan_only" in s)
#
#     async def handle_task(self, task: Dict[str, Any]):
#         """Handles async network pentest tasks end-to-end."""
#         task_id = task.get("id") or f"task_{int(time.time())}"
#         start = time.time()
#
#         try:
#             action = task.get("action", "")
#             targets = task.get("target") or task.get("targets") or task.get("hints", {}).get("targets")
#
#             if not targets:
#                 logger.warning("[NetworkManager] Empty targets; skipping task.")
#                 return
#
#             # === Initial Scanning Stage ===
#             if action in ("initial_scan", "initial_network_scan"):
#                 self.bus.publish_task({
#                     "region": "network",
#                     "action": "network_recon_scan",
#                     "targets": targets,
#                     "parent_id": task_id
#                 })
#                 return
#
#             # === Post-Recon Decision Stage ===
#             if action == "post_recon_decision":
#                 recon = task.get("scan_results", {})
#                 if not recon:
#                     return
#
#                 try:
#                     self.db.save_scan_result(recon)
#                 except Exception:
#                     logger.exception("DB save failed during post-recon.")
#
#                 next_action = self.gnn_brain.predict([recon])
#                 do_exploit = task.get("hints", {}).get("do_exploit", False)
#
#                 if next_action == "exploitation" and do_exploit and self._scan_allows_exploit(task.get("scan_type", "")):
#                     self.bus.publish_task({
#                         "region": "network",
#                         "action": "run_exploitation",
#                         "target": targets,
#                         "parent_id": task_id
#                     })
#                 else:
#                     summary = generate_ai_summary(recon.get("findings", []))
#                     output_format = task.get("output_format", "pdf")
#                     filename_base = f"network_scan_results_{task_id}"
#                     export_report(summary, "./reports", filename_base, export_format=output_format)
#
#                     agg = self.aggregator.aggregate_partial_results(recon)
#                     end = time.time()
#
#                     self.bus.publish_event("task_completed", {
#                         "id": task_id,
#                         "region": "network",
#                         "status": "completed",
#                         "time_taken": round(end - start, 2),
#                         "threats_found": len(recon.get("findings", [])),
#                         "risk_level": self._assess_risk(recon),
#                         "summary": summary,
#                         "aggregated": agg
#                     })
#                 return
#
#             # === Exploitation Stage ===
#             if action == "run_exploitation":
#                 res = await self._run_exploitation(targets)
#                 self.db.save_scan_result(res)
#
#                 summary = generate_ai_summary(res.get("exploit_results", {}).values())
#                 output_format = task.get("output_format", "pdf")
#                 filename_base = f"network_exploit_{task_id}"
#                 export_report(summary, "./reports", filename_base, export_format=output_format)
#
#                 end = time.time()
#                 self.bus.publish_event("task_completed", {
#                     "id": task.get("parent_task_id", task_id),
#                     "region": "network",
#                     "status": "completed",
#                     "time_taken": round(end - start, 2),
#                     "threats_found": len(res.get("exploit_results", {})),
#                     "risk_level": self._assess_risk(res),
#                     "summary": summary,
#                     "raw_results": res
#                 })
#                 return
#
#         except asyncio.CancelledError:
#             logger.warning(f"[NETWORK] Task {task_id} cancelled by shutdown.")
#             await self.bus.publish_event("task_terminated", {
#                 "id": task_id,
#                 "region": "network",
#                 "status": "terminated",
#                 "message": "Scan manually stopped."
#             })
#
#         except Exception as e:
#             logger.exception(f"[NETWORK] Task {task_id} failed.")
#             self.bus.publish_event("task_failed", {
#                 "id": task_id,
#                 "region": "network",
#                 "status": "failed",
#                 "message": str(e)
#             })
#
#     async def _run_exploitation(self, targets: List[str]) -> Dict[str, Any]:
#         """Run async exploitation tasks on all targets."""
#         results = {}
#
#         for t in targets:
#             try:
#                 res = await asyncio.wait_for(
#                     self.exploit_mgr.handle_scan_result({"target": [t]}),
#                     timeout=1200
#                 )
#                 results[t] = res
#             except asyncio.TimeoutError:
#                 results[t] = {"error": "Timeout"}
#
#         try:
#             new_global = self.local_learner.local_knowledge([
#                 {"target": t, "vulnerabilities": r, "status": "success"} for t, r in results.items()
#             ])
#         except Exception:
#             logger.exception("Local learner update failed.")
#             new_global = []
#
#         return {"targets": targets, "exploit_results": results, "new_for_global": new_global}
#
#     def _assess_risk(self, results: Dict[str, Any]) -> str:
#         """Simple risk assessment from number of findings."""
#         count = len(results.get("findings") or results.get("exploit_results", {}))
#         if count == 0:
#             return "None"
#         elif count < 3:
#             return "Low"
#         elif count < 6:
#             return "Medium"
#         return "High"
