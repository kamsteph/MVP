
# new_module/managers/network_manager.py
"""
NetworkManager: Phase 1A (mapping & delegation)
- Uses advanced NetworkManagerGNN to make graph-level decisions.
- Loads model weights (optional) and exposes `decide` which returns (action, probs).
"""

from typing import List, Tuple
import torch
import torch.nn.functional as F
from torch_geometric.data import Data
import ipaddress
from collections import defaultdict

from Network_Pentest.network.Brain.gnn_models import NetworkManagerGNN
from back_end.database import DatabaseManager


class NetworkManager:
    def __init__(self, model_path: str = None, device: str = "cpu", subnet_prefix: int = 24):
        self.device = torch.device(device)
        self.model = NetworkManagerGNN(in_channels=11, hidden=64, num_classes=2)
        if model_path:
            self.model.load_state_dict(torch.load(model_path, map_location=self.device))
        self.model.to(self.device)
        self.model.train()
        self.db = DatabaseManager()
        self.subnet_prefix = subnet_prefix

    def _ip_to_subnet(self, ip_str: str):
        try:
            ip = ipaddress.ip_address(ip_str)
            network = ipaddress.ip_network(f"{ip}/{self.subnet_prefix}", strict=False)
            return f"{network.network_address}/{self.subnet_prefix}"
        except Exception:
            return None

    def build_graph(self, scan_results: List[dict]) -> Data:
        # same features as the advanced models expect (11-dim)
        nodes = []
        edges = set()
        subnet_map = defaultdict(list)
        cve_map = defaultdict(list)
        service_map = defaultdict(list)
        ip_index = {}

        for idx, r in enumerate(scan_results):
            ip = r.get("ip", f"node_{idx}")
            ip_index[ip] = idx

        for idx, r in enumerate(scan_results):
            vulns = r.get("vulnerabilities", [])
            services = r.get("services", [])
            num_vulns = len(vulns)
            max_cvss = max([v.get("cvss", 0.0) for v in vulns]) if vulns else 0.0
            has_exploit = 1 if any(v.get("exploit", False) for v in vulns) else 0
            num_services = len(services)
            risk = r.get("risk", "").lower()
            r_high, r_med, r_low = int(risk == "high"), int(risk == "medium"), int(risk == "low")

            nodes.append({
                "num_vulns": num_vulns,
                "max_cvss": max_cvss,
                "has_exploit": has_exploit,
                "num_services": num_services,
                "risk_high": r_high,
                "risk_med": r_med,
                "risk_low": r_low,
                "ip": r.get("ip"),
                "vulns": [v.get("cve") for v in vulns if v.get("cve")],
                "services": [s.get("name") or str(s.get("port")) for s in services],
                "observed_connections": r.get("observed_connections", []),
            })

            ip = r.get("ip")
            if ip:
                sn = self._ip_to_subnet(ip)
                if sn:
                    subnet_map[sn].append(idx)
            for v in nodes[-1]["vulns"]:
                cve_map[v].append(idx)
            for s in nodes[-1]["services"]:
                service_map[s].append(idx)

        def add_edge(edge_a, edge_b):
            if edge_a==edge_b: return
            if edge_a < edge_b: edges.add((edge_a, edge_b))
            else: edges.add((edge_b, edge_a))

        for idxs in subnet_map.values():
            for i in range(len(idxs)):
                for j in range(i+1, len(idxs)):
                    add_edge(idxs[i], idxs[j])
        for idxs in cve_map.values():
            for i in range(len(idxs)):
                for j in range(i+1, len(idxs)):
                    add_edge(idxs[i], idxs[j])
        for idxs in service_map.values():
            for i in range(len(idxs)):
                for j in range(i+1, len(idxs)):
                    add_edge(idxs[i], idxs[j])
        for idx, node in enumerate(nodes):
            for peer in node["observed_connections"]:
                j = ip_index.get(peer)
                if j is not None:
                    add_edge(idx, j)

        # build features (11 dims)
        feats = []
        for n in nodes:
            subnet_deg = 0
            if n["ip"]:
                sn = self._ip_to_subnet(n["ip"])
                if sn:
                    subnet_deg = len(subnet_map.get(sn, [])) - 1
            feats.append([
                float(n["num_vulns"]),
                float(n["max_cvss"]),
                float(n["has_exploit"]),
                float(n["num_services"]),
                float(n["risk_high"]),
                float(n["risk_med"]),
                float(n["risk_low"]),
                float(subnet_deg),
                float(len(n["vulns"])),
                float(len(n["services"])),
                float(len(n["observed_connections"]))
            ])
        import torch
        x = torch.tensor(feats, dtype=torch.float)
        if edges:
            el = []
            for a,b in edges:
                el.append([a,b]); el.append([b,a])
            edge_index = torch.tensor(el, dtype=torch.long).t().contiguous()
        else:
            edge_index = torch.empty((2,0), dtype=torch.long)
        return Data(x=x, edge_index=edge_index)

    def decide(self, scan_results: List[dict]) -> Tuple[str, torch.Tensor]:
        """Return (action: 'delegate'|'deeper_scan', probs tensor)"""
        data = self.build_graph(scan_results=scan_results)
        device=self.device
        data = data.to(device)
        data.batch = torch.zeros(data.num_nodes, dtype=torch.long, device=self.device)

        logits = self.model(data.x, data.edge_index, data.batch)
        probs = F.softmax(logits, dim=1).squeeze(0)
        pred = int(probs.argmax().item())
        action = "delegate" if pred == 0 else "deeper_scan"
        return action, probs.cpu()
