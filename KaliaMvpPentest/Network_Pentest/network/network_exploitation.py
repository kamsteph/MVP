# new_module/network_exploitation.py
"""
NetworkExploitation executor (safe-by-default).

- Prefers Metasploit RPC (pymetasploit3) if configured.
- Falls back to CLI execution.
- WILL NOT execute live exploits unless ALLOW_LIVE_EXPLOITS=1 and either:
    * you pass a safe `execute_fn`, or
    * msf_rpc_config is configured and pymetasploit3 is available.
- Persists structured records via DatabaseManager.save_scan_result().
"""
from typing import Dict, Any, Optional, Callable
import os
import asyncio
import shlex
import traceback
import uuid
from datetime import datetime

try:
    from pymetasploit3.msfrpc import MsfRpcClient  # type: ignore
    HAS_PYMETASPLOIT = True
except Exception:
    MsfRpcClient = None
    HAS_PYMETASPLOIT = False

from back_end.utils.colored_logger import get_logger
from back_end.database import DatabaseManager

logger = get_logger(__name__, component="EXPLOITATION", region="NETWORK")
ALLOW_LIVE = os.getenv("ALLOW_LIVE_EXPLOITS", "0") == "1"
msf_rpc_config_network = {
    "host": os.getenv("MSF_HOST", "10.149.244.106"),
    "port": int(os.getenv("MSF_PORT", "55553")),
    "password": os.getenv("MSF_PASSWORD", "mypassword")
}


class NetworkExploitation:
    def __init__(self,
                 db: DatabaseManager,
                 #msf_rpc_config: Optional[Dict[str, Any]] = None,
                 execute_fn: Optional[Callable[[Dict[str, Any], str, Optional[int]], Dict[str, Any]]] = None):
        self.db = db
        self.msf_rpc_config = msf_rpc_config_network or {}
        self.execute_fn = execute_fn
        self.msf_client = None

        # connect Metasploit RPC when available
        if HAS_PYMETASPLOIT and self.msf_rpc_config:
            try:
                host = self.msf_rpc_config.get("host", "127.0.0.1")
                port = int(self.msf_rpc_config.get("port", 55553))
                password = self.msf_rpc_config.get("password", "msf")
                logger.info("Connecting to msfrpcd at %s:%s", host, port)
                self.msf_client = MsfRpcClient(password, server=host, port=port)
                logger.info("Connected to msfrpcd via pymetasploit3 (NetworkExploitation).")

            except Exception as e:
                logger.warning("Failed to connect to msfrpcd: %s", e)
                self.msf_client = None
        else:
            if not HAS_PYMETASPLOIT:
                logger.debug("pymetasploit3 not installed or import failed.")
            if not self.msf_rpc_config:
                logger.debug("No msf_rpc_config provided.")

        # register available backends
        self.backends = {
            "msf_rpc": self._execute_via_msf_rpc,
            "cli": self._execute_cli,
            "custom": self._execute_custom_tool,
        }

    async def run_exploitation(self,
                               cve_entry: Dict[str, Any],
                               target_ip: str,
                               port: Optional[int] = None,
                               exec_mode: str = "auto",
                               timeout: int = 300) -> Dict[str, Any]:
        run_id = str(uuid.uuid4())
        tool = cve_entry.get("exploit_tool", "unknown")
        cmd_template = cve_entry.get("exploit_command", "")
        try:
            command = cmd_template.format(target_ip=target_ip, port=port or "")
        except Exception:
            command = cmd_template

        result = {
            "run_id": run_id,
            "cve_id": cve_entry.get("id"),
            "target_ip": target_ip,
            "port": port,
            "tool": tool,
            "command": command,
            "started_at": datetime.now().isoformat() + "Z",
            "status": "skipped",
            "output": None,
            "error": None,
        }

        # Safety gate
        if not ALLOW_LIVE:
            logger.warning("Live execution disabled. Skipping execution for %s", result["cve_id"])
            result["status"] = "skipped_live_disabled"

            try:
                self.db.save_scan_result(result)
            except Exception:
                logger.debug("Failed to persist skipped record.")
            return result

        # If execute_fn provided, use it (user-controlled local plugin)
        if self.execute_fn:
            try:
                loop = asyncio.get_running_loop()
                exec_res = await loop.run_in_executor(None, self.execute_fn, cve_entry, target_ip, port)
                result.update(exec_res or {})
                result["status"] = exec_res.get("status", "executed") if exec_res else "executed"
            except Exception as e:
                logger.error("execute_fn raised exception: %s", e)
                result["status"] = "error"
                result["error"] = str(e)
            try:
                self.db.save_scan_result(result)
            except Exception:
                logger.debug("Persist failed")
            return result

            # RPC path (safe): prefer RPC when explicitly requested or when an msf_client exists.
        prefer_rpc = (exec_mode == "rpc") or (exec_mode == "auto" and self.msf_client is not None)
        if prefer_rpc and self.msf_client is not None and cve_entry.get("msf_module"):
            logger.info("Executing via Metasploit RPC for %s", result["cve_id"])

            # Run blocking RPC helper in threadpool â€” but protect against exceptions
            try:
                exec_res = await asyncio.get_running_loop().run_in_executor(
                    None, self._execute_via_msf_rpc, cve_entry, target_ip, port
                )
            except Exception as e:
                # If the helper throws, convert to a normalized rpc_error result rather
                # than letting the exception bubble up and kill the coroutine/test.
                logger.exception("Exception during msf rpc execution for %s: %s", result["cve_id"], e)
                exec_res = {
                    "status": "rpc_error",
                    "output": None,
                    "error": str(e),
                }

            # Merge helper result into final record, persist, and return
            try:
                result.update(exec_res or {})
                # ensure a sane fallback status
                result["status"] = exec_res.get("status", result.get("status", "executed"))
            except Exception as e:
                logger.debug("Merging exec_res failed: %s", e)

            try:
                self.db.save_scan_result(result)
            except Exception:
                logger.debug("Persist failed when saving rpc result")

            return result


        # CLI fallback
        logger.info("CLI fallback execution for %s", result["cve_id"])
        exec_res = await self._execute_cli(command, timeout=timeout)
        result.update(exec_res or {})
        result["status"] = exec_res.get("status", "executed") if exec_res else "executed"
        try:
            self.db.save_scan_result(result)
        except Exception:
            logger.debug("Persist failed")
        return result

    def _execute_via_msf_rpc(self, cve_entry: Dict[str, Any], target_ip: str, port: Optional[int]) -> Dict[str, Any]:
        if not self.msf_client:
            return {"status": "rpc_unavailable", "output": None, "error": "msf client not connected"}
        module_path = cve_entry.get("msf_module")
        options = cve_entry.get("module_options", {})
        try:
            parts = module_path.split("/", 1) if module_path else (None, module_path)
            if parts and len(parts) == 2:
                category = parts[0]
                module_name = parts[1]
                module = self.msf_client.modules.use(category, module_name)
            else:
                module = self.msf_client.modules.use('exploit', module_path)

            # set host and port options if available
            try:
                if 'RHOSTS' in module._opts:
                    module['RHOSTS'] = target_ip
                elif 'RHOST' in module._opts:
                    module['RHOST'] = target_ip
                if port and 'RPORT' in module._opts:
                    module['RPORT'] = port
            except Exception:
                pass

            for k, v in options.items():
                try:
                    module[k] = v
                except Exception:
                    pass

            res = module.execute()
            return {"status": "executed_rpc", "output": str(res), "rpc_result": res}
        except Exception as e:
            tb = traceback.format_exc()
            logger.error("msf rpc error: %s", e)
            return {"status": "rpc_error", "output": None, "error": str(e), "traceback": tb}

    async def _execute_cli(self, cmd: str, timeout: int = 300) -> Dict[str, Any]:
        if not cmd:
            return {"status": "no_command", "output": None, "error": "No command provided"}

        try:
            use_shell = any(sym in cmd for sym in ["|", "&&", ";"])
            if use_shell:
                proc = await asyncio.create_subprocess_shell(cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE)
            else:
                parts = shlex.split(cmd)
                proc = await asyncio.create_subprocess_exec(*parts, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE)

            try:
                stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=timeout)
            except asyncio.TimeoutError:
                proc.kill()
                await proc.wait()
                return {"status": "timeout", "output": None, "error": "Execution timed out"}

            output = stdout.decode(errors="ignore") if stdout else ""
            err = stderr.decode(errors="ignore") if stderr else ""
            status = "executed" if proc.returncode == 0 else "failed"
            return {"status": status, "output": output.strip(), "error": err.strip(), "returncode": proc.returncode}
        except Exception as e:
            logger.error("CLI execution error: %s", e)
            return {"status": "cli_error", "output": None, "error": str(e)}


    async def _execute_custom_tool(self, cve_entry, target_ip, port, timeout=300):
        if not self.execute_fn:
            return {"status": "custom_unavailable"}
        try:
            loop = asyncio.get_event_loop()
            res = await loop.run_in_executor(None, self.execute_fn, cve_entry, target_ip, port)
            return res or {"status": "custom_executed"}
        except Exception as e:
            return {"status": "custom_error", "error": str(e)}
