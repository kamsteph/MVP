# file: Network_Pentest/network/Managers/insider_file_handler.py

import os
import re
from typing import List, Dict, Any, Optional

from back_end.database import DatabaseManager
from back_end.event_bus import EventBus
from back_end.utils.colored_logger import get_logger

logger = get_logger(__name__, component="INSIDER_HANDLER", region="NETWORK")


class InsiderFileHandler:
    """
    Handle 'insider files' for grey/white-box network pentests.

    Responsibilities:
    -----------------
    - Classify uploaded files into:
        * vpn_config       (.ovpn, .conf, .pem/.crt bundle)
        * cred_list        (.txt/.csv simple credential lists)
        * intelligence_doc (.txt/.log/.cfg/.ini for network hints)
        * other
    - Extract:
        * VPN config paths → used later by connectivity layer
        * Credentials      → structured list for AuthManager
        * Network hints    → subnets, IPs, hostnames (for scoping)
    - Persist metadata + extracted info into MongoDB.
    - Provide a 'hints' dict suitable to pass into NetworkPipeline.run(...).
    - Optionally emit an EventBus task to set up internal access from VPN configs.
    """

    def __init__(
            self,
            db: DatabaseManager,
            bus: EventBus,
            enable_vpn_bus: bool = True,
    ):
        self.db = db
        self.bus = bus
        self.enable_vpn_bus = enable_vpn_bus
        # prefer a dedicated collection if available
        try:
            self.coll = self.db.insiderFiles
        except Exception:
            print("Could not find the insider collection")

    # ------------------------------------------------------------------
    # Public entrypoint
    # ------------------------------------------------------------------
    def process_insider_files(
            self,
            task_id: str,
            scope: str,
            files: List[Dict[str, Any]],
    ) -> Dict[str, Any]:
        """
        Process insider files for a given pentest task.

        Parameters
        ----------
        task_id : str
            Pentest task identifier.
        scope : str
            Pentest scope string ("grey", "white", ...).
        files : List[Dict[str, Any]]
            Backend-level representation of uploaded files.
            Expected minimal fields per element:
                {
                    "filename": "corp.ovpn",
                    "path": "/var/tmp/uploaded/corp.ovpn",
                    "mime": "application/x-openvpn" (optional),
                    "size": 12345 (optional),
                    "meta": {...} (optional extra UI info)
                }

        Returns
        -------
        hints : Dict[str, Any]
            Structured hints to inject into your NetworkPipeline:
            {
                "insider": {
                    "vpn_configs": [...],
                    "credentials": [...],
                    "network_hints": {
                        "subnets": [...],
                        "ips": [...],
                        "hostnames": [...],
                    },
                    "raw_files": [...],
                }
            }
        """
        if scope not in ("grey", "white"):
            logger.info(
                f"[InsiderFileHandler] Scope={scope} – usually no insider files used here."
            )

        vpn_configs = []
        cred_records = []
        network_hints = {
            "subnets": set(),
            "ips": set(),
            "hostnames": set(),
        }

        raw_file_entries = []

        for f in files or []:
            f_type = self._classify_file(f)
            path = f.get("path")
            filename = f.get("filename") or os.path.basename(path or "")

            raw_file_entries.append(
                {
                    "filename": filename,
                    "path": path,
                    "type": f_type,
                    "size": f.get("size"),
                }
            )

            if not path or not os.path.exists(path):
                logger.warning(
                    f"[InsiderFileHandler] File path missing or not found: {path}"
                )
                continue

            if f_type == "vpn_config":
                vpn_configs.append(path)

            elif f_type == "cred_list":
                parsed_creds = self._parse_credential_file(path)
                cred_records.extend(parsed_creds)

            elif f_type == "intelligence_doc":
                hints = self._extract_network_hints_from_text_file(path)
                network_hints["subnets"].update(hints["subnets"])
                network_hints["ips"].update(hints["ips"])
                network_hints["hostnames"].update(hints["hostnames"])

            else:
                # ignore "other" except for metadata
                continue

        # Convert sets back to sorted lists
        network_hints = {
            "subnets": sorted(network_hints["subnets"]),
            "ips": sorted(network_hints["ips"]),
            "hostnames": sorted(network_hints["hostnames"]),
        }

        hints_out = {
            "insider": {
                "vpn_configs": vpn_configs,
                "credentials": cred_records,
                "network_hints": network_hints,
                "raw_files": raw_file_entries,
            }
        }

        # Persist to DB for audit
        self._save_insider_bundle(task_id, scope, hints_out)

        # Optionally kick off internal access setup from VPN configs
        if self.enable_vpn_bus and vpn_configs:
            self._emit_internal_access_task(task_id, vpn_configs)

        logger.info(
            f"[InsiderFileHandler] Processed insider files for task {task_id}: "
            f"vpn={len(vpn_configs)}, creds={len(cred_records)}, "
            f"subnets={len(network_hints['subnets'])}, ips={len(network_hints['ips'])}"
        )

        return hints_out

    # ------------------------------------------------------------------
    # Classification
    # ------------------------------------------------------------------
    def _classify_file(self, f: Dict[str, Any]) -> str:
        """Return one of: vpn_config | cred_list | intelligence_doc | other"""
        filename = (f.get("filename") or "").lower()
        mime = (f.get("mime") or "").lower()
        ext = os.path.splitext(filename)[1]

        # VPN configs / keys
        if ext in (".ovpn", ".conf") or "openvpn" in mime:
            return "vpn_config"
        if ext in (".pem", ".crt", ".key") and "vpn" in filename:
            return "vpn_config"

        # Credentials
        if ext in (".txt", ".csv", ".tsv"):
            # we will treat as cred_list if it *looks* like it
            # (parsing will discard lines that don't match)
            return "cred_list"

        # Intelligence docs (simple text-based for now)
        if ext in (".log", ".cfg", ".conf", ".ini"):
            return "intelligence_doc"

        # Binary docs like pdf/docx could be added later (LLM/OCR path)
        # For now, treat them as "other" to avoid messing with them.
        return "other"

    # ------------------------------------------------------------------
    # Credential parsing
    # ------------------------------------------------------------------
    def _parse_credential_file(self, path: str) -> List[Dict[str, Any]]:
        """
        Very simple credential parser.

        Recognized formats per non-empty, non-comment line:
          - user:pass
          - user|pass
          - user;pass
          - user pass
        Everything else is stored as raw_line without parsing.
        """
        creds = []
        try:
            with open(path, "r", encoding="utf-8", errors="ignore") as fh:
                for line in fh:
                    line = line.strip()
                    if not line or line.startswith("#") or line.startswith("//"):
                        continue

                    # Try common separators
                    for sep in (":", "|", ";"):
                        if sep in line:
                            parts = [p.strip() for p in line.split(sep, 1)]
                            if len(parts) == 2 and parts[0] and parts[1]:
                                creds.append(
                                    {
                                        "username": parts[0],
                                        "password": parts[1],
                                        "raw_line": None,
                                        "source_file": path,
                                    }
                                )
                                break
                    else:
                        # fallback: whitespace-separated
                        parts = line.split()
                        if len(parts) == 2:
                            creds.append(
                                {
                                    "username": parts[0],
                                    "password": parts[1],
                                    "raw_line": None,
                                    "source_file": path,
                                }
                            )
                        else:
                            # store as raw line (could be token, API key, etc.)
                            creds.append(
                                {
                                    "username": None,
                                    "password": None,
                                    "raw_line": line,
                                    "source_file": path,
                                }
                            )
        except Exception as e:
            logger.error(f"[InsiderFileHandler] Failed to parse creds from {path}: {e}")

        # IMPORTANT: do *not* log actual passwords
        logger.info(
            f"[InsiderFileHandler] Parsed {len(creds)} credential entries from {path}"
        )
        return creds

    # ------------------------------------------------------------------
    # Network hints extraction (from simple text-like files)
    # ------------------------------------------------------------------
    def _extract_network_hints_from_text_file(self, path: str) -> Dict[str, set]:
        """
        Regex-based extraction of:
          - IPv4 addresses
          - CIDR subnets
          - host-like tokens (something.something)
        """
        text = ""
        try:
            with open(path, "r", encoding="utf-8", errors="ignore") as fh:
                text = fh.read()
        except Exception as e:
            logger.error(
                f"[InsiderFileHandler] Failed to read intelligence doc {path}: {e}"
            )
            return {"subnets": set(), "ips": set(), "hostnames": set()}

        # IPv4 + CIDR
        cidr_pattern = r"\b(?:\d{1,3}\.){3}\d{1,3}/\d{1,2}\b"
        ip_pattern = r"\b(?:\d{1,3}\.){3}\d{1,3}\b"
        host_pattern = r"\b[a-zA-Z0-9_\-]+(?:\.[a-zA-Z0-9_\-]+)+\b"

        subnets = set(re.findall(cidr_pattern, text))
        ips = set(re.findall(ip_pattern, text))
        hostnames = set(re.findall(host_pattern, text))

        return {"subnets": subnets, "ips": ips, "hostnames": hostnames}

    # ------------------------------------------------------------------
    # Persistence & bus integration
    # ------------------------------------------------------------------
    def _save_insider_bundle(
            self,
            task_id: str,
            scope: str,
            hints: Dict[str, Any],
    ):
        """Persist all insider-derived info for later audit / replay."""
        try:
            doc = {
                "type": "insider_bundle",
                "task_id": task_id,
                "scope": scope,
                "hints": hints,
            }
            self.coll.insert_one(doc)
        except Exception as e:
            logger.error(
                f"[InsiderFileHandler] Failed to persist insider bundle: {e}"
            )

    def _emit_internal_access_task(self, task_id: str, vpn_configs: List[str]):
        """
        Notify some 'connectivity manager' / 'env manager' that VPN configs
        are available and should be used to establish an internal vantage point.

        Another component (not this class) will:
          - spawn an isolated container/VM
          - run the VPN client with one of the configs
          - expose a network interface for ReconManager to use.

        Here we just publish an event; no actual VPN dialing is done here.
        """
        payload = {
            "id": task_id,
            "region": "network",
            "action": "setup_internal_access",
            "vpn_configs": vpn_configs,
        }
        logger.info(
            f"[InsiderFileHandler] Emitting setup_internal_access for task {task_id} "
            f"with {len(vpn_configs)} VPN configs."
        )
        try:
            self.bus.publish_task(payload)
        except Exception as e:
            logger.error(
                f"[InsiderFileHandler] Failed to publish setup_internal_access task: {e}"
            )
