# new_module/exploitation_manager_ai.py
import asyncio
import logging
from typing import Dict
from back_end.database import DatabaseManager
from back_end.event_bus import EventBus
from Network_Pentest.network.network_exploitation import NetworkExploitation
from Network_Pentest.network.exploitation_agent_network import ExploitationAgent
from Network_Pentest.network.Sub_Unit_Manager_Network.GNN_Features.exploit_gnn import ExploitBrain

logger = logging.getLogger("ExploitationManagerAI")

class ExploitationManagerAI:
    def __init__(self, db: DatabaseManager, bus: EventBus, gnn_model_path=None):
        self.db = db
        self.bus = bus
        self.brain = ExploitBrain(model_path=gnn_model_path)
        self.executor = NetworkExploitation(db)
        self.agent = ExploitationAgent(db)
        self._sem = asyncio.Semaphore(4)

    async def handle_scan_result(self, scan_result: Dict):
        target_ip = scan_result.get("ip") or scan_result.get("target", [None])[0]
        if not target_ip:
            return []

        # Get vuln IDs from scan
        vuln_ids = scan_result.get("vulnerabilities", [])
        open_ports = scan_result.get("open_ports", [])

        # Fetch candidate details from DB
        db_candidates = list(self.db.adb_collection.find({"id": {"$in": vuln_ids}}))

        # Normalize into dicts for the GNN
        candidates = []
        for c in db_candidates:
            candidates.append({
                "id": c.get("id"),
                "severity": c.get("severity", 0),
                "port": c.get("port") or (open_ports[0] if open_ports else 0),
                "service": c.get("service", ""),
                "previous_success": c.get("previous_success", False),
                "exploit_age": c.get("exploit_age", 0),
                "affected_ports": c.get("affected_ports", []),
                "exploit_tool": c.get("exploit_tool", "sim"),
            })

        if not candidates:
            self.bus.publish_event("exploitation_completed", {"target": target_ip, "results": []})
            return []

        memory = self.db.get_memory_state(target_ip) or {}
        ranked = self.brain.rank_candidates(candidates, memory_features=[memory.get("feature", 0)])

        results = []
        for cand in ranked:
            async with self._sem:
                res = await self.executor.run_exploitation(cand, target_ip)
            results.append(res)

        self.db.save_memory_state({"target_ip": target_ip, "last_exploit_results": results})
        self.bus.publish_event("exploitation_completed", {"target": target_ip, "results": results})
        return results

