import asyncio
import logging
from typing import List, Optional, Dict, Any
from Network_Pentest.network.vuln_scan_api_wrappers import NaabuAPI, NmapAPI, MasscanAPI
from back_end.database import DatabaseManager
from Network_Pentest.network.Sub_Unit_Manager_Network.GNN_Features.vuln_scan_gnn import VulnScanBrain
from back_end.event_bus import EventBus
from back_end.network_cap_matrix import NETWORK_CAPABILITY_MATRIX

logger = logging.getLogger("VulnScanManager")


class VulnScanManager:
    def __init__(self, db: DatabaseManager, bus: EventBus, gnn_model_path: Optional[str] = None, max_concurrency: int = 20):
        self.db = db
        self.bus = bus
        self.brain = VulnScanBrain(model_path=gnn_model_path)
        self.tools = {
            "naabu": NaabuAPI(),
            "nmap": NmapAPI(),
            "masscan": MasscanAPI()
        }
        self.global_semaphore = asyncio.Semaphore(max_concurrency)
        # per-target concurrency semaphore to limit simultaneous tool calls per target if needed
        self.per_target_semaphore = asyncio.Semaphore(4)
        # timeouts (tune to environment)
        self.discovery_timeout = 25.0
        self.nmap_timeout = 60.0

    async def scan_target(
            self,
            target_ip: str,
            hints: Optional[Dict[str, Any]] = None,
            tool_order: Optional[List[str]] = None,
            top_ports: Optional[int] = None,
            custom_ports: Optional[List[int]] = None,
    ):
        hints = hints or {}
        attack_surfaces = hints.get("attack_surface", [])
        tool_hints = hints.get("tools", {})

        scan_results = {"ip": target_ip, "open_ports": [], "services": [], "vulns": []}
        memory = self.db.get_memory_state(target_ip) or {}

        for surface in attack_surfaces:
            surface_name = surface.get("surface")
            matrix_entry = next((m for m in NETWORK_CAPABILITY_MATRIX if m["attack_surface"] == surface_name), None)
            if not matrix_entry:
                logging.warning(f"No capability matrix entry for {surface_name}, skipping.")
                continue

            # Decide ports
            port_mode = matrix_entry.get("default_ports", "top10")
            ports_to_scan = custom_ports or surface.get("custom_ports")
            top_ports_to_scan = top_ports or (10 if port_mode == "top10" else 0)

            # Decide tools
            tools_for_surface = surface.get("tools") or matrix_entry.get("tools") or ["Nmap"]

            # Prioritize port scanners
            priority = {"Naabu": 1, "Masscan": 1, "Nmap": 2}
            tools_for_surface = sorted(set(tools_for_surface), key=lambda t: priority.get(t, 99))
            if tool_order:
                tools_for_surface = tool_order

            # Run tools
            for tool_name in tools_for_surface:
                tool = self.tools.get(tool_name.lower())
                if not tool:
                    logging.warning(f"Tool {tool_name} not found, skipping.")
                    continue
                try:
                    if tool_name in ["Naabu", "Masscan"]:
                        if ports_to_scan:
                            res = await tool.scan(target_ip, ports=ports_to_scan)
                        else:
                            res = await tool.scan(target_ip, top_ports=top_ports_to_scan)
                        scan_results["open_ports"] = list(set(scan_results["open_ports"] + res))
                    else:
                        res = await tool.scan(target_ip, scan_results.get("open_ports", []))
                        scan_results["services"] += res.get("services", [])
                        scan_results["vulns"] += res.get("vulns", [])
                except Exception as e:
                    logging.warning(f"Tool {tool_name} failed on {target_ip}: {e}")

        self.db.save_memory_state({"target_ip": target_ip, "last_scan": scan_results})
        self.bus.publish_task({
            "region": "deception",
            "action": "deploy_honeynet",
            "target_ip": target_ip,
            "vuln_files": scan_results["vulns"],
        })
        return scan_results
