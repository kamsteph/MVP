# file: Network_Pentest/network/Managers/network_pipeline.py

from typing import Dict, Any, List

from Network_Pentest.network.Managers.NetworkM.NetworkM_LLM import NetworkManagerLLM
from Network_Pentest.network.Managers.network_recon_manager import ReconManager
from Network_Pentest.network.Managers.network_vuln_manager import VulnerabilityAIAgent
from back_end.database import DatabaseManager
from back_end.event_bus import EventBus
from back_end.utils.colored_logger import get_logger

logger = get_logger(__name__, component="NETWORK_PIPELINE", region="NETWORK")


class NetworkPipeline:
    """
    RECON → VAI → NetworkManagerLLM
    """

    def __init__(self, bus: EventBus, db: DatabaseManager,
                 recon_mgr: ReconManager,
                 vai: VulnerabilityAIAgent,
                 net_mgr_llm: NetworkManagerLLM):
        self.on_vuln_scan_done= self.on_vuln_scan_done
        self.bus = bus
        self.db = db
        self.recon_mgr = recon_mgr
        self.vai = vai
        self.net_mgr_llm = net_mgr_llm

        # event subscriptions
        self.bus.subscribe("network_recon_done", self.on_recon_done)
        self.bus.subscribe("network_vuln_scan_done", self.on_vuln_scan_done)

    # ------------------------------------------------------------
    # START → publish recon task
    # ------------------------------------------------------------
    async def run(self, targets, task_id: str, hints: dict):
        hints = hints or {}
        logger.info(f"[Pipeline] Starting pipeline for task {task_id}")

        self.bus.publish_task({
            "id": task_id,
            "action": "network_recon_scan",
            "targets": targets,
            "hints": hints
        })

    # ------------------------------------------------------------
    # RECON COMPLETE
    # ------------------------------------------------------------
    def on_recon_done(self, message: Dict[str, Any]):
        task_id = message["id"]
        recon_results = message["results"]
        hints = message.get("hints", {})

        logger.info(f"[Pipeline] Recon done → {len(recon_results)} hosts")

        alive_hosts = [r["ip"] for r in recon_results if r.get("alive")]

        self.bus.publish_task({
            "id": task_id,
            "action": "network_vuln_scan",
            "targets": alive_hosts,
            "recon_results": recon_results,
            "hints": hints
        })

    # ------------------------------------------------------------
    # VULN SCAN COMPLETE → VAI + NetworkM LLM
    # ------------------------------------------------------------
    def on_vuln_scan_done(self, message: Dict[str, Any]):
        task_id = message["id"]
        vuln_results = message["results"]
        recon_results = message["recon_results"]
        hints = message.get("hints", {})

        logger.info(f"[Pipeline] Vuln scan complete ({len(vuln_results)} entries).")

        # ---- Merge data into host_records ----
        host_records = self._merge_recon_vuln(recon_results, vuln_results)

        # ---- VAI: classify into levels ----
        level_summary = self.vai.classify_hosts_for_levels(host_records)
        hints["level_summary"] = level_summary
        hints["host_records"] = host_records

        # ---- Ask NetworkManagerLLM to decide next step ----
        meta = self.net_mgr_llm.run_decide_and_plan(
            task_id=task_id,
            scan_results=host_records,
            hints=hints,
            force_llm=True
        )
        return meta

    # ------------------------------------------------------------
    # MERGE RECON + VULN
    # ------------------------------------------------------------
    def _merge_recon_vuln(self, recon: List[Dict[str, Any]],
                          vuln: List[Dict[str, Any]]):
        ip_map = {r["ip"]: r for r in recon}
        for entry in vuln:
            ip = entry.get("ip")
            if ip in ip_map:
                ip_map[ip].setdefault("vuln_details", []).append(entry)
        return list(ip_map.values())
