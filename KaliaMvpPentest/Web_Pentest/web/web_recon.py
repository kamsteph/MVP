# regions/web/web_recon.py
import json
from typing import List
import os
import subprocess
import uuid
import logging
from dotenv import load_dotenv

from back_end.utils.colored_logger import get_logger
from pydantic_models.web_Models import VulnerabilityEntry
from Web_Pentest.web.web_osint import gather_main_osint_info, gather_social_osint_info
from Web_Pentest.web.web_scrapping import discover_social_links, scrape_bio

load_dotenv()

logger = get_logger(__name__,component="RECON",region="WEB")
logger.setLevel(logging.DEBUG)

NUCLEI_PATH = os.getenv("NUCLEI_PATH")
SUBFINDER_PATH = os.getenv("SUBFINDER_PATH")
AMASS_PATH = os.getenv("AMASS_PATH")


class Recon:
    def __init__(self, nuclei_path: str = NUCLEI_PATH,
                 subfinder_path: str = SUBFINDER_PATH,
                 amass_path: str = AMASS_PATH):
        self.nuclei_path = nuclei_path
        self.subfinder_path = subfinder_path
        self.amass_path = amass_path
        logger.info("Recon initialized (nuclei=%s, subfinder=%s, amass=%s)",
                    self.nuclei_path, self.subfinder_path, self.amass_path)

    def run_nuclei_scan(self, targets: List[str]) -> List[VulnerabilityEntry]:
        """
        Run nuclei against list of targets and enrich with OSINT (headers, DNS, Shodan, socials, whois, bios).
        """
        if not os.path.exists(self.nuclei_path):
            logger.error("Nuclei binary not found at path: %s", self.nuclei_path)
            raise FileNotFoundError(f"Nuclei not found at path: {self.nuclei_path}")

        vulns = []
        for target in targets:
            output_file = f"nuclei_{uuid.uuid4().hex}.json"
            cmd = [self.nuclei_path, "-u", target, "-json", "-silent", "-o", output_file]
            logger.info("Running nuclei scan on target=%s -> output=%s", target, output_file)

            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode != 0:
                logger.error("Nuclei scan failed for %s: %s", target, result.stderr)
                raise RuntimeError(f"Nuclei error: {result.stderr}")

            logger.debug("Nuclei scan finished for %s, parsing results...", target)
            with open(output_file, "r", encoding="utf-8") as f:
                lines = [json.loads(line) for line in f if line.strip()]

            for item in lines:
                logger.debug("Processing nuclei finding: %s", item.get("templateID", "unknown"))

                # --- Enrich with OSINT ---
                osint_data = gather_main_osint_info(target)

                # WHOIS lookup (if included in OSINT)
                try:
                    whois_data = osint_data.get("whois", {})
                except Exception as e:
                    logger.warning("WHOIS enrichment failed for %s: %s", target, e)
                    whois_data = {"error": str(e)}

                # Discover social links + scrape bios
                discovered_socials = discover_social_links(target)
                bios, social_data = {}, {}
                if discovered_socials:
                    logger.info("Discovered social links for %s: %s", target, discovered_socials)
                    try:
                        social_data = gather_social_osint_info(discovered_socials)
                        bios = {s_url: scrape_bio(s_url) for s_url in discovered_socials}
                    except Exception as e:
                        logger.warning("Social OSINT enrichment failed for %s: %s", target, e)
                        social_data = {"error": str(e)}

                # Construct enriched vuln entry
                vuln_entry = VulnerabilityEntry(
                    alert=item.get("templateID", "N/A"),
                    risk=item.get("severity", "Info").capitalize(),
                    confidence="High",
                    url=item.get("host", target),
                    method="GET",
                    description=item.get("info", {}).get("description", ""),
                    solution="Check references or fix per template.",
                    data=item,
                    social_url=discovered_socials,
                    bio=bios,
                    whois=whois_data,
                    social_links=discovered_socials,
                    osint={
                        "main": osint_data,
                        "social": social_data
                    }
                )
                logger.debug("Created VulnerabilityEntry for %s", vuln_entry.url)
                vulns.append(vuln_entry)

        logger.info("Nuclei scan completed. Total findings: %d", len(vulns))
        return vulns

    def enumerate_subdomains(self, target: str) -> List[str]:
        logger.info("Enumerating subdomains for target: %s", target)
        subdomains = []

        # --- Try Subfinder first ---
        if self.subfinder_path and os.path.exists(self.subfinder_path):
            cmd = [self.subfinder_path, "-silent", "-d", target]
            logger.debug("Running Subfinder command: %s", cmd)
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode == 0:
                subdomains.extend(result.stdout.splitlines())
                logger.info("Subfinder found %d subdomains for %s", len(subdomains), target)

        # --- Then try Amass ---
        elif self.amass_path and os.path.exists(self.amass_path):
            cmd = [self.amass_path, "enum", "-passive", "-d", target]
            logger.debug("Running Amass command: %s", cmd)
            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode == 0:
                subdomains.extend(result.stdout.splitlines())
                logger.info("Amass found %d subdomains for %s", len(subdomains), target)

        # --- Fallback ---
        if not subdomains:
            logger.warning("No subdomains found for %s, falling back to root domain", target)
            subdomains = [target]

        unique_subdomains = list(set(subdomains))
        logger.debug("Final subdomain list for %s: %s", target, unique_subdomains)
        return unique_subdomains

    def full_recon(self, root_domain: str) -> List[VulnerabilityEntry]:
        """
        Pipeline: enumerate subdomains -> nuclei scan -> enrich with OSINT
        """
        logger.info("Starting full recon for root domain: %s", root_domain)
        targets = self.enumerate_subdomains(root_domain)
        logger.info("Recon pipeline discovered %d targets for %s", len(targets), root_domain)
        vulns = self.run_nuclei_scan(targets)
        logger.info("Full recon completed for %s. Total vulnerabilities: %d",
                    root_domain, len(vulns))
        return vulns
