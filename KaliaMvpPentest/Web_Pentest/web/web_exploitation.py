# new_module/web_exploitation.py
"""
WebExploitation executor (safe-by-default).

- Prefers Metasploit RPC (pymetasploit3) if configured.
- Falls back to CLI execution.
- WILL NOT execute live exploits unless ALLOW_LIVE_EXPLOITS=1.
- Persists structured records via DatabaseManager.save_scan_result().
"""

import os
import asyncio
import shlex
import traceback
import uuid
from datetime import datetime
from typing import Dict, Any, Optional

try:
    from pymetasploit3.msfrpc import MsfRpcClient
    HAS_PYMETASPLOIT = True
except Exception:
    MsfRpcClient = None
    HAS_PYMETASPLOIT = False

from back_end.utils.colored_logger import get_logger
from back_end.database import DatabaseManager

logger = get_logger(__name__, component="EXPLOITATION", region="WEB")
ALLOW_LIVE = os.getenv("ALLOW_LIVE_EXPLOITS", "0") == "1"


class WebExploitation:
    def __init__(self, db: DatabaseManager, msf_rpc_config: Optional[Dict[str, Any]] = None):
        self.db = db
        self.msf_rpc_config = msf_rpc_config or {}
        self.msf_client = None

        if HAS_PYMETASPLOIT and self.msf_rpc_config:
            try:
                host = self.msf_rpc_config.get("host", "127.0.0.1")
                port = int(self.msf_rpc_config.get("port", 55553))
                password = self.msf_rpc_config.get("password", "msf")
                logger.info("Connecting to msfrpcd at %s:%s", host, port)
                self.msf_client = MsfRpcClient(password, server=host, port=port)
                logger.info("Connected to msfrpcd via pymetasploit3 (WebExploitation).")
            except Exception as e:
                logger.warning("Failed to connect to msfrpcd: %s", e)
                self.msf_client = None
        else:
            if not HAS_PYMETASPLOIT:
                logger.debug("pymetasploit3 not installed or import failed.")
            if not self.msf_rpc_config:
                logger.debug("No msf_rpc_config provided.")

    async def run_exploitation(self, vuln_entry: Dict[str, Any], target_url: str, timeout: int = 300) -> Dict[str, Any]:
        run_id = str(uuid.uuid4())
        tool = vuln_entry.get("exploit_tool", "unknown")
        cmd_template = vuln_entry.get("exploit_command", "")

        try:
            command = cmd_template.format(target_url=target_url)
        except Exception:
            command = cmd_template

        result = {
            "run_id": run_id,
            "cve_id": vuln_entry.get("id"),
            "target_url": target_url,
            "tool": tool,
            "command": command,
            "started_at": datetime.now().isoformat() + "Z",
            "status": "skipped",
            "output": None,
            "error": None,
        }

        # Safety gate
        if not ALLOW_LIVE:
            logger.warning("Live execution disabled. Skipping execution for %s", result["cve_id"])
            result["status"] = "skipped_live_disabled"
            try:
                self.db.save_scan_result(result)
            except Exception:
                logger.debug("Failed to persist skipped record.")
            return result

            # RPC path (safe: catch exceptions from remote RPC helper)
        if self.msf_client and vuln_entry.get("msf_module"):
            logger.info("Executing via Metasploit RPC for %s", result["cve_id"])
            try:
                exec_res = await asyncio.get_running_loop().run_in_executor(
                    None, self._execute_via_msf_rpc, vuln_entry, target_url
                )
            except Exception as e:
                # Convert exception -> rpc_error result and persist
                logger.exception("Exception during msf rpc execution: %s", e)
                exec_res = {
                    "status": "rpc_error",
                    "output": None,
                    "error": str(e),
                }

            # merge, persist, return (same behavior whether exec_res came from RPC or was synthesized)
            result.update(exec_res or {})
            result["status"] = exec_res.get("status", result.get("status", "executed"))
            try:
                self.db.save_scan_result(result)
            except Exception:
                logger.debug("Persist failed")
            return result

        # CLI fallback
        logger.info("CLI fallback execution for %s", result["cve_id"])
        exec_res = await self._execute_cli(command, timeout=timeout)
        result.update(exec_res or {})
        result["status"] = exec_res.get("status", "executed") if exec_res else "executed"
        try:
            self.db.save_scan_result(result)
        except Exception:
            logger.debug("Persist failed")
        return result

    def _execute_via_msf_rpc(self, vuln_entry: Dict[str, Any], target_url: str) -> Dict[str, Any]:
        if not self.msf_client:
            return {"status": "rpc_unavailable", "output": None, "error": "msf client not connected"}
        module_path = vuln_entry.get("msf_module")
        options = vuln_entry.get("module_options", {})
        try:
            parts = module_path.split("/", 1) if module_path else (None, module_path)
            if parts and len(parts) == 2:
                category = parts[0]
                module_name = parts[1]
                module = self.msf_client.modules.use(category, module_name)
            else:
                module = self.msf_client.modules.use('exploit', module_path)

            if 'RHOSTS' in module._opts:
                module['RHOSTS'] = target_url
            elif 'RHOST' in module._opts:
                module['RHOST'] = target_url

            for k, v in options.items():
                try:
                    module[k] = v
                except Exception:
                    pass

            res = module.execute()
            return {"status": "executed_rpc", "output": str(res), "rpc_result": res}
        except Exception as e:
            tb = traceback.format_exc()
            logger.error("msf rpc error: %s", e)
            return {"status": "rpc_error", "output": None, "error": str(e), "traceback": tb}

    async def _execute_cli(self, cmd: str, timeout: int = 300) -> Dict[str, Any]:
        if not cmd:
            return {"status": "no_command", "output": None, "error": "No command provided"}

        try:
            use_shell = any(sym in cmd for sym in ["|", "&&", ";"])
            if use_shell:
                proc = await asyncio.create_subprocess_shell(cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE)
            else:
                parts = shlex.split(cmd)
                proc = await asyncio.create_subprocess_exec(*parts, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE)

            try:
                stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=timeout)
            except asyncio.TimeoutError:
                proc.kill()
                await proc.wait()
                return {"status": "timeout", "output": None, "error": "Execution timed out"}

            output = stdout.decode(errors="ignore") if stdout else ""
            err = stderr.decode(errors="ignore") if stderr else ""
            status = "executed" if proc.returncode == 0 else "failed"
            return {"status": status, "output": output.strip(), "error": err.strip(), "returncode": proc.returncode}
        except Exception as e:
            logger.error("CLI execution error: %s", e)
            return {"status": "cli_error", "output": None, "error": str(e)}
