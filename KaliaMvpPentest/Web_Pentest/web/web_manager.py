# new_module/web_manager_async.py
import logging
from typing import Dict, Any, List
import asyncio

from G_L_L.l_region.local_learner import LocalLearner
from Web_Pentest.web.web_vuln_scan import VulnScan
from back_end.database import DatabaseManager
from back_end.event_bus import EventBus
from back_end.utils.colored_logger import get_logger
from back_end.GraphNN import GNNBrain  # shared GCN brain

# Sub-unit managers
from Web_Pentest.web.Sub_Unit_Manager.web_recon_manager import WebReconManager
from Web_Pentest.web.Sub_Unit_Manager.web_vuln_manager import WebVulnManager
from Web_Pentest.web.Sub_Unit_Manager.web_exploitation_manager import WebExploitationManager
from Web_Pentest.web.web_recon import Recon
from Web_Pentest.web.web_exploitation import WebExploitation

logger = get_logger(__name__, component="MANAGER", region="WEB")
logger.setLevel(logging.INFO)


class WebManager:
    """
    Fully async high-level AI Agent for Web Pentesting.
    Integrates local learner for exploitation feedback.
    """

    def __init__(
            self,
            bus: EventBus,
            recon_engine: Recon,
            exploitation_engine: WebExploitation,
            vuln_scanner: VulnScan,
            local_learner: LocalLearner,
            db: DatabaseManager,
            gnn_model_path: str = None,
        ):
        self.bus = bus
        self.db = db
        self.local_learner = local_learner

        # Shared GCN brain for decision making
        self.gnn_brain = GNNBrain(model_path=gnn_model_path)

        # Autonomous sub-unit managers with injected engines
        self.recon_mgr = WebReconManager(bus, db, recon_engine)
        self.vuln_mgr = WebVulnManager(bus, db, vuln_scanner)
        self.exploit_mgr = WebExploitationManager(db, exploitation_engine, concurrency=4)

        logger.info("[WebManager] Initialized as an async AI Agent with injected engines.")

        # Subscribe to web region tasks
        self.bus.subscribe("web", self._async_task_wrapper)

    def _async_task_wrapper(self, task: Dict[str, Any]):
        """Wrap async handler for synchronous EventBus subscriptions."""
        asyncio.create_task(self.handle_task(task))

    async def handle_task(self, task: Dict[str, Any]):
        """Main async handler for web tasks."""
        logger.info(f"[WebManager] Received task: {task}")
        action = task.get("action", "initial_web_scan")
        targets = task.get("targets", [])

        if not targets:
            logger.warning("[WebManager] No targets specified. Skipping task.")
            return

        if action == "initial_web_scan":
            self.bus.publish_task({
                "region": "web",
                "action": "web_recon_scan",
                "targets": targets
            })

        elif action == "post_recon_decision":
            recon_results = task.get("scan_results", [])
            if not recon_results:
                logger.warning("[WebManager] No recon results provided. Skipping.")
                return

            # Save to DB
            for r in recon_results:
                self.db.save_scan_result(r.model_dump())

            # Decide next action using GCN
            next_action = self.gnn_brain.predict(recon_results)

            if next_action == "vulnerability_scan":
                self.bus.publish_task({
                    "region": "web",
                    "action": "web_vuln_scan",
                    "targets": targets,
                    "recon_results": recon_results
                })
            elif next_action == "exploitation":
                self.bus.publish_task({
                    "region": "web",
                    "action": "run_exploitation",
                    "targets": targets
                })

        elif action == "post_vuln_decision":
            vuln_results = task.get("vuln_results", [])
            if not vuln_results:
                logger.warning("[WebManager] No vulnerability results provided. Skipping.")
                return

            for v in vuln_results:
                self.db.save_scan_result(v.model_dump())

            next_action = self.gnn_brain.predict(vuln_results)
            if next_action == "exploitation":
                self.bus.publish_task({
                    "region": "web",
                    "action": "run_exploitation",
                    "targets": targets,
                    "vulnerabilities": [v.model_dump() for v in vuln_results]
                })

        elif action == "run_exploitation":
            # Await async exploitation
            exploit_results = await self._run_exploitation(targets, task.get("vulnerabilities", []))

            # Save results to DB
            self.db.save_scan_result(exploit_results)

            # Push only new/unrecognized events to global learning
            if "new_for_global" in exploit_results:
                self.bus.publish_task({
                    "region": "learning",
                    "source_region": "web",
                    "results_ids": [str(r.get("_id", "unknown")) for r in exploit_results["new_for_global"]]
                })

    async def _run_exploitation(self, targets: List[str], vulnerabilities: List[Dict[str, Any]] = []) -> Dict[str, Any]:
        """Async delegation to WebExploitationManager + local learner."""
        all_results = {}

        for target in targets:
            exploit_res = await self.exploit_mgr.run(target, vulnerabilities)
            all_results[target] = exploit_res

        # Feed results to local learner (sync)
        new_for_global = self.local_learner.learn_from_exploitation([
            {
                "target": t,
                "vulnerabilities": r,
                "status": "success"  # adjust fields according to your model
            } for t, r in all_results.items()
        ])

        return {"targets": targets, "exploit_results": all_results, "new_for_global": new_for_global}
