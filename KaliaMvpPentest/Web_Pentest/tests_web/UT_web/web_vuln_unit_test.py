import pytest
from unittest.mock import MagicMock, patch
import Web_Pentest.web.web_vuln_scan as web_vuln_scan
from Web_Pentest.web import WebVulnManager


# --------------------
# Tests for VulnScan
# --------------------
@patch("back_end.Regions.web.web_vuln_scan.ZAPv2")
@patch("back_end.Regions.web.web_vuln_scan.export_to_pdf")
@patch("back_end.Regions.web.web_vuln_scan.time.sleep", lambda s: None)  # speed up
def test_run_zap_scan_success(mock_export, mock_zap):
    """Happy path: run_zap_scan returns parsed vulnerabilities."""
    fake_zap = MagicMock()
    mock_zap.return_value = fake_zap

    # urlopen works
    fake_zap.urlopen.return_value = None

    # spider scan simulation
    fake_zap.spider.scan.return_value = "1"

    fake_zap.spider.status.side_effect = ["50", "100","100"]

    # ascan simulation
    fake_zap.ascan.scan.return_value = "2"
    fake_zap.ascan.status.side_effect = ["70", "100","100"]

    # alerts simulation
    fake_zap.core.alerts.return_value = [
        {
            "alert": "SQL Injection",
            "risk": "High",
            "confidence": "Medium",
            "url": "http://test",
            "method": "GET",
            "param": "id",
            "attack": "' OR 1=1--",
            "evidence": "error",
            "description": "Classic SQLi",
            "solution": "Use prepared statements",
            "cweid": "89",
            "wascid": "19",
            "sourceid": "scanner"
        }
    ]

    vs = web_vuln_scan.VulnScan("apikey", "http://proxy")
    vulns = vs.run_zap_scan("http://test")

    assert len(vulns) == 1
    v = vulns[0]
    assert v.alert == "SQL Injection"
    assert v.risk == "High"
    mock_export.assert_called_once()

@patch("back_end.Regions.web.web_vuln_scan.ZAPv2")
@patch("back_end.Regions.web.web_vuln_scan.export_to_pdf")
@patch("back_end.Regions.web.web_vuln_scan.time.sleep", lambda s: None)
def test_run_zap_scan_with_recon_data(mock_export,mock_zap):
    """Should also seed URLs if recon_data is passed."""
    fake_zap = MagicMock()
    mock_zap.return_value = fake_zap
    fake_zap.spider.scan.return_value = "1"
    fake_zap.spider.status.side_effect = ["100"]
    fake_zap.ascan.scan.return_value = "2"
    fake_zap.ascan.status.side_effect = ["100"]
    fake_zap.core.alerts.return_value = []

    vs = web_vuln_scan.VulnScan("apikey", "http://proxy")

    # Minimal fake VulnerabilityEntry-like object
    class DummyEntry:
        url = "http://extra"
    vulns = vs.run_zap_scan("http://test",[DummyEntry()])

    fake_zap.urlopen.assert_any_call("http://extra")
    assert vulns == []


# --------------------
# Tests for WebVulnManager
# --------------------
@pytest.mark.asyncio
async def test_web_vuln_manager_run_scan_success(monkeypatch):
    """WebVulnManager should save results and publish tasks after scanning."""
    fake_bus = MagicMock()
    fake_db = MagicMock()
    fake_vulnscanner = MagicMock()
    fake_vulnscanner.run_zap_scan.return_value = [
        MagicMock(model_dump=lambda: {"alert": "xss"})
    ]

    mgr = WebVulnManager(fake_bus, fake_db, fake_vulnscanner)

    task = {"id": "T1", "target": ["example.com"], "scan_results": {"example.com": []}}
    await mgr.run_scan(task)

    fake_vulnscanner.run_zap_scan.assert_called_once()
    fake_db.save_scan_result.assert_called_once()
    # honeynet + learning + completion
    assert fake_bus.publish_task.call_count >= 3

@pytest.mark.asyncio
async def test_web_vuln_manager_run_scan_no_targets():
    """Should log error and return without scanning."""
    fake_bus = MagicMock()
    fake_db = MagicMock()
    fake_vulnscanner = MagicMock()

    mgr = WebVulnManager(fake_bus, fake_db, fake_vulnscanner)

    task = {"id": "T2"}  # no targets
    result = await mgr.run_scan(task)

    assert result is None
    fake_vulnscanner.run_zap_scan.assert_not_called()
    fake_db.save_scan_result.assert_not_called()
    fake_bus.publish_task.assert_not_called()
