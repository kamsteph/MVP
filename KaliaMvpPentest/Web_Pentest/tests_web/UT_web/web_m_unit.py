# tests/test_web_manager_async.py
import pytest
from unittest.mock import AsyncMock, MagicMock, patch

from Web_Pentest.web import WebManager

@pytest.fixture
def setup_manager():
    bus = MagicMock()
    db = MagicMock()
    learner = MagicMock()
    gnn = MagicMock()
    recon_mgr = MagicMock()
    vuln_mgr = MagicMock()
    exploit_mgr = AsyncMock()

    with patch("back_end.Regions.web.web_manager.GNNBrain", return_value=gnn), \
            patch("back_end.Regions.web.web_manager.WebReconManager", return_value=recon_mgr), \
            patch("back_end.Regions.web.web_manager.WebVulnManager", return_value=vuln_mgr), \
            patch("back_end.Regions.web.web_manager.WebExploitationManager", return_value=exploit_mgr):

        manager = WebManager(
            bus=bus,
            recon_engine=MagicMock(),
            exploitation_engine=MagicMock(),
            vuln_scanner=MagicMock(),
            local_learner=learner,
            db=db,
            gnn_model_path="dummy"
        )

    return manager, bus, db, learner, gnn, exploit_mgr

@pytest.mark.asyncio
async def test_initial_web_scan_publishes_recon(setup_manager):
    manager, bus, _, _, _, _ = setup_manager

    await manager.handle_task({
        "action": "initial_web_scan",
        "targets": ["http://test.com"]
    })

    bus.publish_task.assert_called_once()
    args = bus.publish_task.call_args[0][0]
    assert args["action"] == "web_recon_scan"

@pytest.mark.asyncio
async def test_post_recon_decision_vuln_path(setup_manager):
    manager, bus, db, _, gnn, _ = setup_manager
    gnn.predict.return_value = "vulnerability_scan"

    fake_result = MagicMock()
    fake_result.model_dump.return_value = {"foo": "bar"}

    await manager.handle_task({
        "action": "post_recon_decision",
        "targets": ["http://test.com"],
        "scan_results": [fake_result]
    })

    db.save_scan_result.assert_called()
    bus.publish_task.assert_called()
    assert bus.publish_task.call_args[0][0]["action"] == "web_vuln_scan"

@pytest.mark.asyncio
async def test_post_vuln_decision_exploit_path(setup_manager):
    manager, bus, db, _, gnn, _ = setup_manager
    gnn.predict.return_value = "exploitation"

    fake_vuln = MagicMock()
    fake_vuln.model_dump.return_value = {"id": "CVE-1234"}

    await manager.handle_task({
        "action": "post_vuln_decision",
        "targets": ["http://victim.com"],
        "vuln_results": [fake_vuln]
    })

    db.save_scan_result.assert_called()
    bus.publish_task.assert_called()
    assert bus.publish_task.call_args[0][0]["action"] == "run_exploitation"

@pytest.mark.asyncio
async def test_run_exploitation_saves_and_publishes(setup_manager):
    manager, bus, db, learner, _, exploit_mgr = setup_manager
    exploit_mgr.run.return_value = [{"status": "ok"}]
    learner.learn_from_exploitation.return_value = ["new_item"]

    results = await manager._run_exploitation(["http://t.com"], [{"id": "CVE-1"}])

    assert "http://t.com" in results["exploit_results"]
    learner.learn_from_exploitation.assert_called()
    assert results["new_for_global"] == ["new_item"]
