# tests/unit/test_web_exploitation.py
"""
Unit tests for WebExploitation and WebExploitationManager.

Two styles are provided:
 - MOCKED: uses AsyncMock to fake asyncio.create_subprocess_exec/shell (recommended for CI).
 - REAL  : (commented out) runs a harmless command (echo) on the host (use manually).

Run:
    pip install pytest pytest-asyncio
    pytest -q tests/unit/test_web_exploitation.py
"""

import asyncio
import sys

import pytest
from unittest.mock import MagicMock, AsyncMock, patch

# Import the classes under test (adjust module path if necessary)
from Web_Pentest.web import WebExploitation
from Web_Pentest.web import WebExploitationManager


# -------------------------
# WebExploitation: basic behavior
# -------------------------

@pytest.mark.asyncio
async def test_run_exploitation_skips_when_live_disabled(monkeypatch):
    """When ALLOW_LIVE is False, run_exploitation must skip and persist the skipped record."""
    monkeypatch.setenv("ALLOW_LIVE_EXPLOITS", "0")  # ensure env default
    # Ensure module constant ALLOW_LIVE is False during runtime
    monkeypatch.setattr("back_end.Regions.web.web_exploitation.ALLOW_LIVE", False)

    fake_db = MagicMock()
    fake_db.save_scan_result = MagicMock()

    webexp = WebExploitation(db=fake_db, msf_rpc_config=None)

    vuln = {"id": "CVE-UNIT-1", "exploit_tool": "sim", "exploit_command": "echo hi"}
    res = await webexp.run_exploitation(vuln, "http://target")

    assert res["status"] in ("skipped_live_disabled", "skipped")
    fake_db.save_scan_result.assert_called_once()


# -------------------------
# _execute_cli: MOCKED subprocess path (recommended)
# -------------------------

@pytest.mark.asyncio
async def test__execute_cli_mocked_success(monkeypatch):
    """
    Test _execute_cli using a mocked asyncio.create_subprocess_exec to avoid real processes.
    - We simulate a subprocess that returns stdout bytes and returncode 0.
    """
    fake_db = MagicMock()
    we = WebExploitation(db=fake_db)

    # Patch the create_subprocess_exec used inside the module
    async def fake_create_subprocess_exec(*args, **kwargs):
        proc = AsyncMock()
        # simulate communicate() coroutine returning (stdout_bytes, stderr_bytes)
        proc.communicate = AsyncMock(return_value=(b"hello\n", b""))
        proc.returncode = 0
        return proc

    with patch("back_end.Regions.web.web_exploitation.asyncio.create_subprocess_exec", new=fake_create_subprocess_exec):
        res = await we._execute_cli("echo hello", timeout=2)
        assert res["status"] == "executed"
        assert "hello" in res["output"]

@pytest.mark.asyncio
async def test__execute_cli_mocked_timeout(monkeypatch):
    """
    Simulate a process that hangs and causes asyncio.TimeoutError.
    We emulate communicate() raising asyncio.TimeoutError when awaited via wait_for.
    """
    fake_db = MagicMock()
    we = WebExploitation(db=fake_db)

    async def fake_proc_communicate():
        # Simulate a never-resolving coroutine by raising Timeout when awaited inside wait_for
        await asyncio.sleep(0)  # allow context switch
        raise asyncio.TimeoutError()

    async def fake_create_subprocess_exec(*args, **kwargs):
        proc = AsyncMock()
        proc.communicate = AsyncMock(side_effect=asyncio.TimeoutError)
        proc.kill = AsyncMock()
        proc.wait = AsyncMock(return_value=None)
        proc.returncode = 1
        return proc

    with patch("back_end.Regions.web.web_exploitation.asyncio.create_subprocess_exec", new=fake_create_subprocess_exec):
        res = await we._execute_cli("sleep 0.1", timeout=1)
        # Because our fake raises TimeoutError inside communicate, code returns timeout dict
        assert res["status"] in ("timeout", "cli_error", "failed", "no_command")  # accept any safe outcome


#-------------------------
#_execute_cli: REAL subprocess (MANUAL, commented)
#-------------------------
#NOTE: The following test actually runs a local command (echo) and is OS dependent.
#Keep commented in CI; run manually if you want to smoke-test real-subprocess behavior.

@pytest.mark.asyncio
async def test__execute_cli_real_echo():
    fake_db = MagicMock()
    we = WebExploitation(db=fake_db)

    # Use the Python executable to print "hello" â€” reliable across platforms.
    cmd = f'{sys.executable} -c "print(\'hello\')"'
    res = await we._execute_cli(cmd, timeout=2)

    assert res["status"] == "executed"
    assert "hello" in res["output"]


#-------------------------
#run_exploitation: RPC & CLI branches (mocked)
#-------------------------

@pytest.mark.asyncio
async def test_run_exploitation_cli_path_persists(monkeypatch):
    """When ALLOW_LIVE True but no msf_client, code falls back to CLI; we mock CLI execution."""
    monkeypatch.setenv("ALLOW_LIVE_EXPLOITS", "1")
    monkeypatch.setattr("back_end.Regions.web.web_exploitation.ALLOW_LIVE", True)

    fake_db = MagicMock()
    fake_db.save_scan_result = MagicMock()

    we = WebExploitation(db=fake_db)

    # Mock the _execute_cli to avoid process creation; simulate executed result
    async def fake_execute_cli(cmd, timeout=300):
        return {"status": "executed", "output": "cli-out", "returncode": 0}

    monkeypatch.setattr(we, "_execute_cli", fake_execute_cli)

    vuln = {"id": "CVE-CLI-1", "exploit_command": "curl -I {target_url}"}
    res = await we.run_exploitation(vuln, "http://example.test", timeout=1)
    assert res["status"] == "executed"
    fake_db.save_scan_result.assert_called_once()

@pytest.mark.asyncio
async def test_execute_via_msf_rpc_error_path(monkeypatch):
    """
    If msf_client exists but raises in _execute_via_msf_rpc, the method should return an rpc_error-like dict.
    We'll patch msf_client to force an exception inside _execute_via_msf_rpc.
    """
    monkeypatch.setenv("ALLOW_LIVE_EXPLOITS", "1")
    monkeypatch.setattr("back_end.Regions.web.web_exploitation.ALLOW_LIVE", True)

    fake_db = MagicMock()
    fake_db.save_scan_result = MagicMock()

    we = WebExploitation(db=fake_db, msf_rpc_config={"host": "x", "port": 1, "password": "p"})
    # force msf client presence but make _execute_via_msf_rpc throw
    monkeypatch.setattr(we, "msf_client", True)
    # Patch the blocking helper to raise
    with patch.object(we, "_execute_via_msf_rpc", side_effect=Exception("rpc-fail")):
        # Now run; since msf_client truthy and msf_module not provided, it will proceed but helper raises
        vuln = {"id": "CVE-RPC-1", "msf_module": "exploit/test"}
        # Wrap call and ensure it handles exception without raising
        res = await we.run_exploitation(vuln, "http://fake")
        # We expect it to have a status (rpc_error or executed depending on handling)
        assert isinstance(res, dict)
        fake_db.save_scan_result.assert_called()


# -------------------------
# WebExploitationManager: tests (mocked)
# -------------------------

@pytest.mark.asyncio
async def test_web_exploitation_manager_no_target_returns_empty(monkeypatch):
    fake_db = MagicMock()
    fake_executor = MagicMock()
    manager = WebExploitationManager(fake_db, fake_executor)

    res = await manager.handle_exploitation("", [{"alert": "a"}])
    assert res == []
    # no db save
    fake_db.save_scan_result.assert_not_called()

@pytest.mark.asyncio
async def test_web_exploitation_manager_no_vulns_returns_empty(monkeypatch):
    fake_db = MagicMock()
    fake_executor = MagicMock()
    manager = WebExploitationManager(fake_db, fake_executor)

    res = await manager.handle_exploitation("http://t", [])
    assert res == []
    fake_db.save_scan_result.assert_not_called()

@pytest.mark.asyncio
async def test_web_exploitation_manager_happy_path(monkeypatch):
    """
    Happy path: _run_exploit will be patched to avoid real execution.
    We simulate executor.run_exploits being called via our patch.
    """
    fake_db = MagicMock()
    fake_executor = MagicMock()

    # Make a manager where _run_exploit is patched to return a deterministic result
    manager = WebExploitationManager(fake_db, fake_executor)

    async def fake_run_exploit(vuln, target):
        return {"status": "executed", "target": target, "vuln": vuln.get("alert")}

    monkeypatch.setattr(manager, "_run_exploit", fake_run_exploit)

    results = await manager.handle_exploitation("http://target", [{"alert": "CVE-1"}])

    assert isinstance(results, list)
    assert results[0]["status"] == "executed"
    # summary saved to DB
    fake_db.save_scan_result.assert_called_once()

