# new_module/deception_learning.py
import os
from datetime import datetime
from typing import Dict, Any, List, Optional
import torch
import torch.nn as nn
import torch.optim as optim
import docker

from back_end.utils.colored_logger import get_logger
from back_end.event_bus import EventBus
from back_end.database import DatabaseManager

logger = get_logger(__name__, component="DECEPTION", region="D-L")

# TLS connection for remote Docker host
CERT_DIR = os.getenv("CERT_DIR")
tls_config = docker.tls.TLSConfig(
    client_cert=(os.path.join(CERT_DIR, "cert.pem"), os.path.join(CERT_DIR, "key.pem")),
    ca_cert=os.path.join(CERT_DIR, "ca.pem"),
    verify=True
)

# ---------------- GAN COMPONENTS (optional training mode) ----------------
class HoneynetGenerator(nn.Module):
    """Simple feedforward generator for honeynet configs"""
    def __init__(self, noise_dim: int = 16, config_dim: int = 32):
        super().__init__()
        self.model = nn.Sequential(
            nn.Linear(noise_dim, 64),
            nn.ReLU(),
            nn.Linear(64, config_dim),
            nn.Tanh(),
        )

    def forward(self, z):
        return self.model(z)


class HoneynetDiscriminator(nn.Module):
    """Simple discriminator to validate honeynet configs"""
    def __init__(self, config_dim: int = 32):
        super().__init__()
        self.model = nn.Sequential(
            nn.Linear(config_dim, 64),
            nn.LeakyReLU(0.2),
            nn.Linear(64, 1),
            nn.Sigmoid()
        )

    def forward(self, x):
        return self.model(x)


# ---------------- MAIN DECEPTION LEARNING ----------------
class DeceptionLearning:
    """
    Handles honeynet deployment logic.
    - live mode: uses real vulnerabilities (default)
    - training mode: uses GAN to synthesize fake honeynet configs for research
    """

    def __init__(self, bus: EventBus, db: DatabaseManager, device="cpu"):
        self.bus = bus
        self.db = db
        self.device = device

        # Mode selector (from environment or runtime config)
        # LIVE_MODE=1 → Real honeynet deployment
        # TRAIN_MODE=1 → GAN training/simulation
        self.live_mode = os.getenv("LIVE_MODE", "1") == "1"
        self.train_mode = os.getenv("TRAIN_MODE", "0") == "1"

        # Docker connection (for live mode)
        self.docker_client = docker.APIClient(
            base_url="tcp://10.149.244.106:2376",
            tls=tls_config
        )

        # GAN models (loaded only in training mode)
        if self.train_mode:
            self.generator = HoneynetGenerator().to(self.device)
            self.discriminator = HoneynetDiscriminator().to(self.device)
            self.gan_optimizer_G = optim.Adam(self.generator.parameters(), lr=0.001)
            self.gan_optimizer_D = optim.Adam(self.discriminator.parameters(), lr=0.001)
            self.criterion = nn.BCELoss()
            logger.info("[DeceptionLearning] Initialized in GAN TRAINING mode.")
        else:
            logger.info("[DeceptionLearning] Initialized in LIVE honeynet mode.")

        # Subscribe to honeynet deployment requests
        self.bus.subscribe("deploy_honeynet", self.deploy_honeynet)

    # -------------------------------------------------------------------------
    async def deploy_honeynet(self, task: Dict[str, Any]):
        """
        Deploy honeynet containers or generate synthetic ones depending on mode.
        """
        honeynet_type = task.get("type", "network")
        vuln_files: List[Dict[str, Any]] = task.get("vuln_files", [])
        logger.info(f"[DeceptionLearning] deploy_honeynet called → live={self.live_mode}, train={self.train_mode}")

        try:
            if self.train_mode:
                # ---------------- GAN SYNTHETIC MODE ----------------
                z = torch.randn(1, 16, device=self.device)
                config_tensor = self.generator(z)
                generated_config = config_tensor.detach().cpu().numpy().tolist()

                final_config = {
                    "mode": "synthetic",
                    "gan_generated": generated_config,
                    "real_vulns": vuln_files or []
                }
                honeypot_id = f"honeypot-sim-{datetime.now().strftime('%Y%m%d%H%M%S')}"
                honeypot_ip = "127.0.0.1"  # simulated
                logger.info(f"[DeceptionLearning] GAN generated synthetic honeynet config.")

            else:
                # ---------------- REAL LIVE DEPLOYMENT ----------------
                honeypot_id = f"honeypot-{honeynet_type}-{datetime.now().strftime('%Y%m%d%H%M%S')}"
                container = self.docker_client.create_container(
                    image="honeynet_image",
                    name=honeypot_id,
                    detach=True,
                    ports=[80, 22],
                    host_config=self.docker_client.create_host_config(
                        port_bindings={80: ('0.0.0.0', None), 22: ('0.0.0.0', None)}
                    )
                )
                self.docker_client.start(container)
                info = self.docker_client.inspect_container(container)
                honeypot_ip = info["NetworkSettings"]["IPAddress"]
                logger.info(f"[DeceptionLearning] Honeynet container started at {honeypot_ip}")

                final_config = {
                    "mode": "live",
                    "vulnerabilities": vuln_files
                }

            # ---------------- SAVE METADATA ----------------
            honeypot_data = {
                "honeypot_id": honeypot_id,
                "type": honeynet_type,
                "ip": honeypot_ip,
                "status": "running",
                "created_at": datetime.now().isoformat(),
                "config": final_config
            }
            self.db.standard_db.insert_one(honeypot_data)
            logger.info(f"[DeceptionLearning] Honeynet {honeypot_id} recorded in DB.")

            # ---------------- NOTIFY Exploitation AI ----------------
            self.bus.publish_task({
                "region": "exploitation",
                "action": "ai_exploitation",
                "honeypot_id": honeypot_id,
                "target_ip": honeypot_ip,
                "vuln_files": vuln_files,
                "mode": "train" if self.train_mode else "live"
            })
            logger.info(f"[DeceptionLearning] Triggered ExploitationAIAgentV2 for honeypot {honeypot_id}.")

        except Exception as e:
            logger.error(f"[DeceptionLearning] Deployment failed: {e}")

    # -------------------------------------------------------------------------
    async def analyze_traffic(self, traffic_data: Dict[str, Any]):
        """
        Analyze honeypot network traffic, forwarding to local learning modules.
        """
        logger.info("[DeceptionLearning] New honeypot traffic detected. Forwarding to local learner.")
        self.bus.publish_task({
            "region": "L_REGION",
            "action": "learn_from_deception",
            "data": traffic_data
        })
