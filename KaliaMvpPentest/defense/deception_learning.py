# new_module/deception_learning.py
import os
from datetime import datetime
from typing import Dict, Any
import torch
import torch.nn as nn
import torch.optim as optim
import docker
import subprocess
import json
import uuid

from back_end.utils.colored_logger import get_logger
from back_end.event_bus import EventBus
from back_end.database import DatabaseManager

logger = get_logger(__name__, component="DECEPTION", region="D-L")

# -------------------------- FIRECRACKER HELPERS --------------------------

class FirecrackerManager:
    """
    Minimal Firecracker wrapper for fast microVM honeynet deployment.
    - Each microVM gets its own jailer path.
    - Uses rootfs templates you pre-created.
    """

    def __init__(self, kernel_path: str, rootfs_templates_dir: str):
        self.kernel_path = kernel_path
        self.templates = rootfs_templates_dir

    def _new_vm_id(self):
        return str(uuid.uuid4())[:8]

    def _build_vm_paths(self, vm_id):
        base = f"/tmp/firecracker_{vm_id}"
        os.makedirs(base, exist_ok=True)
        return {
            "id": vm_id,
            "path": base,
            "kernel": self.kernel_path,
            "rootfs": os.path.join(self.templates, "level1.ext4"),   # default
            "socket": os.path.join(base, "api.socket")
        }

    def launch_microvm(self, level="level1"):
        """
        Launch a microVM using Firecracker and return its metadata.
        """

        vm_id = self._new_vm_id()
        paths = self._build_vm_paths(vm_id)

        # rootfs selection per level1/2/3
        rootfs_file = os.path.join(self.templates, f"{level}.ext4")
        if not os.path.exists(rootfs_file):
            raise RuntimeError(f"Missing rootfs: {rootfs_file}")

        paths["rootfs"] = rootfs_file

        logger.info(f"[Firecracker] Launching microVM {vm_id} with rootfs={level}.")

        # 1. Start Firecracker in background
        subprocess.Popen([
            "firecracker",
            "--api-sock", paths["socket"]
        ])

        # 2. Configure the microVM
        machine_cfg = {
            "vcpu_count": 1,
            "mem_size_mib": 128,
            "ht_enabled": False
        }
        boot_cfg = {
            "kernel_image_path": paths["kernel"],
            "boot_args": "console=ttyS0 reboot=k panic=1 pci=off"
        }
        drive_cfg = {
            "drive_id": "rootfs",
            "path_on_host": paths["rootfs"],
            "is_root_device": True,
            "is_read_only": False
        }

        # Configure Firecracker via API
        self._fc_put(paths["socket"], "/machine-config", machine_cfg)
        self._fc_put(paths["socket"], "/boot-source", boot_cfg)
        self._fc_put(paths["socket"], "/drives/rootfs", drive_cfg)

        # 3. Start microVM
        self._fc_put(paths["socket"], "/actions", {
            "action_type": "InstanceStart"
        })

        # Firecracker won't give IP directly — if you embed a DHCP client inside rootfs,
        # you retrieve IP by reading the host TAP interface. For simplicity, we assign:
        honeypot_ip = f"172.16.0.{int(vm_id[:2], 16)%200 + 10}"

        logger.info(f"[Firecracker] microVM {vm_id} started at simulated IP {honeypot_ip}")

        return {
            "honeypot_id": vm_id,
            "ip": honeypot_ip,
            "rootfs_level": level,
            "paths": paths
        }

    def _fc_put(self, socket, path, payload):
        cmd = [
            "curl", "-sS", "-X", "PUT",
            "--unix-socket", socket,
            "-H", "Content-Type: application/json",
            "-d", json.dumps(payload),
            f"http://localhost{path}"
        ]
        subprocess.run(cmd, check=True)


# -------------------------- GAN COMPONENTS (training) --------------------------

class HoneynetGenerator(nn.Module):
    def __init__(self, noise_dim=16, config_dim=32):
        super().__init__()
        self.model = nn.Sequential(
            nn.Linear(noise_dim, 64),
            nn.ReLU(),
            nn.Linear(64, config_dim),
            nn.Tanh()
        )
    def forward(self, z): return self.model(z)


class HoneynetDiscriminator(nn.Module):
    def __init__(self, config_dim=32):
        super().__init__()
        self.model = nn.Sequential(
            nn.Linear(config_dim, 64),
            nn.LeakyReLU(0.2),
            nn.Linear(64, 1),
            nn.Sigmoid()
        )
    def forward(self, x): return self.model(x)


# -------------------------- MAIN DECEPTION LEARNING --------------------------

class DeceptionLearning:

    def __init__(self, bus: EventBus, db: DatabaseManager, device="cpu"):
        self.bus = bus
        self.db = db
        self.device = device

        # Provider selection
        provider = os.getenv("HONEYPOT_PROVIDER", "DOCKER").upper()
        self.use_docker = (provider == "DOCKER")
        self.use_firecracker = (provider == "FIRECRACKER")
        self.use_gan = (provider == "GAN")

        logger.info(f"[DeceptionLearning] Provider selected: {provider}")

        # Docker mode
        if self.use_docker:
            CERT_DIR = os.getenv("CERT_DIR")
            tls_config = docker.tls.TLSConfig(
                client_cert=(os.path.join(CERT_DIR, "cert.pem"), os.path.join(CERT_DIR, "key.pem")),
                ca_cert=os.path.join(CERT_DIR, "ca.pem"),
                verify=True
            )
            self.docker_client = docker.APIClient(
                base_url="tcp://10.149.244.106:2376",
                tls=tls_config
            )
            logger.info("[DeceptionLearning] Docker mode ready.")

        # Firecracker mode
        if self.use_firecracker:
            self.firecracker = FirecrackerManager(
                kernel_path="/honeynet/kernel/vmlinux",
                rootfs_templates_dir="/honeynet/rootfs_templates"
            )
            logger.info("[DeceptionLearning] Firecracker mode ready.")

        # GAN mode
        if self.use_gan:
            self.generator = HoneynetGenerator().to(self.device)
            self.discriminator = HoneynetDiscriminator().to(self.device)
            self.gan_optimizer_G = optim.Adam(self.generator.parameters(), lr=0.001)
            self.gan_optimizer_D = optim.Adam(self.discriminator.parameters(), lr=0.001)
            self.criterion = nn.BCELoss()
            logger.info("[DeceptionLearning] GAN training mode ready.")

        # Event listener
        self.bus.subscribe("deploy_honeynet", self.deploy_honeynet)

        # -------------------------------------------------------------------------
    # UPDATED HONEYNET DEPLOYMENT — using VAI level summary
    # -------------------------------------------------------------------------
    async def deploy_honeynet(self, task: Dict[str, Any]):
        """
        Deploy multiple Firecracker microVMs according to:
            - level_1 / level_2 / level_3
            - defense_state per host
            - host_record vulnerabilities

        Input task MUST contain:
            - level_summary  → from VAI.classify_hosts_for_levels()
            - host_records   → raw recon/vuln results

        This is the main PRE-EXPLOITATION environment builder.
        """
        try:
            level_summary = task.get("level_summary", {})
            host_records = task.get("host_records", [])
            honeynet_type = task.get("type", "network")

            logger.info("[DeceptionLearning] Received honeynet deployment request.")
            logger.info(f"[DeceptionLearning] Level summary = {level_summary.get('counts')}")

            deployed_honeypots = []

            # -------------------------------------------------------------
            # DEPLOY LEVEL_1, LEVEL_2, LEVEL_3 microVMs
            # Each level gets a different rootfs template
            # -------------------------------------------------------------
            for level_key in ("level_1", "level_2", "level_3"):
                hosts_for_level = level_summary.get(level_key, [])

                for host in hosts_for_level:
                    ip = host["ip"]
                    defense = host["defense_state"]
                    score = host["score"]
                    exploit_prob = host["exploit_prob"]

                    logger.info(f"[DeceptionLearning] Deploying {level_key} VM for host {ip}")

                    if self.use_firecracker:
                        # Firecracker rootfs matches level_1.ext4, level_2.ext4, level_3.ext4
                        fc = self.firecracker.launch_microvm(level=level_key)
                        honeypot_id = fc["honeypot_id"]
                        honeypot_ip = fc["ip"]

                        config_block = {
                            "mode": "firecracker",
                            "rootfs_level": level_key,
                            "simulated_for_ip": ip,
                            "defense_state": defense,
                            "vuln_score": score,
                            "exploit_prob": exploit_prob
                        }

                    elif self.use_docker:
                        honeypot_id = f"{level_key}-{datetime.now().strftime('%H%M%S')}"
                        container = self.docker_client.create_container(
                            image="honeynet_image",
                            name=honeypot_id,
                            detach=True,
                            ports=[80, 22],
                            host_config=self.docker_client.create_host_config(
                                port_bindings={80: ('0.0.0.0', None), 22: ('0.0.0.0', None)}
                            )
                        )
                        self.docker_client.start(container)
                        info = self.docker_client.inspect_container(container)
                        honeypot_ip = info["NetworkSettings"]["IPAddress"]

                        config_block = {
                            "mode": "docker",
                            "rootfs_level": level_key,
                            "simulated_for_ip": ip,
                            "defense_state": defense,
                            "vuln_score": score,
                            "exploit_prob": exploit_prob
                        }

                    elif self.use_gan:
                        z = torch.randn(1, 16, device=self.device)
                        cfg = self.generator(z).detach().cpu().numpy().tolist()
                        honeypot_id = f"gan-{datetime.now().strftime('%H%M%S')}"
                        honeypot_ip = "127.0.0.1"
                        config_block = {
                            "mode": "gan",
                            "generated_config": cfg,
                            "simulated_for_ip": ip
                        }

                    else:
                        raise RuntimeError("No honeynet provider selected.")

                    # Save honeypot metadata
                    honeypot_data = {
                        "honeypot_id": honeypot_id,
                        "type": honeynet_type,
                        "ip": honeypot_ip,
                        "status": "running",
                        "created_at": datetime.now().isoformat(),
                        "level": level_key,
                        "source_ip": ip,
                        "config": config_block
                    }
                    self.db.standard_db.insert_one(honeypot_data)

                    deployed_honeypots.append({
                        "honeypot_id": honeypot_id,
                        "ip": honeypot_ip,
                        "level": level_key,
                        "simulated_for": ip
                    })

            logger.info(f"[DeceptionLearning] Deployed {len(deployed_honeypots)} honeypots total.")

            # -------------------------------------------------------------------
            # Notify EXP AI — pre-exploitation now begins
            # -------------------------------------------------------------------
            self.bus.publish_task({
                "region": "exploitation",
                "action": "ai_exploitation",
                "honeypots": deployed_honeypots,
                "mode": "simulation",
                "task_id": task.get("task_id"),
            })

        except Exception as e:
            logger.error(f"[DeceptionLearning] Deployment failed: {e}")

    # -------------------------------------------------------------------------
    # async def deploy_honeynet(self, task: Dict[str, Any]):
    #     global honeypot_id, honeypot_ip, final_config
    #     honeynet_type = task.get("type", "network")
    #     vuln_files: List[Dict[str, Any]] = task.get("vuln_files", [])
    #
    #     try:
    #         # ---------------- GAN MODE ----------------
    #         if self.use_gan:
    #             z = torch.randn(1, 16, device=self.device)
    #             config = self.generator(z).detach().cpu().numpy().tolist()
    #             honeypot_id = f"honeypot-gan-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    #             honeypot_ip = "127.0.0.1"
    #
    #             final_config = {"mode": "synthetic", "gan_generated": config}
    #
    #         # ---------------- DOCKER MODE ----------------
    #         elif self.use_docker:
    #             honeypot_id = f"honeypot-docker-{datetime.now().strftime('%Y%m%d%H%M%S')}"
    #             container = self.docker_client.create_container(
    #                 image="honeynet_image",
    #                 name=honeypot_id,
    #                 detach=True,
    #                 ports=[80, 22],
    #                 host_config=self.docker_client.create_host_config(
    #                     port_bindings={80: ('0.0.0.0', None), 22: ('0.0.0.0', None)}
    #                 )
    #             )
    #             self.docker_client.start(container)
    #             info = self.docker_client.inspect_container(container)
    #             honeypot_ip = info["NetworkSettings"]["IPAddress"]
    #
    #             final_config = {"mode": "docker", "vulnerabilities": vuln_files}
    #
    #         # ---------------- FIRECRACKER MODE ----------------
    #         elif self.use_firecracker:
    #             fc = self.firecracker.launch_microvm(level="level1")
    #             honeypot_id = fc["honeypot_id"]
    #             honeypot_ip = fc["ip"]
    #
    #             final_config = {
    #                 "mode": "firecracker",
    #                 "rootfs_level": fc["rootfs_level"],
    #                 "vulnerabilities": vuln_files,
    #             }
    #
    #         # ---------------- SAVE TO DB ----------------
    #         honeypot_data = {
    #             "honeypot_id": honeypot_id,
    #             "type": honeynet_type,
    #             "ip": honeypot_ip,
    #             "status": "running",
    #             "created_at": datetime.now().isoformat(),
    #             "config": final_config,
    #         }
    #         self.db.standard_db.insert_one(honeypot_data)
    #
    #         # ---------------- NOTIFY EXP AI ----------------
    #         self.bus.publish_task({
    #             "region": "exploitation",
    #             "action": "ai_exploitation",
    #             "honeypot_id": honeypot_id,
    #             "target_ip": honeypot_ip,
    #             "vuln_files": vuln_files,
    #             "mode": final_config["mode"],
    #         })
    #
    #     except Exception as e:
    #         logger.error(f"[DeceptionLearning] Deployment failed: {e}")

    # -------------------------------------------------------------------------
    async def analyze_traffic(self, traffic_data: Dict[str, Any]):
        logger.info("[DeceptionLearning] Honeypot traffic received → forwarding to learning module.")
        self.bus.publish_task({
            "region": "L_REGION",
            "action": "learn_from_deception",
            "data": traffic_data
        })

# # new_module/deception_learning.py
# import os
# from datetime import datetime
# from typing import Dict, Any, List, Optional
# import torch
# import torch.nn as nn
# import torch.optim as optim
# import docker
#
# from back_end.utils.colored_logger import get_logger
# from back_end.event_bus import EventBus
# from back_end.database import DatabaseManager
#
# logger = get_logger(__name__, component="DECEPTION", region="D-L")
#
# # TLS connection for remote Docker host
# CERT_DIR = os.getenv("CERT_DIR")
# tls_config = docker.tls.TLSConfig(
#     client_cert=(os.path.join(CERT_DIR, "cert.pem"), os.path.join(CERT_DIR, "key.pem")),
#     ca_cert=os.path.join(CERT_DIR, "ca.pem"),
#     verify=True
# )
#
# # ---------------- GAN COMPONENTS (optional training mode) ----------------
# class HoneynetGenerator(nn.Module):
#     """Simple feedforward generator for honeynet configs"""
#     def __init__(self, noise_dim: int = 16, config_dim: int = 32):
#         super().__init__()
#         self.model = nn.Sequential(
#             nn.Linear(noise_dim, 64),
#             nn.ReLU(),
#             nn.Linear(64, config_dim),
#             nn.Tanh(),
#         )
#
#     def forward(self, z):
#         return self.model(z)
#
#
# class HoneynetDiscriminator(nn.Module):
#     """Simple discriminator to validate honeynet configs"""
#     def __init__(self, config_dim: int = 32):
#         super().__init__()
#         self.model = nn.Sequential(
#             nn.Linear(config_dim, 64),
#             nn.LeakyReLU(0.2),
#             nn.Linear(64, 1),
#             nn.Sigmoid()
#         )
#
#     def forward(self, x):
#         return self.model(x)
#
#
# # ---------------- MAIN DECEPTION LEARNING ----------------
# class DeceptionLearning:
#     """
#     Handles honeynet deployment logic.
#     - live mode: uses real vulnerabilities (default)
#     - training mode: uses GAN to synthesize fake honeynet configs for research
#     """
#
#     def __init__(self, bus: EventBus, db: DatabaseManager, device="cpu"):
#         self.bus = bus
#         self.db = db
#         self.device = device
#
#         # Mode selector (from environment or runtime config)
#         # LIVE_MODE=1 → Real honeynet deployment
#         # TRAIN_MODE=1 → GAN training/simulation
#         self.live_mode = os.getenv("LIVE_MODE", "1") == "1"
#         self.train_mode = os.getenv("TRAIN_MODE", "0") == "1"
#
#         # Docker connection (for live mode)
#         self.docker_client = docker.APIClient(
#             base_url="tcp://10.149.244.106:2376",
#             tls=tls_config
#         )
#
#         # GAN models (loaded only in training mode)
#         if self.train_mode:
#             self.generator = HoneynetGenerator().to(self.device)
#             self.discriminator = HoneynetDiscriminator().to(self.device)
#             self.gan_optimizer_G = optim.Adam(self.generator.parameters(), lr=0.001)
#             self.gan_optimizer_D = optim.Adam(self.discriminator.parameters(), lr=0.001)
#             self.criterion = nn.BCELoss()
#             logger.info("[DeceptionLearning] Initialized in GAN TRAINING mode.")
#         else:
#             logger.info("[DeceptionLearning] Initialized in LIVE honeynet mode.")
#
#         # Subscribe to honeynet deployment requests
#         self.bus.subscribe("deploy_honeynet", self.deploy_honeynet)
#
#     # -------------------------------------------------------------------------
#     async def deploy_honeynet(self, task: Dict[str, Any]):
#         """
#         Deploy honeynet containers or generate synthetic ones depending on mode.
#         """
#         honeynet_type = task.get("type", "network")
#         vuln_files: List[Dict[str, Any]] = task.get("vuln_files", [])
#         logger.info(f"[DeceptionLearning] deploy_honeynet called → live={self.live_mode}, train={self.train_mode}")
#
#         try:
#             if self.train_mode:
#                 # ---------------- GAN SYNTHETIC MODE ----------------
#                 z = torch.randn(1, 16, device=self.device)
#                 config_tensor = self.generator(z)
#                 generated_config = config_tensor.detach().cpu().numpy().tolist()
#
#                 final_config = {
#                     "mode": "synthetic",
#                     "gan_generated": generated_config,
#                     "real_vulns": vuln_files or []
#                 }
#                 honeypot_id = f"honeypot-sim-{datetime.now().strftime('%Y%m%d%H%M%S')}"
#                 honeypot_ip = "127.0.0.1"  # simulated
#                 logger.info(f"[DeceptionLearning] GAN generated synthetic honeynet config.")
#
#             else:
#                 # ---------------- REAL LIVE DEPLOYMENT ----------------
#                 honeypot_id = f"honeypot-{honeynet_type}-{datetime.now().strftime('%Y%m%d%H%M%S')}"
#                 container = self.docker_client.create_container(
#                     image="honeynet_image",
#                     name=honeypot_id,
#                     detach=True,
#                     ports=[80, 22],
#                     host_config=self.docker_client.create_host_config(
#                         port_bindings={80: ('0.0.0.0', None), 22: ('0.0.0.0', None)}
#                     )
#                 )
#                 self.docker_client.start(container)
#                 info = self.docker_client.inspect_container(container)
#                 honeypot_ip = info["NetworkSettings"]["IPAddress"]
#                 logger.info(f"[DeceptionLearning] Honeynet container started at {honeypot_ip}")
#
#                 final_config = {
#                     "mode": "live",
#                     "vulnerabilities": vuln_files
#                 }
#
#             # ---------------- SAVE METADATA ----------------
#             honeypot_data = {
#                 "honeypot_id": honeypot_id,
#                 "type": honeynet_type,
#                 "ip": honeypot_ip,
#                 "status": "running",
#                 "created_at": datetime.now().isoformat(),
#                 "config": final_config
#             }
#             self.db.standard_db.insert_one(honeypot_data)
#             logger.info(f"[DeceptionLearning] Honeynet {honeypot_id} recorded in DB.")
#
#             # ---------------- NOTIFY Exploitation AI ----------------
#             self.bus.publish_task({
#                 "region": "exploitation",
#                 "action": "ai_exploitation",
#                 "honeypot_id": honeypot_id,
#                 "target_ip": honeypot_ip,
#                 "vuln_files": vuln_files,
#                 "mode": "train" if self.train_mode else "live"
#             })
#             logger.info(f"[DeceptionLearning] Triggered ExploitationAIAgentV2 for honeypot {honeypot_id}.")
#
#         except Exception as e:
#             logger.error(f"[DeceptionLearning] Deployment failed: {e}")
#
#     # -------------------------------------------------------------------------
#     async def analyze_traffic(self, traffic_data: Dict[str, Any]):
#         """
#         Analyze honeypot network traffic, forwarding to local learning modules.
#         """
#         logger.info("[DeceptionLearning] New honeypot traffic detected. Forwarding to local learner.")
#         self.bus.publish_task({
#             "region": "L_REGION",
#             "action": "learn_from_deception",
#             "data": traffic_data
#         })
