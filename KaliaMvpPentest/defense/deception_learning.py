# new_module/deception_learning.py
import os
from datetime import datetime
from typing import Dict, Any, List
import torch
import torch.nn as nn
import torch.optim as optim
import docker

from back_end.utils.colored_logger import get_logger
from back_end.event_bus import EventBus
from back_end.database import DatabaseManager

logger = get_logger(__name__, component="DECEPTION", region="D-L")
CERT_DIR=os.getenv("CERT_DIR")
tls_config = docker.tls.TLSConfig(
    client_cert=(os.path.join(CERT_DIR,"cert.pem"), os.path.join(CERT_DIR,"key.pem")),
    ca_cert=os.path.join(CERT_DIR,"ca.pem"),
    verify=True
)

# ---------------- GAN COMPONENTS ----------------
class HoneynetGenerator(nn.Module):
    """Simple feedforward generator for honeynet configs"""
    def __init__(self, noise_dim: int = 16, config_dim: int = 32):
        super().__init__()
        self.model = nn.Sequential(
            nn.Linear(noise_dim, 64),
            nn.ReLU(),
            nn.Linear(64, config_dim),
            nn.Tanh(),
        )

    def forward(self, z):
        return self.model(z)


class HoneynetDiscriminator(nn.Module):
    """Simple discriminator to validate honeynet configs"""
    def __init__(self, config_dim: int = 32):
        super().__init__()
        self.model = nn.Sequential(
            nn.Linear(config_dim, 64),
            nn.LeakyReLU(0.2),
            nn.Linear(64, 1),
            nn.Sigmoid()
        )

    def forward(self, x):
        return self.model(x)


# ---------------- MAIN DECEPTION LEARNING ----------------
class DeceptionLearning:
    def __init__(self, bus: EventBus, db: DatabaseManager, device="cpu"):
        self.bus = bus
        self.db = db
        self.device = device

        # GAN model
        self.generator = HoneynetGenerator().to(self.device)
        self.discriminator = HoneynetDiscriminator().to(self.device)
        self.gan_optimizer_G = optim.Adam(self.generator.parameters(), lr=0.001)
        self.gan_optimizer_D = optim.Adam(self.discriminator.parameters(), lr=0.001)
        self.criterion = nn.BCELoss()

        # Event subscription
        self.bus.subscribe("deploy_honeynet", self.deploy_honeynet)
        self.docker_client = docker.APIClient(base_url="tcp://10.149.244.106:2376",tls=tls_config)
        print(self.docker_client.version())
        logger.info("[DeceptionLearning] Module initialized with GAN.")

    async def deploy_honeynet(self, task: Dict[str, Any]):
        """
        Deploys a honeynet by combining GAN configs + real vulnerability files.
        Then signals ExploitationManager to begin exploitation.
        """
        honeynet_type = task.get("type", "generic")
        vuln_files: List[Dict[str, Any]] = task.get("vuln_files", [])
        logger.info(f"[DeceptionLearning] Deploying {honeynet_type} honeynet...")

        # Step A: Generate GAN-based config
        z = torch.randn(1, 16, device=self.device)
        config_tensor = self.generator(z)
        generated_config = config_tensor.detach().cpu().numpy().tolist()
        logger.debug(f"[DeceptionLearning] GAN generated config: {generated_config}")

        # Step B: Merge with provided vulnerabilities (if any)
        final_config = {
            "gan_generated": generated_config,
            "real_vulns": vuln_files or []
        }
        logger.info("[DeceptionLearning] Final honeynet config created (merged real + GAN).")

        # Step C: Save honeypot metadata in DB
        honeypot_id = f"honeypot-{honeynet_type}-{hash(str(final_config))}"
        honeypot_data = {
            "honeypot_id": honeypot_id,
            "type": honeynet_type,
            "status": "deployed",
            "config": final_config,
            "start_time": datetime.now().isoformat()
        }
        self.db.results.insert_one(honeypot_data)
        logger.info(f"[DeceptionLearning] Honeynet {honeypot_id} deployed and logged in DB.")

        # Step D: Signal ExploitationManager to start exploiting this honeynet
        self.bus.publish_task({
            "region": "exploitation",
            "action": "start_exploitation",
            "honeypot_id": honeypot_id,
            "vuln_files": vuln_files,
        })
        logger.info(f"[DeceptionLearning] Task sent to ExploitationManager for honeypot {honeypot_id}.")


    async def analyze_traffic(self, traffic_data: Dict[str, Any]):
        """
        Processes traffic captured by honeynets, forwarding to local learners.
        """
        logger.info("[DeceptionLearning] New honeypot traffic detected. Forwarding to local learning.")
        self.bus.publish_task({
            "region": "L_REGION",
            "action": "learn_from_deception",
            "data": traffic_data
        })
