# metrics/validator.py
from typing import Dict
from sklearn.metrics import precision_score, recall_score, f1_score

from back_end.database import DatabaseManager


class DBResultValidator:
    """
    Validator that fetches ground truth dynamically using DatabaseManager.
    """

    def __init__(self, db_manager: DatabaseManager = None):
        # Allow injecting DB for tests
        self.db_manager = db_manager or DatabaseManager()
        # Direct collection reference (standard_db)
        self.results = self.db_manager.results

    def validate_network(self, system_output: dict, target_ip: str) -> Dict[str, Dict[str, float]]:
        gt = self.results.find_one({"ip": target_ip}) or {}
        results = {}

        # Ports
        y_true_ports = [1 if p in gt.get("expected_ports", []) else 0
                        for p in system_output.get("open_ports", [])]
        y_pred_ports = [1] * len(y_true_ports)
        results["ports"] = self._compute_metrics(y_true_ports, y_pred_ports)

        # Vulnerabilities
        y_true_vulns = [1 if v in gt.get("expected_vulns", []) else 0
                        for v in system_output.get("vulnerabilities", [])]
        y_pred_vulns = [1] * len(y_true_vulns)
        results["vulnerabilities"] = self._compute_metrics(y_true_vulns, y_pred_vulns)

        return results

    def validate_web(self, system_output: dict, domain: str) -> Dict[str, Dict[str, float]]:
        gt = self.results.find_one({"domain": domain}) or {}
        results = {}

        # Endpoints
        y_true_endpoints = [1 if ep in gt.get("expected_endpoints", []) else 0
                            for ep in system_output.get("endpoints", [])]
        y_pred_endpoints = [1] * len(y_true_endpoints)
        results["endpoints"] = self._compute_metrics(y_true_endpoints, y_pred_endpoints)

        # Vulnerabilities
        y_true_vulns = [1 if v in gt.get("expected_vulns", []) else 0
                        for v in system_output.get("vulnerabilities", [])]
        y_pred_vulns = [1] * len(y_true_vulns)
        results["vulnerabilities"] = self._compute_metrics(y_true_vulns, y_pred_vulns)

        return results

    def evaluate(self, system_output: dict) -> Dict[str, Dict[str, float]]:
        """
        Auto-select validation based on region type (network/web).
        """
        if "ip" in system_output:  # network scan results
            return self.validate_network(system_output, system_output["ip"])
        elif "domain" in system_output:  # web scan results
            return self.validate_web(system_output, system_output["domain"])
        else:
            return {"unknown": {"precision": 0, "recall": 0, "f1": 0}}

    def _compute_metrics(self, y_true, y_pred) -> Dict[str, float]:
        if not y_true:
            return {"precision": 0, "recall": 0, "f1": 0}
        return {
            "precision": precision_score(y_true, y_pred, zero_division=0),
            "recall": recall_score(y_true, y_pred, zero_division=0),
            "f1": f1_score(y_true, y_pred, zero_division=0)
        }
