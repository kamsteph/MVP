import asyncio
import uuid
import time
from datetime import datetime

from back_end.event_bus import EventBus
from back_end.database import DatabaseManager
from back_end.pentest_orchestrator import PentestOrchestrator

from metrics.metrics_collector import BenchmarkMetrics
from metrics.validator import DBResultValidator
from back_end.utils.export_report import export_report, export_to_pdf
from back_end.utils.colored_logger import get_logger


logger = get_logger(__name__, component="BENCHMARK", region="CONTROLLER")


# back_end/benchmark_runner.py

class BenchmarkRunner:
    def __init__(self, bus=None, db=None):
        self.bus = bus or EventBus()
        # Ensure that self.db is correctly handled
        self.db = db if db is not None else DatabaseManager()

        self.orchestrator = PentestOrchestrator(self.bus, self.db)
        self.metrics = BenchmarkMetrics()
        self.validator = DBResultValidator(self.db) # <--- Corrected to use self.db
        self.scan_results = {}

        self.bus.subscribe("task_completed", self._handle_task_completed)
        logger.info("BenchmarkRunner initialized.")


    def _handle_task_completed(self, task_result):
        """Callback when a scan finishes."""
        scan_id = task_result.get("scan_id", str(uuid.uuid4()))
        self.scan_results[scan_id] = task_result
        logger.info(f"Task completed: ScanID={scan_id}, Region={task_result.get('region')}")

    async def run_single_scan(self, region: str, scan_type: str, target: list):
        local_id = str(uuid.uuid4())
        logger.info(f"Starting scan {local_id} | Region={region}, Type={scan_type}, Target={target}")

        # ---- Submit scan ----
        start = time.time()
        submit_result = await self.orchestrator.submit_scan_request(
            region, scan_type, target=["192.168.12.13"], scope="black box",
        )
        submit_end = time.time()

        # Use orchestrator's task_id if available
        scan_id = submit_result.get("task_id", local_id)

        self.metrics.record_stage(
            scan_id,
            "scan_request",
            submit_result.get("status", "unknown"),
            start,
            submit_end,
            submit_result,
        )
        logger.debug(f"Scan request accepted for {scan_id}")

        # ---- Wait for task completion ----
        while scan_id not in self.scan_results:
            await asyncio.sleep(0.5)

        result = self.scan_results[scan_id]
        end = time.time()

        self.metrics.record_stage(
            scan_id,
            "scan_completion",
            result.get("status", "completed"),
            submit_end,
            end,
            result,
        )
        logger.info(f"Scan {scan_id} completed successfully.")

        # ---- Validate ----
        validation = self.validator.evaluate(result)
        self.metrics.record_stage(
            scan_id,
            "validation",
            "completed",
            time.time(),
            time.time(),
            validation,
        )
        logger.debug(f"Validation completed for {scan_id}: {validation}")

        # ---- Save into Standard DB ----
        sdb_doc = {
            "scan_id": scan_id,
            "region": region,
            "scan_type": scan_type,
            "target": target,
            "status": result.get("status", "unknown"),
            "result": result,        # raw scan result
            "validation": validation,
            "metrics": self.metrics.aggregate_stats().get(scan_id, {}),
            "timestamp": datetime.now(),
            "l_region_processed": False,   # flag for DataAugmentor
        }

        self.db.save_scan_result(sdb_doc)
        logger.info(f"Stored scan {scan_id} into Standard DB (SDB).")

        return scan_id, result

    async def run_benchmark(self, runs: int = 5, export_format: str = "both"):
        """Runs benchmark, exports metrics CSV, and generates a consolidated report."""
        logger.info(f"Running benchmark with {runs} runs...")

        tasks = []
        for _ in range(runs):
            tasks.append(self.run_single_scan("network", "full", ["192.168.56.102"]))
        await asyncio.gather(*tasks)

        # ---- Save metrics ----
        self.metrics.export_csv("benchmark_results.csv")
        logger.info("Metrics exported to benchmark_results.csv")

        # ---- Generate final consolidated report ----
        summary_lines = [
            "# Benchmark Pentest Report",
            f"**Generated on:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"**Total Runs:** {runs}",
            "\n## Results Summary:\n",
        ]

        for scan_id, result in self.scan_results.items():
            region = result.get("region", "unknown")
            status = result.get("status", "unknown")
            target = result.get("target", [])
            summary_lines.append(f"- **Scan {scan_id[:8]}** | Region: {region} | Status: {status} | Target: {target}")

            # Add vulnerabilities if present
            vulns = result.get("vulnerabilities", [])
            if vulns:
                summary_lines.append("  - Vulnerabilities:")
                for v in vulns:
                    summary_lines.append(f"    â€¢ {v.get('alert', 'N/A')} (Risk: {v.get('risk', 'N/A')})")

        summary_text = "\n".join(summary_lines)

        saved_files = export_to_pdf(summary_text, "benchmark_reports", "benchmark_summary")
        if saved_files:
            logger.info(f"Consolidated benchmark report saved: {saved_files}")
        else:
            logger.error("Failed to save benchmark report.")
