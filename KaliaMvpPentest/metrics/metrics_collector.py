import csv
import statistics
from typing import Dict, Any, List


class BenchmarkMetrics:
    """
    Collects timing, precision/recall, error rates for orchestrator runs,
    and supports aggregate benchmark statistics.
    """
    def __init__(self):
        self.records: List[Dict[str, Any]] = []

    def record_stage(self, scan_id: str, stage: str, status: str,
                     start: float, end: float, details: Dict[str, Any] = None, region: str = "unknown"):
        duration = end - start
        self.records.append({
            "scan_id": scan_id,
            "region": region,
            "stage": stage,
            "status": status,
            "duration_sec": duration,
            "details": details or {}
        })

    def record_validation(self, scan_id: str, region: str, metrics: Dict[str, Dict[str, float]]):
        """Attach validation metrics (precision, recall, f1) to a scan record."""
        self.records.append({
            "scan_id": scan_id,
            "region": region,
            "stage": "validation",
            "status": "completed",
            "duration_sec": 0,
            "details": metrics
        })

    def export_csv(self, filename: str = "benchmark_metrics.csv"):
        if not self.records:
            return
        keys = set()
        for r in self.records:
            keys.update(r.keys())
        keys = list(keys)

        with open(filename, "w", newline="") as f:
            writer = csv.DictWriter(f, fieldnames=keys)
            writer.writeheader()
            writer.writerows(self.records)

    def aggregate_stats(self) -> Dict[str, Any]:
        """Compute aggregate statistics for benchmark reporting."""
        durations = [r["duration_sec"] for r in self.records if r["stage"] == "scan_completion"]
        errors = [r for r in self.records if r["status"] != "completed"]

        if not durations:
            return {"avg_time": 0, "min_time": 0, "max_time": 0, "stddev_time": 0, "error_rate": 0.0}

        return {
            "avg_time": statistics.mean(durations),
            "min_time": min(durations),
            "max_time": max(durations),
            "stddev_time": statistics.pstdev(durations) if len(durations) > 1 else 0,
            "error_rate": len(errors) / len(self.records),
        }
