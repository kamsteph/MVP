# tests/test_exploitation_manager.py
from Network_Pentest.network.Sub_Unit_Manager_Network.network_exploitation_manager import ExploitationManagerAI
from back_end.event_bus import EventBus
from back_end.database import DatabaseManager
from metrics.validator import DBResultValidator

import pytest
@pytest.fixture
def db_manager():
    db = DatabaseManager()
    # Insert mock network scan
    db.results.insert_one({
        "_id": "test_network_1",
        "type": "initial_network_scan",
        "open_ports": [22, 80],
        "vulnerabilities": ["CVE-2023-1234"],
        "l_region_processed": False
    })
    # Insert mock web scan
    db.results.insert_one({
        "_id": "test_web_1",
        "type": "initial_web_scan",
        "endpoints": ["/login", "/admin"],
        "vulnerabilities": ["SQLi"],
        "l_region_processed": False
    })
    yield db
    # Clean up after test
    db.results.delete_many({"_id": {"$in": ["test_network_1", "test_web_1"]}})

@pytest.mark.integration
def test_network_validation_integration():
    db_manager = DatabaseManager()
    validator = DBResultValidator(db_manager)

    system_output = {
        "ip": "192.168.56.102",
        "open_ports": [22, 80],
        "vulnerabilities": ["CVE-2023-1234"]
    }

    results = validator.evaluate(system_output)

    assert results["ports"]["f1"] >= 0.5
    assert results["vulnerabilities"]["precision"] > 0

def test_web_validation(db_manager):
    validator = DBResultValidator(db_manager)
    system_output = {
        "_id": "test_web_1",
        "endpoints": ["/login", "/admin"],
        "vulnerabilities": ["SQLi"]
    }
    results = validator.validate_web(system_output,"https://example.com")
    assert results["endpoints"]["recall"] == 1
    assert results["vulnerabilities"]["precision"] == 1

@pytest.mark.asyncio
async def test_manager_with_simulated_executor(tmp_path, monkeypatch):
    db = DatabaseManager()
    bus = EventBus()

    # insert a candidate in adb
    db.adb_collection.insert_one({
        "id": "CVE-TEST-1",
        "affected_ports": [22],
        "msf_module": None,
        "exploit_tool": "sim",
        "exploit_command": "echo simulated"
    })

    # insert scan result that will match candidate
    scan = {"_id": "scan-test", "open_ports": [22], "vulnerabilities": ["CVE-TEST-1"], "target": ["127.0.0.1"]}

    # simulated execute_fn
    def fake_execute_fn(cve_entry):
        return {"status": "executed", "output": "simulated output", "tool": cve_entry.get("exploit_tool")}

    mgr = ExploitationManagerAI(db, bus, executor_execute_fn=fake_execute_fn)
    results = await mgr.handle_scan_result(scan, max_attempts=1, epsilon=0.0)
    assert isinstance(results, list)
    assert len(results) >= 1
    assert results[0].get("status") in ("executed", "executed_rpc", "success", "skipped_live_disabled")

