import json

import pytest
from unittest.mock import patch, MagicMock

from back_end.utils.ai_summary import generate_ai_summary


# Dummy class to simulate scan result entries
class DummyScanResult:
    def __init__(self, port, protocol, service, state, version=None):
        self.port = port
        self.protocol = protocol
        self.service = service
        self.state = state
        self.version = version

@pytest.mark.parametrize("scan_results,expected_contains", [
    ([], "No results found"),  # empty input
    ([DummyScanResult(80, "tcp", "http", "open", "Apache")], "http")
])
def test_generate_ai_summary_success(scan_results, expected_contains):
    mock_response = MagicMock()
    mock_response.status_code = 200
    # Dynamically include service name from scan_results if present
    if scan_results:
        mock_response.text = json.dumps({"response": f"Found {scan_results[0].service} service on port {scan_results[0].port}."}) + "\n"
    else:
        mock_response.text = ""

    with patch("back_end.ai_summary.requests.post", return_value=mock_response) as mock_post:
        summary = generate_ai_summary(scan_results)

        # Empty scan returns early, don't assert request called
        if scan_results:
            mock_post.assert_called_once()
            assert expected_contains in summary
        else:
            assert summary == "No results found in the scan."

def test_generate_ai_summary_failure():
    """Test that an HTTP error raises RuntimeError"""
    mock_response = MagicMock()
    mock_response.status_code = 500
    mock_response.text = "Server error"

    with patch("back_end.ai_summary.requests.post", return_value=mock_response):
        with pytest.raises(RuntimeError, match="Ollama request failed"):
            generate_ai_summary([DummyScanResult(22, "tcp", "ssh", "open")])
