# tests/test_validator_orchestrator.py
import pytest
import mongomock

from G_L_L.l_region.Aggregation_area.aggregator import ValidatorOrchestrator


class DummyDeception:
    def deploy_honeynet_sync(self, cfg):
        return {"target_url": "http://fake", "ip": "10.0.0.5"}

class DummyExploit:
    async def run_exploitation(self, step, target, **kwargs):
        return {"step": step, "target": target, "status": "success"}

@pytest.fixture
def fake_db():
    client = mongomock.MongoClient()
    db = client["test_pentest"]
    return db

@pytest.mark.asyncio
async def test_validator_orchestrator_dry_run(fake_db):
    deception = DummyDeception()
    web = DummyExploit()
    net = DummyExploit()

    # Patch DBManager-like behavior
    class FakeDBManager:
        def __init__(self, db):
            self.db = db
        def save_learning_data(self, data):
            return self.db.learning.insert_one(data)
        def get_all(self, name):
            return list(self.db[name].find({}))
        def save_validation(self, record):
            return self.db.validation.insert_one(record)

    db_manager = FakeDBManager(fake_db)
    orch = ValidatorOrchestrator(None, db_manager, deception, web, net)

    hyp = {
        "sandboxable": True,
        "honeypot_template": {"services": ["http"]},
        "web_steps": [{"kind": "exploit", "tool": "web_poc"}],
        "net_steps": [{"kind": "auth_attempt", "tool": "ssh_bruteforce"}]
    }

    orch._is_allowed_hypothesis = lambda h: True

    await orch._validate_hypothesis(hyp)

    # Assert DB got a validation entry
    saved = list(fake_db.validation.find({}))
    assert saved, "Validation results should be stored"
    assert saved[0]["validation"]["status"] in ["success", "failed"]
