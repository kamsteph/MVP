import pytest
from unittest.mock import AsyncMock, MagicMock
from mongomock import MongoClient

from Web_Pentest.web import ZAP_PROXY, ZAP_API_KEY
from Web_Pentest.web import WebManager
from Web_Pentest.web import WebExploitation
from Web_Pentest.web import Recon
from Web_Pentest.web import VulnScan
from back_end.event_bus import EventBus
from global_local_learner.l_region import LocalLearner
import os

ZAP_PROXY=os.getenv("ZAP_PROXY")
ZAP_API_KEY=os.getenv("ZAP_API_KEY")

@pytest.mark.asyncio
async def test_web_manager_component_layer4():
    """
    Layer 4 component test for WebManager:
    - Orchestrates Recon → Vulnerability Scan → Exploitation.
    - Uses in-memory substitutes (mongomock DB, fake EventBus).
    - No real network or external services.
    """

    # ------------------------
    # 1. Setup in-memory DB
    # ------------------------
    fake_client = MongoClient()
    fake_db = fake_client["pentest_db"]

    # ------------------------
    # 2. Setup fake EventBus
    # ------------------------
    bus = EventBus()
    bus.publish_task = MagicMock()  # track published events

    # ------------------------
    # 3. Setup engines and managers
    # ------------------------
    recon_engine = Recon()
    vuln_scanner = VulnScan(ZAP_PROXY,ZAP_API_KEY)
    exploitation_engine = WebExploitation(db=fake_db)

    # Patch run methods to avoid real network calls
    exploitation_engine.run_exploitation = AsyncMock(return_value={"status": "ok_web"})

    # Local learner stub
    local_learner = LocalLearner("web",bus)
    local_learner.learn_from_exploitation = MagicMock(return_value=[{"_id": "new_result"}])

    # ------------------------
    # 4. Initialize WebManager
    # ------------------------
    manager = WebManager(
        bus=bus,
        recon_engine=recon_engine,
        exploitation_engine=exploitation_engine,
        vuln_scanner=vuln_scanner,
        local_learner=local_learner,
        db=fake_db,
        gnn_model_path=None  # optional, can be None for this test
    )

    # ------------------------
    # 5. Define a sample web vulnerability task
    # ------------------------
    web_task = {
        "action": "run_exploitation",
        "targets": ["http://fake_target"],
        "vulnerabilities": [{"id": "WEB-2025-XYZ", "steps": [{"id": "WEB-STEP1"}]}]
    }

    # ------------------------
    # 6. Run orchestration
    # ------------------------
    result = await manager._run_exploitation(
        targets=web_task["targets"],
        vulnerabilities=web_task["vulnerabilities"]
    )

    # ------------------------
    # 7. Assertions
    # ------------------------
    # Exploitation engine was called for the target
    exploitation_engine.run_exploitation.assert_called_once()

    # Results contain the mocked status
    assert result["exploit_results"]["http://fake_target"]["status"] == "ok_web"

    # Local learner was fed the results
    local_learner.learn_from_exploitation.assert_called_once()

    # EventBus publishes new results for global learning
    # (triggered after learn_from_exploitation)
    bus.publish_task.assert_called()  # at least once
    published_event = bus.publish_task.call_args[0][0]
    assert published_event["region"] == "learning"
    assert published_event["source_region"] == "web"
    assert published_event["results_ids"][0] == "new_result"

    # DB remains consistent (in-memory mongomock)
    # Optionally check the DB has not crashed
    saved_results = list(fake_db.scan_results.find({}))
    assert isinstance(saved_results, list)
