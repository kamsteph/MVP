import pytest
from unittest.mock import AsyncMock, MagicMock, patch

from Network_Pentest.network import ExploitationManager
from Web_Pentest.web import WebExploitation
from back_end.event_bus import EventBus
from mongomock import MongoClient

@pytest.mark.asyncio
# Patch the NetworkExploitation class at the exact location where it's imported
# and used by the ExploitationManager class.
@patch('back_end.Regions.network.Sub_Unit_Manager_Network.network_exploitation_manager.NetworkExploitation')
async def test_exploitation_manager_component_layer4(MockNetworkExploitation):
    """
    Layer 4 component test.
    - Tests orchestration without real network calls.
    - Uses mocks to isolate the ExploitationManager logic.
    """

    # ------------------------
    # 1. Setup in-memory DB
    # ------------------------
    fake_client = MongoClient()
    fake_db = fake_client["pentest_db"]

    # ------------------------
    # 2. Setup fake EventBus
    # ------------------------
    bus = EventBus()
    bus.publish_task = MagicMock()

    # ------------------------
    # 3. Setup exploitation unit mocks
    # ------------------------
    web_exploit = WebExploitation(db=fake_db)
    web_exploit.run_exploitation = AsyncMock(return_value={"status": "ok_web"})

    # Configure the mocked NetworkExploitation instance and its run_exploitation method
    mock_net_exploit_instance = MockNetworkExploitation.return_value
    mock_net_exploit_instance.run_exploitation = AsyncMock(return_value={"status": "ok_net"})

    # ------------------------
    # 4. Setup ExploitationManager
    # ------------------------
    # The manager's __init__ will now use the mocked NetworkExploitation instance
    # provided by the @patch decorator.
    manager = ExploitationManager(db=fake_db, bus=bus)

    # Manually set the web exploit unit as before
    manager.web_exploit_unit = web_exploit

    # The manager's net_exploit_unit is already the mocked instance.

    # ------------------------
    # 5. Define a sample vulnerability scan
    # ------------------------
    vulnerability_entry = {
        "id": "CVE-2025-XYZ",
        "sandboxable": True,
        "honeypot_template": {"os": "linux"},
        "web_steps": [{"id": "WEB-1"}],
        "net_steps": [{"id": "NET-22", "port": 22}],
    }

    # ------------------------
    # 6. Run orchestration
    # ------------------------
    # The manager will call the mocked methods, avoiding timeouts.
    result = await manager.run_exploitation(vulnerability_entry, "http://fake_target")

    # ------------------------
    # 7. Assertions
    # ------------------------
    # Verify that the correct methods were called.
    web_exploit.run_exploitation.assert_called_once()
    mock_net_exploit_instance.run_exploitation.assert_called_once()

    # Verify the return value of the orchestration.
    assert result["status_web"] == "ok_web"
    assert result["status_net"] == "ok_net"

    # Verify that the database was interacted with correctly.
    saved = list(fake_db.scan_results.find({}))
    assert len(saved) == 1
    assert saved[0]["id"] == "CVE-2025-XYZ"

    # Verify that the event bus published the expected event.
    bus.publish_task.assert_called_once()
    published_event = bus.publish_task.call_args[0][0]
    assert published_event["action"] == "validation_result"
    assert published_event["result"]["status_web"] == "ok_web"
    assert published_event["result"]["status_net"] == "ok_net"