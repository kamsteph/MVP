1.Static checks (instant)

linters (flake8/ruff), type checks (mypy), formatting (black).

Why first: catches trivial mistakes before running Python code.

2.Pure unit tests (very fast, isolated)

Logic-only modules with no external deps (math, helpers, pure functions).

Include NN shape tests and small deterministic functions.

Use small mocks/stubs for dependencies.

Run frequently and on each commit.

3.Unit tests with light mocks (fast)

Tests that instantiate classes but patch heavy subsystems (DB, network, RL training).

Example: ExploitationManager orchestration test with learn_from_experience monkeypatched, fake_execute_fn, mongomock for DB.

4.Component tests / integration with in-memory substitutes (medium)

Use mongomock, simulated executors, fake EventBus.

Validate interactions between several units but still avoid real external services.

5.Model tests (deterministic, medium)

NN forward/backward shape tests, deterministic small training step on tiny batch (CPU).

Set random seeds to check deterministic behaviour.

6.Integration tests against real infra (slow)

Real MongoDB, optional msfrpcd/metasploit connections (if available), real network I/O.

Mark these with @pytest.mark.integration and skip in default runs unless environment available.

7.End-to-End tests (very slow, fragile)

Full pipeline: scan → adb matching → exploit → learning. Run rarely (nightly or on release branch).

8.Performance & Benchmarks (separate suite)

pytest-benchmark or asv for long-running benchmarks.

GPU/CPU profiling and memory profiling (pyinstrument, memory_profiler).

Run on dedicated runners (not on PRs by default).

9.Fuzzing / Property-based tests (optional)

Use Hypothesis for robustness of parsers / validators.

10.Security / penetration tests (manual / scheduled)

Real attacks, pentest tools — run in isolated lab only.