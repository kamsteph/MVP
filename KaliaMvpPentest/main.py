# backend/main.py
import json
import os
import uuid
from contextlib import asynccontextmanager
from datetime import datetime
from typing import List, Optional

from dotenv import load_dotenv
from fastapi import UploadFile, File, Form
from pydantic import BaseModel
from starlette.middleware.cors import CORSMiddleware

from Network_Pentest.network_pipeline import NetworkPipeline
from back_end.database import DatabaseManager
from back_end.event_bus import EventBus
from back_end.pentest_orchestrator import PentestOrchestrator, translator
from back_end.telemetry.progress_registry import progress_registry
from back_end.telemetry.tracker_manager import init_tracker
from back_end.websocket_bridge import WebSocketBridge
from pydantic_models.schema import UploadedFile, ScanRequest, PentestTask
from back_end.telemetry.aggregation_manager import AggregationManager

from fastapi import FastAPI, HTTPException

# --- Load environment ---
load_dotenv()
# msf_rpc_config = {
#     "host": os.getenv("MSF_HOST"),
#     "port": int(os.getenv("MSF_PORT")),
#     "password": os.getenv("MSF_PASSWORD")
# }

# --- FastAPI app and lifespan ---
@asynccontextmanager
async def lifespan(app: FastAPI):
    await ws_bridge.start()
    yield
    await ws_bridge.stop()

app = FastAPI(lifespan=lifespan)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # restrict in production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- Initialize core components ---
db_manager = DatabaseManager()
event_bus = EventBus()
tracker = init_tracker(db_manager, event_bus)

#l_network = LocalLearner(region="network", bus=event_bus)

# Initialize main pipeline (handles Recon → NetworkManager → VulnAIAgent)
network_pipeline = NetworkPipeline(model_path=None, device="cpu")

# Orchestrator gets access to bus and db, and delegates network region to the pipeline
orchestrator = PentestOrchestrator(db=db_manager,bus=event_bus,network_pipeline=network_pipeline)

ws_bridge = WebSocketBridge(event_bus)

aggregation_manager = AggregationManager(db=db_manager,bus=event_bus, model_name="ai_pentest_orchestrator_v1")

# --- Event subscriptions ---
#event_bus.subscribe("network", network_manager.handle_task)
#event_bus.subscribe("network_exploitation_results", l_network.handle_exploitation_results)
event_bus.subscribe("network_recon_done", network_pipeline.on_recon_done)
event_bus.subscribe("network_vuln_scan", network_pipeline.on_vuln_scan)


# --- FastAPI endpoints ---
@app.post("/scan")
async def start_scan(
        payload: str = Form(...),  # raw JSON string
        codebase_files: Optional[List[UploadFile]] = File(None),
        insider_files: Optional[List[UploadFile]] = File(None),
):
    """
    Triggers a new pentest scan.
    - `payload`: JSON-encoded string for scan metadata (validated by Pydantic).
    - `codebase_files`: optional file uploads for white scope.
    - `insider_files`: optional file uploads for grey scope.
    """

    # --- JWT Authentication (optional, enable later) ---
    # from back_end.auth import get_current_user
    # user_id = user["sub"]  # Unique user ID from token
    # claims = user["claims"]  # All JWT claims
    # You can log claims or restrict permissions here.
    # Example:
    # if "pentest:start" not in claims.get("permissions", []):
    #     raise HTTPException(status_code=403, detail="Permission denied")

    # --- Step 1. Parse and validate payload ---
    try:
        payload_dict = json.loads(payload)
        scan_request = ScanRequest(**payload_dict)  # validation

        attack_surface_raw = payload_dict.get("attack_surface") or []
        payload_dict["attack_surface"] = normalize_attack_surface_list(attack_surface_raw)

    except Exception as e:
        return {"error": f"Invalid payload: {e}"}

    # --- Step 2. Save uploaded files ---
    codebase_paths, insider_paths = [], []

    if codebase_files:
        for f in codebase_files:
            content = await f.read()
            path = f"/tmp/codebase_{f.filename}"
            with open(path, "wb") as fp:
                fp.write(content)

            file_doc = UploadedFile(
                id=str(uuid.uuid4()),
                filename=f.filename,
                stored_path=path,
                uploaded_at=datetime.now(),
                scope="codebase"
            )
            db_manager.save_codebase(file_doc.model_dump())
            codebase_paths.append(path)

    if insider_files:
        for f in insider_files:
            content = await f.read()
            path = f"/tmp/insider_{f.filename}"
            with open(path, "wb") as fp:
                fp.write(content)

            file_doc = UploadedFile(
                id=str(uuid.uuid4()),
                filename=f.filename,
                stored_path=path,
                uploaded_at=datetime.now(),
                scope="insider"
            )
            db_manager.save_codebase(file_doc.model_dump())
            insider_paths.append(path)

    # --- Step 3. Track orchestrator execution with telemetry ---
    task_id = str(uuid.uuid4())
    user_id = "anonymous"  # (Later replace with auth system)

    # wrapped = await aggregation_manager.telemetry.track_scan(
    #     task_id=task_id,
    #     user_id=user_id,
    #     func=orchestrator.submit_scan_request,
    #     region=scan_request.region,
    #     scan_type=scan_request.scan_type,
    #     scope=scan_request.scope,
    #     target=scan_request.target,
    #     cross_domain_insight=scan_request.cross_domain_insight,
    #     name=scan_request.name,
    #     description=scan_request.description,
    #     attack_surface=scan_request.attack_surface,
    #     codebase_files=codebase_paths,
    #     insider_files=insider_paths,
    #     social_media_url=scan_request.social_media_url if scan_request.region == "web" else None,
    # )
    # result = wrapped["result"]
    # telemetry = wrapped["telemetry"]

    # Broadcast telemetry in real time
    #event_bus.publish_event("scan_telemetry", telemetry)

    #--- Step 3. Call orchestrator with validated data ---
    result = await orchestrator.submit_scan_request(
        region=scan_request.region,
        scan_type=scan_request.scan_type,
        scope=scan_request.scope,
        target=scan_request.target,
        cross_domain_insight=scan_request.cross_domain_insight,
        name=scan_request.name,
        description=scan_request.description,
        attack_surface=scan_request.attack_surface,
        codebase_files=codebase_paths,
        insider_files=insider_paths,
        file_format=scan_request.file_format,
        social_media_url=scan_request.social_media_url if scan_request.region == "web" else None,

    )

    return result

class TextRequest(BaseModel):
    text: str


@app.post("/translate")
# --- JWT SECTION ---
# async def translate_surface(req: TextRequest, Authorize: AuthJWT = Depends()):
#     Authorize.jwt_required()
# --------------------------------------
async def translate_surface(req: TextRequest):
    result = translator.translate(req.text)
    return {
        "surface": result["surface"],
        "definition": result["definition"],
        "score": result["score"],
    }


@app.get("/scan_results")
# --- JWT SECTION ---
# async def get_scan_results(Authorize: AuthJWT = Depends()):
#     Authorize.jwt_required()
# --------------------------------------
async def get_scan_results():
    results = list(db_manager.standard_db.find({}, {"_id": 0}))
    return {"results": results}

from fastapi.responses import FileResponse

@app.get("/download_report/{task_id}")
# --- JWT SECTION ---
# async def download_report(task_id: str, Authorize: AuthJWT = Depends()):
#     Authorize.jwt_required()
# --------------------------------------
async def download_report(task_id: str):
    result = db_manager.standard_db.find_one({"id": task_id})
    if not result or "report_path" not in result:
        return {"error": "Report not found"}
    return FileResponse(result["report_path"], filename=os.path.basename(result["report_path"]))

@app.get("/progress/{task_id}", response_model=PentestTask)
# --- JWT SECTION ---
# async def get_progress(task_id: str, Authorize: AuthJWT = Depends()):
#     Authorize.jwt_required()
# --------------------------------------
async def get_progress(task_id: str):
    """Return progress info for a specific task."""
    task = await progress_registry.get(task_id)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    return task


@app.post("/task_progress")
# # --- JWT SECTION ---
# # async def update_from_bus(event: dict, Authorize: AuthJWT = Depends()):
# #     Authorize.jwt_required()
# # --------------------------------------
async def update_from_bus(event: dict):
    """Update task progress (called internally by EventBus or WebSocket)."""
    task_id = event.get("id")
    if not task_id:
        raise HTTPException(status_code=400, detail="Missing task id")

    await progress_registry.update(task_id, {
        "status": event.get("status", "running"),
        "progressMessage": f"Progress {event.get('progress', 0)}%",
    })
    return {"ok": True}


# @app.get("/protected")
# async def protected_route(user=Depends(get_current_user)):
#     return {"message": f"Hello {user['sub']}", "claims": user["claims"]}
# SECRET = "supersecret"
# users={}


# @app.post("/auth/register", status_code=201)
# def register(req: RegisterRequest):
#     if req.email in users:
#         raise HTTPException(status_code=400, detail="Email already exists")
#     hashed = bcrypt.hashpw(req.password.encode(), bcrypt.gensalt()).decode()
#     users[req.email] = {"name": req.name, "password": hashed}
#     Call the save to the wanted db_collection

#     return {"message": "User registered successfully"}


# @app.post("/auth/login")
# def login(req: LoginRequest):
#     user = users.get(req.email)
#     if not user or not bcrypt.checkpw(req.password.encode(), user["password"].encode()):
#         raise HTTPException(status_code=401, detail="Invalid credentials")
#     token = jwt.encode(
#         {"sub": req.email, "exp": time.time() + 3600},
#         SECRET,
#         algorithm="HS256"
#     )
#     return {"access_token": token, "token_type": "bearer"}

import re
from typing import List, Any, Dict

def normalize_attack_surface_list(raw_list: List[Any]) -> List[Dict[str, Any]]:
    """
    Normalize attack_surface entries into a list of dicts with a 'surface' key.
    Accepts:
      - "Open ports"
      - {"surface": "Open ports"}
      - {"name": "Open ports"}
      - stringified map like "{surface: Open ports}" or "{'surface': 'Open ports'}"
    """
    normalized = []
    if not raw_list:
        return normalized

    for entry in raw_list:
        # plain string -> convert to dict
        if isinstance(entry, str):
            s = entry.strip()
            # quick heuristic: if string looks like "{surface: Open ports}", try to extract
            if s.startswith("{") and ":" in s:
                # try to extract value after "surface" key
                m = re.search(r"surface\s*[:=]\s*['\"]?([^,'\"}]+)['\"]?", s, re.IGNORECASE)
                if m:
                    normalized.append({"surface": m.group(1).strip()})
                    continue
                # fallback: remove braces and use inner
                stripped = s.strip("{} ").strip()
                normalized.append({"surface": stripped})
            else:
                # plain surface string
                normalized.append({"surface": s})
            continue

        # dict-like
        if isinstance(entry, dict):
            if "surface" in entry and entry["surface"]:
                normalized.append({"surface": str(entry["surface"])})
                continue
            if "name" in entry and entry["name"]:
                normalized.append({"surface": str(entry["name"])})
                continue
            # fallback: take first string-like value
            val = None
            for k, v in entry.items():
                if isinstance(v, str) and v.strip():
                    val = v.strip()
                    break
            if val:
                normalized.append({"surface": val})
                continue
            # last fallback: stringify entry
            normalized.append({"surface": str(entry)})
            continue

        # unknown type -> stringify
        normalized.append({"surface": str(entry)})

    return normalized
