# backend/main.py
import json
import uuid
from contextlib import asynccontextmanager
from datetime import datetime
from typing import List, Optional

from dotenv import load_dotenv
from fastapi import FastAPI, UploadFile, File, Form
from pydantic import BaseModel
from starlette.middleware.cors import CORSMiddleware

from G_L_L.l_region.local_learner import LocalLearner
from back_end.bootstrap_network_cap import bootstrap_network_capability_matrix
from back_end.database import DatabaseManager
from back_end.event_bus import EventBus
from back_end.pentest_orchestrator import PentestOrchestrator, translator
from Network_Pentest.network.network_manager import NetworkManager
from back_end.websocket_bridge import WebSocketBridge
from pydantic_models.schema import UploadedFile, ScanRequest

# --- Load environment ---
load_dotenv()
# msf_rpc_config = {
#     "host": os.getenv("MSF_HOST"),
#     "port": int(os.getenv("MSF_PORT")),
#     "password": os.getenv("MSF_PASSWORD")
# }

# --- Bootstrap network capability matrix into MongoDB ---
bootstrap_network_capability_matrix()

# --- FastAPI app and lifespan ---
@asynccontextmanager
async def lifespan(app: FastAPI):
    await ws_bridge.start()
    yield
    await ws_bridge.stop()

app = FastAPI(lifespan=lifespan)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # restrict in production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- Initialize core components ---
db_manager = DatabaseManager()
event_bus = EventBus()
l_network = LocalLearner(region="network", bus=event_bus)
network_manager = NetworkManager(event_bus, db=db_manager, local_learner=l_network)
orchestrator = PentestOrchestrator(bus=event_bus, db=db_manager)
ws_bridge = WebSocketBridge(event_bus)

# --- Event subscriptions ---
#event_bus.subscribe("network", network_manager.handle_task)
event_bus.subscribe("network_exploitation_results", l_network.handle_exploitation_results)


# --- FastAPI endpoints ---
@app.post("/scan")
async def start_scan(
        payload: str = Form(...),  # raw JSON string
        codebase_files: Optional[List[UploadFile]] = File(None),
        insider_files: Optional[List[UploadFile]] = File(None),
):
    """
    Triggers a new pentest scan.
    - `payload`: JSON-encoded string for scan metadata (validated by Pydantic).
    - `codebase_files`: optional file uploads for white scope.
    - `insider_files`: optional file uploads for grey scope.
    """

    # --- Step 1. Parse and validate payload ---
    try:
        payload_dict = json.loads(payload)
        scan_request = ScanRequest(**payload_dict)  # validation
    except Exception as e:
        return {"error": f"Invalid payload: {e}"}

    # --- Step 2. Save uploaded files ---
    codebase_paths, insider_paths = [], []

    if codebase_files:
        for f in codebase_files:
            content = await f.read()
            path = f"/tmp/codebase_{f.filename}"
            with open(path, "wb") as fp:
                fp.write(content)

            file_doc = UploadedFile(
                id=str(uuid.uuid4()),
                filename=f.filename,
                stored_path=path,
                uploaded_at=datetime.now(),
                scope="codebase"
            )
            db_manager.save_codebase(file_doc.model_dump())
            codebase_paths.append(path)

    if insider_files:
        for f in insider_files:
            content = await f.read()
            path = f"/tmp/insider_{f.filename}"
            with open(path, "wb") as fp:
                fp.write(content)

            file_doc = UploadedFile(
                id=str(uuid.uuid4()),
                filename=f.filename,
                stored_path=path,
                uploaded_at=datetime.now(),
                scope="insider"
            )
            db_manager.save_codebase(file_doc.model_dump())
            insider_paths.append(path)

    # --- Step 3. Call orchestrator with validated data ---
    result = await orchestrator.submit_scan_request(
        region=scan_request.region,
        scan_type=scan_request.scan_type,
        scope=scan_request.scope,
        target=scan_request.target,
        cross_domain_insight=scan_request.cross_domain_insight,
        name=scan_request.name,
        description=scan_request.description,
        attack_surface=scan_request.attack_surface,
        codebase_files=codebase_paths,
        insider_files=insider_paths,
        social_media_url=scan_request.social_media_url if scan_request.region == "web" else None,

    )

    return result

class TextRequest(BaseModel):
    text: str


@app.post("/translate")
async def translate_surface(req: TextRequest):
    result = translator.translate(req.text)
    return {
        "surface": result["surface"],
        "definition": result["definition"],
        "score": result["score"],
    }


@app.get("/scan_results")
async def get_scan_results():
    results = list(db_manager.results.find({}, {"_id": 0}))
    return {"results": results}
