# back_end/validation/validator_orchestrator.py
import asyncio
import uuid
import logging
from typing import Dict, Any

from Network_Pentest.network.network_exploitation import NetworkExploitation
from back_end.event_bus import EventBus
from back_end.database import DatabaseManager
from defense.deception_learning import DeceptionLearning

logger = logging.getLogger("ValidatorOrch")
logger.setLevel(logging.INFO)

# Config guards (env or app config)
ALLOW_E_HONEYNET_RUNS = False  # set True only in dev/sandbox env
MAX_PARALLEL_VALIDATIONS = 2
VALIDATION_TIMEOUT = 300

class ValidatorOrchestrator:
    def __init__(self, bus: EventBus, db: DatabaseManager, deception: DeceptionLearning,net_exploit: NetworkExploitation):
        self.bus = bus
        self.db = db
        self.deception = deception
        self.net_exploit = net_exploit
        self._sem = asyncio.Semaphore(MAX_PARALLEL_VALIDATIONS)
        bus.subscribe("candidate_hypothesis", self._on_hypothesis)

    def _is_allowed_hypothesis(self, hypothesis: Dict[str, Any]) -> bool:
        # Example checks: ensure it's for an internal honeypot or e-honeynet
        return hypothesis.get("sandboxable", False) and ALLOW_E_HONEYNET_RUNS

    async def _on_validation_task(self, task: Dict[str, Any]):
        """Triggered only when UI requests validation."""
        hypothesis = task.get("input", {})
        if not hypothesis:
            logger.warning("No hypothesis provided for validation task.")
            return
        asyncio.create_task(self._validate_hypothesis(hypothesis))
    # async def _on_hypothesis(self, hypothesis: Dict[str, Any]):
    #     """Callback invoked when the correlator proposes a hypothesis to validate."""
    #     if not self._is_allowed_hypothesis(hypothesis):
    #         logger.info("Hypothesis rejected by policy or sandbox settings.")
    #         return

        # queue validation
        asyncio.create_task(self._validate_hypothesis(hypothesis))

    async def _validate_hypothesis(self, hypothesis: Dict[str, Any]):
        async with self._sem:
            run_id = str(uuid.uuid4())
            record = {
                "id": run_id,
                "hypothesis": hypothesis,
                "status": "running",
                "start_time": asyncio.get_event_loop().time()
            }
            self.db.save_scan_result({"validation": record})
            try:
                # 1) spin up e-honeynet according to hypothesis config
                honeypot_cfg = hypothesis.get("honeypot_template", {})
                hp = await asyncio.get_event_loop().run_in_executor(
                    None,
                    lambda: self.deception.deploy_honeynet(honeypot_cfg),

                )
                # hp returns honeypot metadata and endpoints to attack

                # 2) run exploit steps (web then network etc.) inside sandbox
                results = {}
                # if "web_steps" in hypothesis:
                #     # run sequentially or parallel depending on hypothesis
                #     for step in hypothesis["web_steps"]:
                #         res = await self.web_exploit.run_exploitation(step, hp["target_url"], timeout=VALIDATION_TIMEOUT)
                #         results.setdefault("web", []).append(res)

                if "net_steps" in hypothesis:
                    for step in hypothesis["net_steps"]:
                        res = await self.net_exploit.run_exploitation(step, hp["ip"], port=step.get("port"))
                        results.setdefault("network", []).append(res)

                # 3) collect evidence and save
                record["status"] = "success"
                record["results"] = results
                record["end_time"] = asyncio.get_event_loop().time()
                self.db.save_scan_result({"validation": record})
                # 4) publish results back to local/global learners
                self.bus.publish_task({"region": "learning", "action": "validation_result", "validation": record})
                logger.info("Hypothesis validated", run_id)
            except Exception as e:
                record["status"] = "failed"
                record["error"] = str(e)
                record["end_time"] = asyncio.get_event_loop().time()
                self.db.save_scan_result({"validation": record})
                logger.exception("Validation error: %s", e)
