# tests/test_validator_orchestrator.py
import pytest
from unittest.mock import AsyncMock, MagicMock

from global_local_learner.l_region.Aggregation_area.aggregator import ValidatorOrchestrator


@pytest.fixture
def setup_orchestrator():
    bus = MagicMock()
    db = MagicMock()
    deception = MagicMock()
    web_exploit = AsyncMock()
    net_exploit = AsyncMock()

    orch = ValidatorOrchestrator(bus, db, deception, web_exploit, net_exploit)
    return orch, bus, db, deception, web_exploit, net_exploit

def test_subscription_on_init(setup_orchestrator):
    orch, bus, *_ = setup_orchestrator
    bus.subscribe.assert_called_once()
    args = bus.subscribe.call_args[0]
    assert args[0] == "candidate_hypothesis"
    assert callable(args[1])

@pytest.mark.asyncio
async def test_on_hypothesis_rejected(setup_orchestrator):
    orch, bus, db, *_ = setup_orchestrator

    bad_hypothesis = {"sandboxable": False}
    await orch._on_hypothesis(bad_hypothesis)

    db.save_scan_result.assert_not_called()
    bus.publish_task.assert_not_called()

@pytest.mark.asyncio
async def test_validate_hypothesis_happy_path(setup_orchestrator, monkeypatch):
    orch, bus, db, deception, web_exploit, net_exploit = setup_orchestrator

    # Force allow sandbox
    monkeypatch.setattr("back_end.Regions.l_region.Aggregation_area.aggregator.ALLOW_E_HONEYNET_RUNS", True)

    # Mocks
    deception.deploy_honeynet.return_value = {"target_url": "http://honeypot", "ip": "10.0.0.5"}
    web_exploit.run_exploitation.return_value = {"status": "ok_web"}
    net_exploit.run_exploitation.return_value = {"status": "ok_net"}

    hypothesis = {
        "sandboxable": True,
        "honeypot_template": {"os": "linux"},
        "web_steps": [{"id": "CVE-123"}],
        "net_steps": [{"id": "EXP-456", "port": 22}]
    }

    await orch._validate_hypothesis(hypothesis)

    # DB saves at least twice (start + success)
    assert db.save_scan_result.call_count >= 2

    # Both exploit engines called
    web_exploit.run_exploitation.assert_called_once()
    net_exploit.run_exploitation.assert_called_once()

    # Publish back to learning
    bus.publish_task.assert_called_once()
    args = bus.publish_task.call_args[0][0]
    assert args["action"] == "validation_result"
    assert "validation" in args

@pytest.mark.asyncio
async def test_validate_hypothesis_failure_path(setup_orchestrator, monkeypatch):
    orch, bus, db, deception, *_ = setup_orchestrator

    monkeypatch.setattr("back_end.Regions.l_region.Aggregation_area.aggregator.ALLOW_E_HONEYNET_RUNS", True)

    deception.deploy_honeynet.side_effect = RuntimeError("honeynet deploy failed")

    hypothesis = {"sandboxable": True, "honeypot_template": {}}

    await orch._validate_hypothesis(hypothesis)

    # DB should record failure
    saved = db.save_scan_result.call_args_list[-1][0][0]
    assert saved["validation"]["status"] == "failed"
    assert "error" in saved["validation"]
